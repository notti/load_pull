\documentclass[12pt,a4paper,parskip=full,abstract=true,BCOR=10mm,twoside,open=right]{scrreprt}
\KOMAoption{bibliography}{totoc}
\KOMAoption{listof}{totoc}

\usepackage[ngerman,english]{babel}
\usepackage[utf8]{inputenc}

%drawings

\usepackage[pdftex]{graphicx}
\graphicspath{{graphics/}}
\usepackage{tikz}
\usepackage{circuitikz}
\usetikzlibrary{positioning,dsp,chains,fit,scopes,calc,backgrounds,arrows,decorations.pathmorphing,bending,arrows.meta,shapes.misc,matrix,patterns}

\include{rfsymbols}

%units

\usepackage[binary-units,retain-explicit-plus]{siunitx}
\DeclareSIUnit \belm {Bm}
\DeclareSIUnit \belfs {BFS}
\DeclareSIUnit \samples {S}
\sisetup{per-mode = symbol}

%plots

\usepackage{pgfplots}
\pgfplotsset{compat=1.12}
\pgfplotsset{every axis plot/.append style={smooth},every axis/.append style={grid=major,legend style={font=\footnotesize}}}
\usepgfplotslibrary{smithchart}
\usepgfplotslibrary{units}
\usepgfplotslibrary{fillbetween}
\pgfplotsset{unit code/.code 2 args={\si{#1#2}}}

\usepgfplotslibrary{external}
\tikzsetexternalprefix{figures/}
\tikzexternalize[mode=list and make]
\tikzexternalwritetomakefile{}
\tikzexternalwritetomakefile{.DELETE_ON_ERROR:}
\tikzexternalwritetomakefile{}

%math

\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{gensymb}

\providecommand{\abs}[1]{\lvert#1\rvert}
\makeatletter
\newcommand\xleftrightarrow[2][]{%
  \ext@arrow 9999{\longleftrightarrowfill@}{#1}{#2}}
\newcommand\longleftrightarrowfill@{%
  \arrowfill@\leftarrow\relbar\rightarrow}
\makeatother

%source

\usepackage{listings}
\lstset{language=Matlab,numbers=left,numberstyle=\tiny,stepnumber=5,numbersep=5pt,frame=single,
breaklines=true,postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
captionpos=b,escapeinside={(*}{*)},mathescape=true}
\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}

%stuff

\usepackage{url}
\usepackage{tocloft} %table of contents modification
\usepackage{subcaption} %subfigures
\usepackage{placeins} % keep floats in check (=sections where they belong)
\usepackage{booktabs} % nicer tables
\usepackage{lipsum} % TODO remove in final
\usepackage{cite}

\usepackage{scrlayer-scrpage}
\pagestyle{scrheadings}
\automark[chapter]{chapter}
\automark*[section]{}

\usepackage[colorlinks,hyperindex,plainpages=false,
pdftitle={FPGA-based Load-Pull Measurement System},
pdfauthor={Gernot Vormayr},
pdfsubject={Diploma thesis},
pdfpagelabels %,hidelinks
]{hyperref}

% lots of acronyms
\usepackage[acronym]{glossaries}

\newacronym{fpga}{FPGA}{field programmable gate array}
\newacronym{iq}{IQ}{in-phase/quadrature-phase}
\newacronym[longplural={general-purpose inputs/outputs}]{gpio}{GPIO}{general-purpose input/output}
\newacronym{fir}{FIR}{finite impulse response}
\newacronym{gui}{GUI}{graphical user interface}
\newacronym{dc}{DC}{direct current}
\newacronym{ui}{UI}{user interface}
\newacronym{rf}{RF}{radio frequency}
\newacronym{pa}{PA}{power amplifier}
\newacronym{mw}{MW}{microwave}
\newacronym{if}{IF}{intermediate frequency}
\newacronym{ram}{RAM}{random access memory}
\newacronym{sparam}{S-parameter}{scattering parameter}
\newacronym{dut}{DUT}{device under test}
\newacronym{emt}{EMT}{electromechanical tuner}
\newacronym{vna}{VNA}{vector network analyzer}
\newacronym{elp}{ELP}{envelope load-pull}
\newacronym{pc}{PC}{personal computer}
\newacronym{adc}{ADC}{analog-to-digital converter}
\newacronym{dac}{DAC}{digital-to-analog converter}

\makeglossaries

\usepackage[noabbrev]{cleveref} %needs to be last

\begin{document}
\begin{titlepage}
    \enlargethispage{1cm}
    \centering
    \vspace*{5cm}
    {\Huge \textbf{Diploma thesis}}\\
    \vspace*{1cm}
    {\Large FPGA-based Load-Pull Measurement System}

    \vspace*{2cm}
    {\large Gernot ~\textsc{Vormayr} \\ 0425210 \\ } ~\\

    \vspace*{2cm}
    {\today } ~\\

    \vfill
    {Supervisors} ~\\\vspace*{0.1cm}
    {Ass.Prof. Dipl.-Ing. Dr.techn. \large Holger ~\textsc{Arthaber}} ~\\
    {Univ.Ass. Dipl.-Ing. Dr.techn. \large Thomas ~\textsc{Faseth}}
    \vspace*{2cm}

    \rule{\linewidth}{0.4pt}
    \begin{minipage}[t]{0.55\linewidth}
        \flushleft
        \begin{large}
            EMCE - Institute of Electrodynamics, Microwave and Circuit Engineering
        \end{large}\\
        Vienna University of Technology
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.27\linewidth}
        \flushright
        Gusshausstrasse 25\\
        1040 Vienna\\
        www.emce.tuwien.ac.at
    \end{minipage}
    \vspace*{-3pt}
    \rule{\linewidth}{0.4pt}
    \clearpage
\end{titlepage}

\begin{abstract}
    %TODO
    \lipsum[1-5]
\end{abstract}

\begin{otherlanguage}{ngerman}
\begin{abstract}
    %TODO
    \lipsum[1-5]
\end{abstract}
\end{otherlanguage}

\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
    %TODO
    \lipsum[1]
\end{abstract}

\tableofcontents

\chapter{Introduction}
\label{chap:introduction}

At \gls{rf} and \gls{mw} frequencies, the circuit theory with lumped elements, where
voltage and current do not vary over the physical dimension of the elements, is of limited
value. The wavelength at these frequencies is of the order of the circuit
element dimensions. This means that transmission line theory has to be used instead \cite{pozar_mw_engineering_2011}.
This theory applies circuit theory to infinitesimal small pieces of the lumped elements
and introduces the concept of forward and backward traveling power waves.

For this reason, instead of impedance- and admittance matrices, \glspl{sparam}
are commonly used in \gls{rf} and \gls{mw} circuit engineering to describe
$N$-ports (see \cref{fig:sparam,eq:sparam} for a 2-port). $a_n$ denotes the incident and
$b_n$ the reflected power wave. Complex valued $S_{nn}$ represents the
part of $a_n$ that gets reflected at port $n$, where as $S_{nm}$ is the part of $a_m$ that
is transmitted to $b_n$. A set of \glspl{sparam} are only valid for a specific frequency, a
characteristic impedance $Z_0$, and a reference plane (port 1 and port 2 in \cref{fig:sparam}).

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \matrix (box)
        [matrix of nodes,%
         nodes in empty cells,
         nodes={dspnodeopen},
         column sep=1cm,
         row sep=2cm]
        {
            |[coordinate]| & &[4cm] & |[coordinate]| \\
            |[coordinate]| & & & |[coordinate]| \\
        };
        \draw[-latex] (box-1-1) node[anchor=east] {$a_1$} -- (box-1-2);
        \draw[-latex] (box-1-2) -- node[above] {$S_{21}$} (box-1-3);
        \draw[-latex] (box-1-3) -- (box-1-4) node[anchor=west] {$b_2$};

        \draw[latex-] (box-2-1) node[anchor=east] {$b_1$} -- (box-2-2);
        \draw[latex-] (box-2-2) -- node[above] {$S_{12}$} (box-2-3);
        \draw[latex-] (box-2-3) -- (box-2-4) node[anchor=west] {$a_2$};

        \draw[-latex] (box-1-2) to[bend left=30] node[right] {$S_{11}$} (box-2-2);
        \draw[latex-] (box-1-3) to[bend right=30] node[left] {$S_{22}$} (box-2-3);

        \draw ($(box-1-2) + (0,0.7cm)$) rectangle ($(box-2-3) - (0,0.7cm)$);

        \draw[dashed] (box-1-2) -- ++(0,1.5cm) node[anchor=south] {Port 1};
        \draw[dashed] (box-1-3) -- ++(0,1.5cm) node[anchor=south] {Port 2};

        \draw[dashed] (box-2-2) -- ++(0,-1cm);
        \draw[dashed] (box-2-3) -- ++(0,-1cm);
    \end{tikzpicture}
    \caption{\Glspl{sparam} of a 2-port}
    \label{fig:sparam}
\end{figure}

\begin{equation}
    \label{eq:sparam}
    \begin{pmatrix} b_1 \\ b_2 \end{pmatrix} = \begin{pmatrix} S_{11} & S_{12} \\ S_{21} & S_{22} \end{pmatrix} \begin{pmatrix} a_1 \\ a_2 \end{pmatrix}
\end{equation}

In a 1-port there is only $S_{11}$. This parameter is equivalent to the reflection
coefficient $\Gamma$ and can be also expressed by the input impedance $Z_{in}$ (see
\cref{eq:s11ref} as shown in \cite{pozar_mw_engineering_2011}). This does not necessarily hold for 2-ports, since for a fully
connected 2-port, also reflections from the device connected at the other port
can be seen.
\begin{equation}
    \label{eq:s11ref} \Gamma = S_{11} = \frac{Z_{in}-Z_0}{Z_{in}+Z_0}
\end{equation}

One way to measure \glspl{sparam} at a specific frequency would be with connecting
a matching impedance $Z_0$. To measure e.g. $S_{11}$ a matching impedance has to
be connected to port 2. According to \cref{eq:s11ref} the reflected wave $a_2$
at port 2 is zero in this case. This means that measurements at port 1 can only see the
reflections caused by $S_{11}$. $S_{11}$ can now be calculated by measuring the incident
and reflected wave at port 1 (see \cref{eq:s11}) \cite{agilent_an_154}.
\begin{align}
    \label{eq:s11} S_{11} & = \left.\frac{b_1}{a_1} \right\rvert_{a_2 = 0}\\
    \label{eq:s21} S_{21} & = \left.\frac{b_2}{a_1} \right\rvert_{a_2 = 0}
\end{align}
Because of connectors and cabling it is often impossible to connect exact matches. Therefor
\glspl{sparam} are measured by sending a power wave into port 1 of the \gls{dut}, measuring
$a_n$ and $b_n$. After that the measurement is repeated with port 2. With measurements from
both ports and calibration measurements (to account for errors caused by connectors and
cabling) it is possible to determine every \gls{sparam}. \Glspl{vna} use this method
and can make automated measurements at various frequencies.

As long as a network behaves linearly with incident small signals, the \glspl{sparam}
fully describe this network at a specific frequency. Thus they can also be used
to model amplifiers, as long as they exhibit controlled and linear behaviour. Since
class-A \glspl{pa} are nearly linear, \glspl{sparam} can be used to describe the small
signal behaviour. But those \glspl{pa} exhibit a very low efficiency of \SI{50}{\percent}.
In modern \gls{rf} and \gls{mw} application the efficiency is increased with input and
output matching networks, that improve the performance. This comes at the cost of non
linear behaviour of the \gls{pa} \cite{ghannouchi_load-pull_2013}.

Because of these non linearities more complex models and verification systems are
needed. One way to measure the characteristics of a non linear system is the
{\it load-pull} (see \cref{fig:load_coeff}). This measurement system presents a
controllable load impedance (output tuner) to the \gls{dut}. The fixed input tuner is
needed to match the input of the \gls{dut} to the source. Load-pull can be used for obtaining the
\gls{dut} characteristics, and for verifying an implementation. This system also
allows to test the \gls{dut} under realistic working conditions.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \draw node[source] (source) {}
              node[tuner,right=of source,label=above:{fixed input tuner}] (ituner) {}
              node[dut,right=of ituner] (dut) {}
              node[tuner,right=2 of dut,label=above:{output tuner}] (otuner) {}
              node[match,right=of otuner,label=above:{$Z_0$}] (match) {}
              node[rground,right=0.3 of match,rotate=90,anchor=center] (ground) {};
        \draw ($(dut)!.5!(otuner)$) node[coordinate] (plane) {};

        \draw (source) -- (ituner) -- (dut) -- (otuner) -- (match) -- (ground);

        \draw [dashed] ($(plane) + (0,2)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,2.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};

    \end{tikzpicture}
    \caption{Load reflection coefficient}
    \label{fig:load_coeff}
\end{figure}

The \cref{eq:gl,eq:zl} show the relations between the load reflection coefficient $\Gamma_L$,
the incident wave $a_2$, the reflected
wave $b_2$, and the load impedance $Z_L$ at port 2 of \cref{fig:sparam,fig:load_coeff}. $Z_0$
is the characteristic impedance of the system \cite{hashmi_highly_2011}.
\begin{align}
    \label{eq:gl} \Gamma_L & = \frac{a_2}{b_2} \\
    \label{eq:zl} \Gamma_L & = \frac{Z_L-Z_0}{Z_L+Z_0}
\end{align}
The output tuner in \cref{fig:load_coeff} synthesizes an appropriate $\Gamma_L$
either by varying the phase and magnitude of the reflected wave $a_2$ or by varying
the load impedance $Z_L$. This means, that it is possible to build a load-pull
setup by either using a passive tuner, or feeding a modified wave back to the
\gls{dut}.

There are various types of load-pull measurement setups, which have different
characteristics. One important features is the repeatability of reflection
coefficients. The repeatability is needed to ensure accurate application
specific device models. Another important factor is the tuning range and
distribution (e.g. \cref{fig:range_passive}). Usually passive load-pull
systems have a more limited tuning range than active ones, but provide a
better repeatability \cite{ghannouchi_load-pull_2013}. Tuner speed and tuner
resolution is an additional trade off. High resolution is needed since \glspl{pa} are
highly sensitive to impedance variations. However a high resolution incurs
a slow tuner speed. An exemplary resolution can be seen in \cref{fig:generic_emt}.
Power handling capability is another extremely important factor. The load-pull
setup has to be capable to sustain the power presented to the tuner without
damage. Which load-pull setup to choose for a specific \gls{dut} depends on
these requirements.

\begin{figure}[htb]
    \begin{subfigure}[b]{.5\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth]
                \addplot[blue,is smithchart cs,mark=o,only marks] file {testdata/generic_emt.data};
            \end{smithchart}
        \end{tikzpicture}
        \caption{\Gls{emt}}
        \label{fig:generic_emt}
    \end{subfigure}%
    \begin{subfigure}[b]{.5\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth]
                \node [circle,draw,pattern=crosshatch,minimum size=.6\linewidth] (0,0) {};
            \end{smithchart}
        \end{tikzpicture}
        \caption{Passive load-pull system}
        \label{fig:range_passive}
    \end{subfigure}
    \caption{Generic representation of achievable tuning range/points passive load-pull}
\end{figure}

Passive load-pull systems are based on the block diagram in \cref{fig:load_coeff}. Depending on
the desired measurements, additional circuit elements like directional couplers,
power meters, and oscilloscopes are needed. For higher power measurements additional
amplifiers and attenuators, to reduce the output power to acceptable levels, might also
be needed. These additional components, the cabling, and connectors add additional loss
on the reflection path, leading to achievable reflection levels $\abs{\Gamma_L} < 1$ with
a maximum usually around 0.75 \cite{de_groote_introduction_2008} (see \cref{fig:range_passive}).

Typical tuners used, consist of a transmission line and a probe, that introduces a mismatch
by adding a parallel susceptance. Varying the position of the probe along the transmission
line changes the phase of the impedance mismatch and the distance the magnitude \cite{hashmi_highly_2011}.
Automated positioning can be achieved by adding motors. These tuners are called \glspl{emt}.
Those have to be calibrated before use and achieve reflection levels like in
\cref{fig:generic_emt} with up to 10000 points \cite{ghannouchi_load-pull_2013}.

If higher $\abs{\Gamma_L}$-levels  are needed (even levels $> 1$), active load-pull setups
can be used. There are two categories: closed- and open loop.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \draw node[dut] (dut) {}
              node[circulator,right=2 of dut] (circ) {}
              node[vmatch,right=of circ,label=above:{Attenuator},yshift=1cm] (att) {}
              node[vphase,right=1.5 of att,label=above:{Phase shift}] (phase) {}
              node[amplifier,right=of circ,label=above:{Amplifier},yshift=-1cm] (amp) {};

        \draw ($(dut)!.5!(circ)$) node[coordinate] (plane) {};

        \draw (dut) -- (circ.A);
        \draw (circ.B) -- ($(circ.B |- att)!.5!(att)$) node[coordinate] (upper) {} -- (att) -- (phase) -- ++(1,0) |- (amp) -- ($(circ.C |- amp)!.5!(amp)$) node[coordinate] (lower) {} -- (circ.C);

        \draw [-latex] ($(circ.B) + (-0.2,0.2)$) -- node[sloped,above] {$b_2$} ($(upper) + (-0.2,0.2)$);
        \draw [latex-] ($(circ.C) + (-0.2,-0.2)$) -- node[sloped,below] {$a_2$} ($(lower) + (-0.2,-0.2)$);

        \draw [dashed] ($(plane) + (0,2)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,2.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};
    \end{tikzpicture}
    \caption{Active closed loop load-pull block diagram}
    \label{fig:active_closed_loop}
\end{figure}

Active closed loop load-pull setups generate a modified reflected wave $a_2$ by
modifying the phase and magnitude of $b_2$ and feeding it back to the \gls{dut}.
The functional block diagram which can be seen in \Cref{fig:active_closed_loop}
is an example of such an active closed loop load-pull setup. With the circulator
the power wave $b_2$ is fed to a variable attenuator, a phase shifter and a
amplifier. These elements enable modifying the phase and the magnitude of $b_2$,
which is again fed back to the \gls{dut} with the circulator. Because of limited
isolation provided by real world circulators this system will oscillate if the loop gain
exceeds the isolation \cite{ghannouchi_load-pull_2013}. This can be circumvented with
an isolator after the amplifier. Another way to improve the stability of the system
is to introduce a bandpass filter into the loop.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \draw node[dut] (dut) {}
              node[isolator,right=2 of dut,rotate=180,anchor=east] (iso) {}
              node[amplifier,right=of iso.west,label=above:Amplifier] (amp) {}
              node[vphase,right=of amp,label=below:{Phase Shift}] (shift) {}
              node[vmatch,right=of shift,label=above:{Attenuator}] (att) {}
              node[source,right=of att,label=below:{Phase Locked Source}] (source) {};

        \draw ($(dut)!.5!(iso)$) node[coordinate] (plane) {};

        \draw (dut) -- (iso) -- (amp) -- (shift) -- (att) -- (source);
        \draw [latex-] ($(iso.west) + (0.2,-0.2)$) -- node[below] {$a_2$} ($(amp.west) + (-0.2,-0.2)$);

        \draw [dashed] ($(plane) + (0,2)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,2.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};
    \end{tikzpicture}
    \caption{Active open loop load-pull block diagram}
    \label{fig:active_open_loop}
\end{figure}

Active open loop load-pull setups work by generating a phase coherent wave with
an external signal generator (see \cref{fig:active_open_loop}). The open loop
approach has the advantage, that it can't oscillate, since there is no closed loop.
It works by generating a signal with a source, that is locked to the generator driving the
source port of the \gls{dut}. Phase and magnitude can be adjusted with the attenuator and
phase shifter. A disadvantage of the open loop system is that the generated wave at
the load generator is equivalent to the one on the source side. This implies that the reflection coefficient
$\Gamma_L$ depends on the large-signal \glspl{sparam} $S_{21}$ and $S_{22}$ of the \gls{dut}.
Therefore, an iterative approach is needed to be able to achieve specific $\Gamma_L$ \cite{muller_comparison_1994}.

The following chapters introduce an active closed loop load-pull system, which
is built with a digital attenuator, phase shifter, and loop filter implemented
in a \gls{fpga}.

% ===========================================================================

\chapter{\glsentryshort{fpga}-based Load-Pull Measurement System}

The active closed loop load-pull measurement system mentioned in
\cref{chap:introduction} can't synthesize harmonically independent
reflection coefficients, which are needed in the design of high-efficiency
\glspl{pa}. Furthermore it depicts a strong interdependency of magnitude
and phase of the reflection coefficient $\Gamma_L$ on both phase shifter
and attenuator settings \cite{pozar_mw_engineering_2011}. To overcome these
limitations an \gls{elp} measurement system was designed.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[circulator,right=2 of dut,label=below:circ] (circ) {}

              node[coordinate,right=of circ,yshift=1.5cm] (uppernode) {}
              node[coordinate,right=of circ,yshift=-1.5cm] (lowernode) {}

              node[amplifier,right=0.5 of lowernode,label=above:amp] (amp) {}
              node[mixer,right=of amp,label=below:mix2] (upmix) {}

              (uppernode -| upmix) node[mixer,label=above:mix1] (downmix) {}

              ($(upmix)!.5!(downmix)$) node[mixer] (mul) {}
              node[rotate=90,anchor=south] at (mul.west) {mul}

              node[right=0.5 of mul] (gamma) {$\Gamma_{set} = X + j Y$}
              node[source,right=0.5 of gamma,scale=0.7,label=right:$f_0$] (lo) {};

        \draw ($(dut)!.5!(circ)$) node[coordinate] (plane) {};

        \draw [latex-] ($(amp.west |- uppernode) + (-0.2,0.2)$) -- node[sloped,above] {$b_2$} ($(uppernode) + (-0.4,0.2)$);
        \draw [-latex] ($(amp.west) + (-0.2,-0.2)$) -- node[below] {$a_2$} ($(lowernode) + (-0.4,-0.2)$);

        { [rounded corners=2pt]
            \draw (dut) -- (circ.A);
            \draw [-latex] (circ.B) -- ($(circ.B |- uppernode)!.5!(uppernode)$) node[coordinate] (upper) {} -- (downmix);
            \draw [-latex] (amp) -- ($(circ.C |- amp)!.5!(lowernode)$) node[coordinate] (lower) {} -- (circ.C);
            \draw [-latex] (lo) |- (downmix);
            \draw [-latex] (lo) |- (upmix);
        }
        \draw [-latex] (gamma) -- (mul);
        { [start chain,every on chain/.style={join=by -latex}]
            \chainin (downmix);
            { [every on chain/.style={join=by {double,-latex}}]
                \chainin (mul);
                \chainin (upmix);
            }
            \chainin (amp);
        }

        \draw [dashed] ($(plane) + (0,2)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,3)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$a_{2}$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-2)$) node[anchor=west] {$b_{2}$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};
    \end{tikzpicture}
    \caption{Generic block diagram \gls{elp}}
    \label{fig:elp}
\end{figure}

Instead of traditional active closed loop load-pull, this system generates the
load coefficient at baseband or \gls{if}. The basic principle of this system
can be seen in \cref{fig:elp}. A circulator is used to split the incident and
reflected wave. The mixer \textit{mix1} is used for shifting the spectrum to
the baseband and for \gls{iq} demodulation. This \gls{iq} signal is then
multiplied by the complex valued $\Gamma_{set}$ (\textit{mul}), thus creating a specific
reflection coefficient $\Gamma_L$. Mixer \textit{mix2} is used for modulating
the \gls{iq} signal and shifting the signal back to the desired \gls{rf} \cite{williams_experimental_2005}.

The multiplication can be done in the analog domain, as has been described
by \cite{williams_experimental_2005}. This has the disadvantage, that
an additional image will be generated by the multiplicator \textit{mul},
if there are amplitude imbalances in the output
of the demodulator \textit{mix1}. Since this image is very close to the
carrier signal, it can't be filtered away \cite{hashmi_agile_2010}.

\begin{figure}[htb]
    \centering
    \resizebox{\linewidth}{!}{
    \begin{tikzpicture}
        \pgfdeclarelayer{foreground}
        \pgfsetlayers{background,main,foreground}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[dircoupler,right=2 of dut,label=below:dir] (dirvna) {}
              node[oscilloscope,above=of dirvna.A2,anchor=A1] (oszivna) {}
              node[circulator,right=of dirvna,label=below:circ] (circ) {}

              node[coordinate,right=of circ,yshift=1.5cm] (uppernode) {}
              node[coordinate,right=of circ,yshift=-1.5cm] (lowernode) {}

              (lowernode) node[amplifier,label=above:amp] (amp) {}
              node[mixer,right=of amp,label=above:mix3] (upmix) {}
              node[lowpass,right=of upmix,label=above:f3] (antialias) {}
              node[adc,right=of antialias,label=above:dac] (dac) {}
              node[empty,right=of dac,label=above:buffer2] (outbuf) {}
              node[mixer,right=of outbuf] (mul) {}
              node[rotate=90,anchor=north] at (mul.east) {mul}

              (uppernode -| upmix) node[mixer,label=below:mix1] (downmix) {}
              node[bandpass,right=of downmix,label=below:f1] (bp) {}
              node[adc,right=of bp,label=below:adc] (adc) {}
              node[empty,right=of adc,label=below:buffer1] (inbuf) {}
              node[mixer,right=of inbuf] (shift) {}
              node[rotate=90,anchor=north] at (shift.east) {mix2}

              ($(shift)!.5!(mul)$) node[allpass,rotate=90] (H) {}
              node[rotate=90,anchor=north] at (H.south) {f2}

              node[source,above=of downmix.center,scale=0.7,label=right:$f_0 - \SI{70}{\mega\hertz}$] (downsource) {}
              node[source,above=of adc.center,scale=0.7,label={[fill=white]right:$\SI{100}{\mega\hertz}$}] (sample) {}
              node[source,above=of shift.center,scale=0.7,label=right:$\SI{30}{\mega\hertz}$] (shiftsource) {}
              node[source,below=of upmix.center,scale=0.7,label=right:$f_0$] (upsource) {}
              node[below=of mul.center] (gamma) {$\Gamma_{set} = X + jY$};

        \draw ($(dut)!.5!(dirvna)$) node[coordinate] (plane) {};

        { [rounded corners=2pt]
            \draw (dut) -- (dirvna) -- (circ.A);
            \draw [-latex] (circ.B) -- ($(circ.B |- uppernode)!.5!(uppernode)$) node[coordinate] (upper) {} -- (downmix);
            \draw (dirvna.A2) -- (oszivna.A1);
            \draw (dirvna.B2) |- ($(dirvna.B2)!.7!(oszivna.A2)$) node[coordinate] (oszimiddle) {} -| (oszivna.A2);
            \draw [-latex] (amp) -- ($(circ.C |- amp)!.5!(lowernode)$) node[coordinate] (lower) {} -- (circ.C);
        }
        { [-latex]
            \draw (downsource) -- (downmix);
            \draw (sample) -- (adc);
            \draw (shiftsource) -- (shift);
            \draw (gamma) -- (mul);
            \draw (upsource) -- (upmix);
        }
        { [latex-,dashed,every node/.style={font=\footnotesize}]
            \foreach \device in {oszivna,downsource,sample,shiftsource} {
                \draw (\device) -- ++(0,1) node[anchor=south] {ref};
            }
            \draw (upsource) -- ++(0,-1) node[anchor=north] {ref};
        }
        { [start chain,every on chain/.style={join=by -latex}]
            \chainin (downmix);
            \chainin (bp);
            \chainin (adc);
            \chainin (inbuf);
            \chainin (shift);
            { [every on chain/.style={join=by {double,-latex}}]
                \chainin (H);
                \chainin (mul);
                \chainin (outbuf);
                \chainin (dac);
                \chainin (antialias);
                \chainin (upmix);
            }
            \chainin (amp);
        }
        { [on background layer,every path/.style={dotted,decorate,decoration=random steps,segment length=2mm}]
            \draw ($(dirvna.B1)!.5!(circ.A) + (0,4)$) -- ++(0,-8.5) node[coordinate] (leftsplit) {};
            \draw ($(adc.east)!.5!(outbuf.west) + (0,4)$) -- ++(0,-8.5) node[coordinate] (rightsplit) {};
        }

        \draw (leftsplit) node[anchor=base east] {One Port \gls{vna}}
              (leftsplit) node[anchor=base west] {Analog}
              (rightsplit) node[anchor=base west] {Digital}
              (rightsplit) node[anchor=base east] {Analog};

%        \draw [-latex] ($(dirvna.A2) + (-0.2,0.1)$) -- node[base left] {$b_1$} ($(oszivna.A1 |- oszimiddle) - (0.2,0.1)$);
%        \begin{pgfonlayer}{foreground}
%            \draw [-latex] ($(dirvna.B2) + (0.2,0.1)$) -- ($(oszimiddle -| dirvna.B2) + (0.2,-0.1)$);
%        \end{pgfonlayer}
%        \draw ($(oszimiddle -| dirvna.B2) + (0.2,-0.1)$) node[base right,fill=white] {$a_1$};

        \draw [dashed] ($(plane) + (0,4)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,4.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-2)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};
    \end{tikzpicture}
    }
    \caption{System overview}
    \label{fig:overall_hf}
\end{figure}

To overcome these limitations, a digital \gls{elp} similar to the one in
\cite{hashim_active_2008} was developed. The design in \cite{hashim_active_2008}
uses direct conversion, which creates additional \gls{dc} components in the \gls{iq}
signals. Since these have to be removed by filters, the band around \SI{0}{\hertz} is
not usable for reflection generation. Additionally it used a variable delay line in
the \gls{fpga}, to compensates the phase difference of multiple carriers. The design in
\cref{fig:overall_hf} was developed with these limitations in mind. Instead of direct
conversion a superheterodyne design is used. Furthermore the delay line is replaced by
a fully configurable filter \textit{f2}. It consists of three distinct parts:

\begin{enumerate}
    \item A one port \gls{vna}, to be able to measure the current $\Gamma_L$. This part is
needed, to be able to reach a specific $\Gamma_{L,target}$ iteratively. It is
described in detail in \cref{sec:vna}, whereas the iterative algorithm can be found
in \cref{sec:matlab}.

    \item The analog part, which contains the mixers for the frequency shifting, necessary
        filters, \gls{dac}, \gls{adc}, and an amplifier. A detailed description can be found
        in \cref{sec:analog}.

    \item A digital processing chain implemented in a \gls{fpga}, which is controlled with
a \gls{pc} running Matlab. The \gls{fpga} implementation is described in \cref{chap:fpga},
the software running on the processor contained in the \gls{fpga}, as well as the Matlab
code, in \cref{chap:software}.
\end{enumerate}

% ---------------------------------------------------------------------------

\section{One Port \glsentryshort{vna}}
\label{sec:vna}

The one port \gls{vna} in \cref{fig:vna_part} consists of a directional coupler
\textit{dir} and a oscilloscope. The directional coupler is needed to split up
the signal into the incident power wave $b_{2,dut}$ and the reflected power
wave $a_{2,dut}$. With the oscilloscope both signals can be measured in the
time domain. Additionally a \gls{pc} connected to the oscilloscope is needed
for the necessary calculations.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \pgfdeclarelayer{foreground}
        \pgfsetlayers{background,main,foreground}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[dircoupler,right=2 of dut,label=below:dir] (dirvna) {}
              node[oscilloscope,above=of dirvna.A2,anchor=A1] (oszivna) {}
              node[coordinate,right=of dirvna] (rest) {}
              node[coordinate,right=of rest] (resta) {};

        \draw ($(dut)!.5!(dirvna)$) node[coordinate] (plane) {};

        \draw [dashed] (rest) -- (resta);

        { [rounded corners=2pt]
            \draw (dut) -- (dirvna) -- (rest);
            \draw (dirvna.A2) -- (oszivna.A1);
            \draw (dirvna.B2) |- ($(dirvna.B2)!.7!(oszivna.A2)$) node[coordinate] (oszimiddle) {} -| (oszivna.A2);
        }
        { [latex-,dashed,every node/.style={font=\footnotesize}]
            \draw (oszivna) -- ++(0,1) node[anchor=south] {ref};
        }
        { [on background layer,every path/.style={dotted,decorate,decoration=random steps,segment length=2mm}]
            \draw ($(dirvna.B1)!.5!(rest) + (0,4)$) -- ++(0,-7) node[coordinate] (leftsplit) {};
        }

        \draw (leftsplit) node[anchor=base east] {One Port \gls{vna}}
              (leftsplit) node[anchor=base west] {Analog};

        \draw [-latex] ($(dirvna.A2) + (-0.2,0.1)$) -- node[base left] {$b_1$} ($(oszivna.A1 |- oszimiddle) - (0.2,0.1)$);
        \begin{pgfonlayer}{foreground}
            \draw [-latex] ($(dirvna.B2) + (0.2,0.1)$) -- ($(oszimiddle -| dirvna.B2) + (0.2,-0.1)$);
        \end{pgfonlayer}
        \draw ($(oszimiddle -| dirvna.B2) + (0.2,-0.1)$) node[base right,fill=white] {$a_1$};

        \draw [dashed] ($(plane) + (0,4)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,3)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-2)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};
    \end{tikzpicture}
    \caption{One port \gls{vna} part}
    \label{fig:vna_part}
\end{figure}

According to \cref{eq:gl_phase} only $\frac{a_2}{b_2}$ is
of interest for calculating $\Gamma$. Since only the fraction of the magnitudes
and the phase difference is needed, the exact point in time, when the signals are
taken does not matter, as long as both are measured at the same time. Therefore
no special triggering is necessary.

\begin{equation}\label{eq:gl_phase}
    \begin{split}
        \Gamma_L & = \frac{a_2}{b_2} \\
                 & = \frac{\abs{a_2}}{\abs{b_2}} e^{j(\arg{a_2}-\arg{b_2})}
    \end{split}
\end{equation}

Magnitude and Phase of the measured waves can be calculated by using
the discrete Fourier transform, if only a single frequency is of
interest. If multiple frequency components are of interest, the computational
power needed can be lowered by using the fast Fourier transform. With both methods
spectral leakage will occur if an arbitrary number of samples are used \cite{harris_use_1978}.
Another problem is that the frequency resolution $\Delta{}f$ is limited by the sampling
frequency and the number of recorded samples (see \cref{eq:fres}). Higher resolutions
can be achieved with a higher sample rate and more samples. Since both are oscilloscope
dependent and potentially increase the time needed for transferring the data to the
\gls{pc} a better way to improve the results is applying a window function to the
measured samples.

\begin{equation}
    \label{eq:fres} \Delta{}f = \frac{f_{sample}}{n_{sample}}
\end{equation}

The window function used in this work (see \cref{sec:matlab}) is the flat top window.
This window function has a very high amplitude accuracy \cite{heinzel_spectrum_2002}.
Since it's frequency response is very flat in a small frequency range around the selected $\Delta{}f$-bin
it also enables acquiring frequency components, that are not $\Delta{}f$-aligned \cite{heinzel_spectrum_2002}.
In this work, the periodic version of the built in Matlab flat top window \lstinline$flattopwin$
was used (see \cref{sec:matlab} and \cite{matlab_flattop}).

\begin{align}
    \label{eq:k} k & = \left\lfloor \frac{f}{\Delta{}f} \right\rfloor \\
    \label{eq:X} X & \xleftrightarrow{\mathcal{DFT}} x\,\lstinline|flattopwin($n_{sample}$, 'periodic')| \\
    \label{eq:gamma_lf} \Gamma_{L,f} & = \frac{X_{a}\{k\}}{X_{b}\{k\}}
\end{align}

Using \cref{eq:fres,eq:k,eq:X,eq:gamma_lf} the reflection coefficient $\Gamma_L$ at
frequency $f$ can be calculated. First, the frequency resolution $\Delta{}f$ is needed, to be able
to calculate the index $k$ of the frequency bin. Since the following calculations are the same
for $a$ and $b$, $x$ is used instead. The spectrum of the window function has to be convoluted with the
spectrum of the samples. This is done with element-wise multiplication in \Cref{eq:X} before applying
the discrete Fourier transform. Because of the linearity of the discrete Fourier transform
\cite{pearson_discrete}, the value at index $k$ can be directly used in \Cref{eq:gl} leading to \cref{eq:gamma_lf}.

The measurements taken with this method contain systematic errors. These are caused by mismatches and
imperfections in the equipment (e.g. limited directivity of the coupler and imperfect connectors).
Additional reflections caused by these imperfections distort the measurements. Furthermore cabling
needed causes the reference plane to be at another place, than depicted in \cref{fig:vna_part}.
Those errors can be corrected with vector error correction. This works by measuring the systematic
errors with known calibration standards, using those measurements to calculate the error model and
using this model, to remove the systematic errors from the subsequent measurements
\cite{agilent_an_1287-3}.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \matrix (box)
        [matrix of nodes,%
         nodes in empty cells,
         nodes={dspnodeopen},
         column sep=1cm,
         row sep=2cm]
        {
            |[coordinate]| & &[4cm] & & |[coordinate]| \\
            |[coordinate]| & & & & |[coordinate]| \\
        };
        \draw[-latex] (box-1-1) node[anchor=east] {$a_{1}$} -- (box-1-2);
        \draw[-latex] (box-1-2) -- node[above] {$1$} (box-1-3);
        \draw[-latex] (box-1-3) -- node[above] {$b_{2}$} (box-1-4);

        \draw[latex-] (box-2-1) node[anchor=east] {$b_{1}$} -- (box-2-2);
        \draw[latex-] (box-2-2) -- node[above] {$S_{12}$} (box-2-3);
        \draw[latex-] (box-2-3) -- node[above] {$a_{2}$} (box-2-4);

        \draw[-latex] (box-1-2) to[bend left=30] node[right] {$S_{11}$} (box-2-2);
        \draw[latex-] (box-1-3) to[bend right=30] node[left] {$S_{22}$} (box-2-3);

        \draw[-latex] (box-1-4) to[bend left=30] node[right] {$\Gamma_L$} (box-2-4);

        \draw ($(box-1-2) + (0,0.7cm)$) rectangle ($(box-2-3) - (0,0.7cm)$);
        \draw ($(box-1-4) + (0,0.7cm)$) rectangle ($(box-2-5) - (0,0.7cm)$);

        \draw[dashed] (box-1-2) -- ++(0,1.5cm) node[anchor=south] {Oscilloscope};
        \draw[dashed] (box-1-3) -- ++(0,1.5cm) node[anchor=south] {Load Reference Plane};

        \draw[dashed] (box-2-2) -- ++(0,-1cm);
        \draw[dashed] (box-2-3) -- ++(0,-1cm);

        \draw ($(box-2-4)!.5!(box-2-5) - (0,0.7cm)$) node[anchor=north] {\gls{dut}};
        \draw ($(box-2-2)!.5!(box-2-3) - (0,0.7cm)$) node[anchor=north] {Error box};
    \end{tikzpicture}
    \caption{Error box for the one port \gls{vna}}
    \label{fig:errorbox}
\end{figure}

\Cref{fig:errorbox} depicts the error model for the measurement system in \cref{fig:vna_part}. It
consists of the \gls{dut} and an error box, containing all the systematic errors of the measurement
system. This error model can cancel out three different errors:
\begin{enumerate}
    \item Source match $S_{22}$, the mismatch between the measurement system and the \gls{dut}.
    \item Directivity $S_{11}$, caused by reflections received by the oscilloscope that are
        not caused by the \gls{dut}.
    \item Reflection tracking $S_{12}$, which characterizes the difference in the frequency response
        between the two oscilloscope ports, including loss in the couplers, transmission lines, and
        other components.
\end{enumerate}

From the error model in \cref{fig:errorbox} the following equations can be derived:
\begin{align}
    \label{eq:b2} b_{2} & = a_{1} + S_{22} a_{2}\\
    \label{eq:b1} b_{1} & = S_{11} a_{1} + S_{12} a_{2} \\
    \label{eq:a2} a_{2} & = \Gamma_L b_{2}
\end{align}
\Cref{eq:b2,eq:b1,eq:a2,eq:gamma_lf} can be combined into the single \cref{eq:gamma_err}.
With this equation the corrected reflection coefficient $\Gamma_L$ can be calculated.
$\Gamma_{L,f}$ is the measured value from the oscilloscope and $S$ denote different the
error terms, that have to be measured and calculated.
\begin{equation}\label{eq:gamma_err}
    \begin{split}
        \Gamma_{L,corr} & = \frac{S_{11} - \frac{b_1}{a_1}}{S_{11} S_{22} - S_{22}\frac{b_1}{a_1} - S_{12}} \\
                        & = \frac{S_{11} - \Gamma_{L,f}^{-1}}{S_{11} S_{22}\Gamma_{L,f}^{-1} - S_{22} - S_{12}}
    \end{split}
\end{equation}

Since there are three error terms, at least three different measurements have
to be taken. These measurements are usually conducted with short, open, and load,
where load is normally the characteristic impedance of the system \cite{agilent_an_1287-3}.
Other impedances could also be used, which is done for example at higher frequencies
with different shorts, because it is more difficult to characterize open and
loads at these frequencies \cite{anritsu_cal}. Another way commonly used in
commercial \gls{vna} is the electronic calibration, where different impedances
are available via a semiconductor switch trough the same connector. With this
technique it isn't necessary to change the connections between the different
targets, therefore minimizing calibration time and risk for operator error.
The calibration used in this work was carried out with short, open, and load (see
\Cref{sec:vna_verify}).

Open targets are usually specified by a frequency-dependent capacitance (see
\cref{eq:cref}) and a transmission line length. Short targets use the same
specification, but instead of a capacitance a frequency-dependent inductance is
needed (see \cref{eq:lref}). For loads a shunt capacitance, a series inductance,
a resistance and the transmission line length is needed.
\begin{align}
    \label{eq:cref} C & = C_0 + C_1 f + C_2 f^2 + C_3 f^3 \\
    \label{eq:lref} L & = L_0 + L_1 f + L_2 f^2 + L_3 f^3
\end{align}
Because of the inherent transmission line, the impedance on the input of this
line has to be calculated. As shown in \cite{pozar_mw_engineering_2011} this
can be achieved with \cref{eq:beta,eq:move}. In these equations the impedances
calculated from the capacitance/inductance provided by \cref{eq:cref,eq:lref},
the material dependent speed $c$, the frequency $f$ and the transmission line
length $l$ is needed. Therefore the actual frequency dependent impedances can
be calculated with the values from the data sheet.
\begin{align}
    \label{eq:beta} \beta & = \frac{2 \pi}{\lambda} = \frac{2 \pi f}{c}\\
    \label{eq:move} Z_{in} & = Z_0 \frac{Z_L + j Z_0 \tan(\beta l)}{Z_0 + j Z_L \tan(\beta l)}
\end{align}

These values don't incorporated eventual adapters needed for the measurements.
Hence it is important to use the calibration kit with the right connectors, or
the connectors have to be accounted for in the error corrections.

By using the three different targets and applying them to \cref{eq:gamma_err},
system of three \cref{eq:gls,eq:glo,eq:glm} can be set up. The
three different $\Gamma_L$ and $\Gamma_{L,f}$ represent the short ($\Gamma_S$),
the open ($\Gamma_O$) and the match ($\Gamma_M$) target.
\begin{align}
    \label{eq:gls} \Gamma_{L_S} & = \frac{S_{11} - \Gamma_{L,f_S}^{-1}}{S_{11} S_{22}\Gamma_{L,f_S}^{-1} - S_{22} - S_{12}} \\
    \label{eq:glo} \Gamma_{L_O} & = \frac{S_{11} - \Gamma_{L,f_O}^{-1}}{S_{11} S_{22}\Gamma_{L,f_O}^{-1} - S_{22} - S_{12}} \\
    \label{eq:glm} \Gamma_{L_M} & = \frac{S_{11} - \Gamma_{L,f_M}^{-1}}{S_{11} S_{22}\Gamma_{L,f_M}^{-1} - S_{22} - S_{12}}
\end{align}

Solving these equations for the error terms $S_{11}$, $S_{12}$ and $S_{22}$
leads to \cref{eq:S11err,eq:S12err,eq:S22err} with the common term $g$ from
\cref{eq:g_replace} and $\Gamma_1$ from \cref{eq:gamma_replace}. Those terms
were used to enable a more compact representation. These equations were
generated with Mathematica and are implemented in a Wolfram Mathematica generated
Mathworks Matlab module (see \cref{sec:matlab}).

\begin{align}
    \label{eq:gamma_replace} \Gamma_1 & = \frac{a_1}{b_1} = \Gamma_{L,f} \\
    \begin{split}
    \label{eq:g_replace} g & = (\Gamma_{1_O} - \Gamma_{1_S}) \Gamma_{1_M} \Gamma_{L_O} \Gamma_{L_S} + \Gamma_{L_M} ((\Gamma_{1_M} - \Gamma_{1_O}) \Gamma_{1_S} \Gamma_{L_O} + (\Gamma_{1_S} - \Gamma_{1_M}) \Gamma_{1_O} \Gamma_{L_S})
    \end{split}\\
    \label{eq:S11err} S_{11} & = \frac{(\Gamma_{1_O} - \Gamma_{1_S}) \Gamma_{L_O} \Gamma_{L_S} + \Gamma_{L_M} ((\Gamma_{1_M} - \Gamma_{1_O}) \Gamma_{L_O} + (\Gamma _{1_S} - \Gamma _{1_M}) \Gamma_{L_S})}{g} \\
    \label{eq:S12err} S_{12} & = \frac{(\Gamma_{1_O} - \Gamma_{1_M}) (\Gamma_{1_M} - \Gamma_{1_S}) (\Gamma_{1_O} - \Gamma_{1_S}) (\Gamma_{L_M} - \Gamma_{L_O}) (\Gamma_{L_M} - \Gamma_{L_S}) (\Gamma_{L_O} - \Gamma_{L_S})}{g^2} \\
    \label{eq:S22err} S_{22} & = \frac{(\Gamma_{1_S} - \Gamma_{1_O}) \Gamma_{1_M} \Gamma_{L_M} + (\Gamma_{1_M} - \Gamma_{1_S}) \Gamma_{1_O} \Gamma_{L_O} + (\Gamma_{1_O} - \Gamma_{1_M}) \Gamma_{1_S} \Gamma_{L_S}}{g}
\end{align}

% ---------------------------------------------------------------------------

\section{Analog Part}
\label{sec:analog}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \pgfdeclarelayer{foreground}
        \pgfsetlayers{background,main,foreground}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[circulator,right=2 of dut,label=below:circ] (circ) {}
              node[coordinate,right=of circ,yshift=1.5cm] (uppernode) {}
              node[coordinate,right=of circ,yshift=-1.5cm] (lowernode) {}

              (lowernode) node[amplifier,label=above:amp] (amp) {}
              node[mixer,right=of amp,label=above:mix3] (upmix) {}
              node[lowpass,right=of upmix,label=above:f3] (antialias) {}
              node[adc,right=of antialias,label=above:dac] (dac) {}
              node[coordinate,right=of dac] (outbuf) {}

              (uppernode -| upmix) node[mixer,label=below:mix1] (downmix) {}
              node[bandpass,right=of downmix,label=below:f1] (bp) {}
              node[adc,right=of bp,label=below:adc] (adc) {}
              node[coordinate,right=of adc] (inbuf) {}

              node[source,above=of downmix.center,scale=0.7,label=right:$f_0 - \SI{70}{\mega\hertz}$] (downsource) {}
              node[source,above=of adc.center,scale=0.7,label={[fill=white]right:$\SI{100}{\mega\hertz}$}] (sample) {}
              node[source,below=of upmix.center,scale=0.7,label=right:$f_0$] (upsource) {};

        \draw ($(dut)!.4!(circ.A)$) node[coordinate] (plane) {};

        { [on background layer,every path/.style={dotted,decorate,decoration=random steps,segment length=2mm}]
            \draw ($(dut)!.75!(circ.A) + (0,4)$) -- ++(0,-8.5) node[coordinate] (leftsplit) {};
            \draw ($(adc.east)!.5!(outbuf.west) + (0,4)$) -- ++(0,-8.5) node[coordinate] (rightsplit) {};
        }
        { [rounded corners=2pt]
            \draw (dut) -- (plane);
            \draw [dashed] (plane) -- (plane -| leftsplit);
            \draw (plane -| leftsplit) -- (circ.A);
            \draw [-latex] (circ.B) -- ($(circ.B |- uppernode)!.5!(uppernode)$) node[coordinate] (upper) {} -- (downmix);
            \draw [-latex] (amp) -- ($(circ.C |- amp)!.5!(lowernode)$) node[coordinate] (lower) {} -- (circ.C);
        }
        { [-latex]
            \draw (downsource) -- (downmix);
            \draw (sample) -- (adc);
            \draw (upsource) -- (upmix);
        }
        { [latex-,dashed,every node/.style={font=\footnotesize}]
            \foreach \device in {downsource,sample} {
                \draw (\device) -- ++(0,1) node[anchor=south] {ref};
            }
            \draw (upsource) -- ++(0,-1) node[anchor=north] {ref};
        }
        { [start chain,every on chain/.style={join=by -latex}]
            \chainin (downmix);
            \chainin (bp);
            \chainin (adc);
            \chainin (inbuf);
        }
        { [start chain,every on chain/.style={join=by -latex}]
            { [every on chain/.style={join=by {double,-latex}}]
                \chainin (outbuf);
                \chainin (dac);
                \chainin (antialias);
                \chainin (upmix);
            }
            \chainin (amp);
        }

        \draw (leftsplit) node[anchor=south west,rotate=90] {One Port \gls{vna}}
              (leftsplit) node[anchor=base west] {Analog}
              (rightsplit) node[anchor=base west] {Digital}
              (rightsplit) node[anchor=base east] {Analog};

        \draw [dashed] ($(plane) + (0,4)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,4.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-.5)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-1)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-1.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};

        \node [draw,fit=(amp) (dac) (upsource),rounded corners=4pt,inner xsep=6pt,inner ysep=14pt,label={above:Vector Signal Generator}] {};
    \end{tikzpicture}
    \caption{Analog part}
    \label{fig:analog}
\end{figure}

The analog part, which was designed for the \gls{elp} system can be seen in
\cref{fig:analog}. It consists of everything needed, to prepare the signal
for analog-to-digital conversion and back. Furthermore it contains a
circulator (\textit{circ}), which is needed for uncoupling the
incident power wave $b_2$ and reflected power wave $a_2$. Instead of a
circulator a directional coupler could be used (see
\cref{chap:verification} for an example) \cite{ghannouchi_load-pull_2013}.

The upper analog processing chain in \cref{fig:analog} handles the
incident power wave $b_2$. It is responsible for shifting the frequency spectrum
of the power wave from \gls{rf} to \SI{70}{\mega\hertz} \gls{if}. This
superheterodyn design, with baseband mixing implemented in the digital
part (see \cref{sec:digital}), was chosen, because it exhibits no amplitude
imbalances between I and Q. This setup has the additional feature, that
the \gls{dc}-component caused by the analog mixer \textit{mix1} is outside the
band of interest at \gls{if}. Therefore there is no gap around \SI{0}{\hertz}
and the whole bandwidth is usable. \SI{70}{\mega\hertz} was chosen for \gls{if},
because it is a widely used \gls{if} in radar and microwave applications
\cite{tozer_broadcast_2004,ahamed_design_1997,whitaker_rf_2002,penttinen_telecommunications_2015}
leading to many available parts for this frequency and compatible microwave
laboratory equipment \cite{agilent_h70}.

After shifting the band of interest to \gls{if}, the signal is converted from
analog to digital (\textit{f1} and \textit{adc}). For the sampling rate
\SI{100}{\mega\samples\per\second} was chosen, because the \gls{fpga} is
capable of handling the needed signal processing operations at this sample
rate. Furthermore the chosen vector signal generator supports this sample rate
at the digital input port. Since this sample rate is too low for the chosen
\gls{if} frequency, bandpass sampling was used. This necessitates that a bandpass
filter is used as alias filter \textit{f1}.

\Cref{fig:downconversion} explains the frequency spectra for the complete down
conversion chain (including the digital mixer). The first plot sketches the
spectrum of interest in \gls{rf} around $f_0$. After the mixer \textit{mix1}, the
spectrum of interest lies at \SI{70}{\mega\hertz} and $2f_0 + \SI{70}{\mega\hertz}$,
which is caused by the analog mixer. Because of this, even if only single tones
within the determined bandwith around $f_0$ are generated, at least a low pass
has to be used for filter \textit{f1}. During sampling spectral aliases occur. These
are at $(n \SI{100}{\mega\hertz} + \SI{70}{\mega\hertz})$ and in mirror form at
$(n \SI{100}{\mega\hertz} + \SI{30}{\mega\hertz})$. This mirroring would causes mixing
of frequency components around $(f_0 - \SI{40}{\mega\hertz})$ into the band of interest,
if no bandpass filter was used. The next to last step is the digital mixer, which shifts
the spectrum $\SI{30}{\mega\hertz}$ to the right. After that the band of interest lies around
\SI{0}{\hertz} (see \cref{sec:digital}).

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}[every node/.style={font=\tiny},every path/.style={decoration={name=zigzag,segment length=2pt}}]
        \def\bpspec#1#2{%
            \begin{scope}[shift={#1}]
                \draw [#2] (-0.2,0) -- (-0.2,0.5) -- (0.2,0.8) -- (0.2,0);
            \end{scope}
        }
        \begin{scope}[shift={(0,4.5)}]
            \draw [latex-latex] (-5,0) -- (3,0) decorate { -- (3.1,0) } -- (5,0) node[anchor= west] {frequency};
            \draw [-latex] (0,-0.2) -- (0,1) node[anchor=south] {amplitude};
            \bpspec{(3.5,0)}{solid,thick}
            \draw (3.5,0.1) -- (3.5,-0.1) node[anchor=north] {$f_0$};
            \draw (-5,0.5) node[anchor=east,font={}] (rf) {\gls{rf}};
            \draw [-latex] (3.5,0) to[bend left=30] ($0.7*(2,0)$);
            \draw ($0.7*(2,0) + (0,0.1)$) -- ($0.7*(2,0) - (0,0.1)$) node[anchor=north] {$\SI{70}{\mega\hertz}$};
        \end{scope}
        \begin{scope}[shift={(0,3)}]
            \draw [latex-latex] (-5,0) -- (4,0) decorate { -- (4.1,0) } -- (5,0) node[anchor=west] {frequency};
            \draw [-latex] (0,-0.2) -- (0,1);
            \bpspec{(4.5,0)}{dashed}
            \draw (4.5,0.1) -- (4.5,-0.1) node[anchor=north] {$2f_0 + \SI{70}{\mega\hertz}$};
            \bpspec{($0.7*(2,0)$)}{solid,thick}
            \draw ($0.7*(2,0) + (0,0.1)$) -- ($0.7*(2,0) - (0,0.1)$) node[anchor=north] {$\SI{70}{\mega\hertz}$};
            \draw (-5,0.5) node[anchor=east,font={}] (if) {\gls{if}};
            \draw [dashed,very thick,-latex] (0,0) -- (0,0.8);
        \end{scope}
        \begin{scope}[shift={(0,1.5)}]
            \draw [latex-latex] (-5,0) -- (5,0) node[anchor=west] {frequency};
            \draw [-latex] (0,-0.2) -- (0,1);
            \foreach \x in {-2,-1,1,2} {
                \draw ($\x*(2,0) + (0,0.1)$) -- ($\x*(2,0) - (0,0.1)$) node[anchor=north] {$\x f_s$};
                \draw [dotted] ($\x*(2,0)$) -- ($\x*(2,0) + (0,1)$);
                \draw [thick,-latex,dashed] ($\x*(2,0)$) -- ($\x*(2,0) + (0,0.8)$);
            }
            \foreach \x in {-3,-2,0,1} {
                \bpspec{($0.7*(2,0) + \x*(2,0)$)}{dashed}
            }
            \begin{scope}[xscale=-1]
                \foreach \x in {-3,...,1} {
                    \bpspec{($0.7*(2,0) + \x*(2,0)$)}{dashed}
                }
            \end{scope}
            \bpspec{($0.7*(2,0) + -1*(2,0)$)}{solid,thick}
            \draw [-latex] ($0.7*(2,0) - (2,0)$) to[bend right=45] (0,0);
            \draw ($0.7*(2,0) + -1*(2,0) + (0,0.1)$) -- ($0.7*(2,0) + -1*(2,0) + (0,-0.1)$) node[anchor=north] {$\SI{-30}{\mega\hertz}$};
            \draw (-5,0.5) node[anchor=east,font={}] (sample) {sampling};
            \draw [very thick,-latex,dashed] (0,0) -- (0,0.8);
        \end{scope}
        \draw [latex-latex] (-5,0) -- (5,0) node[anchor=west] {frequency};
        \draw [-latex] (0,-0.2) -- (0,1);
        \foreach \x in {-2,-1,1,2} {
            \draw ($\x*(2,0) + (0,0.1)$) -- ($\x*(2,0) - (0,0.1)$) node[anchor=north] {$\x f_s$};
            \draw [dotted] ($\x*(2,0)$) -- ($\x*(2,0) + (0,1)$);
        }
        \bpspec{(0,0)}{solid,thick}
        \draw (-5,0.5) node[anchor=east,font={}] (mix) {digital mixer};
        \draw [-latex] ([xshift=-5pt]rf.south east) -- ([xshift=-5pt]if.north east);
        \draw [-latex] ([xshift=-5pt]if.south east) -- ([xshift=-5pt]sample.north east);
        \draw [-latex] ([xshift=-5pt]sample.south east) -- ([xshift=-5pt]mix.north east);
        \foreach \x in {-3,-2,0,1} {
            \bpspec{($(2,0) + \x*(2,0)$)}{dashed}
        }
        \begin{scope}[xscale=-1]
            \foreach \x in {-2,...,2} {
                \bpspec{($0.4*(2,0) + \x*(2,0)$)}{dashed}
            }
        \end{scope}
        \foreach \x in {-2,...,2} {
            \draw [thick,-latex,dashed] ($\x*(2,0) + 0.3*(2,0)$) -- ($\x*(2,0) + 0.3*(2,0) + (0,0.8)$);
        }
    \end{tikzpicture}
    \caption{Down conversion frequency spectra ($f_s = \SI{100}{\mega\hertz}$).}
    \label{fig:downconversion}
\end{figure}

The \gls{adc} chosen for this work was an LTC2274. This \gls{adc}
has an input bandwidth of \SI{700}{\mega\hertz} and is capable of
\SI{105}{\mega\samples\per\second} \cite{ltc2274}. With this specifications it
is suited for sampling the \gls{if} of \SI{70}{\mega\hertz} \gls{if} with the sample rate
of \SI{100}{\mega\samples\per\second}. Any other \gls{adc} capable of handling
these requirements and the same digital interface (see \cref{sec:digital}) can be used as a drop in
replacement for this \gls{elp} system.

Digital to analog conversion and up mixing is handled by the lower analog
processing chain in \cref{fig:analog}. In this work a signal vector generator
SMBV100a from Rhode \& Schwarz with digital \gls{iq} input support (R\&S SMBV-K18
\cite{smbv_100a}) was used for these tasks. Like the \gls{adc} a different
signal vector generator can be used as a drop in replacement, if it uses
the same digital interface (see \cref{sec:digital}).

% ---------------------------------------------------------------------------

\section{Digital Part}
\label{sec:digital}

\begin{enumerate}
    \item mixer
    \item buffers
    \item circular convolution
    \item mul
\end{enumerate}

% ===========================================================================

\chapter{\glsentryshort{fpga} Implementation}
\label{chap:fpga}

\begin{itemize}
    \item describe paper \cite{hashim_active_2008}
    \item improvements done
\end{itemize}

\section{Data Acquisition}
\section{Overlap Add}
\section{SMBV Interface}
\section{Processor Interface}
\chapter{Software Implementation}
\label{chap:software}
\section{Kernel Module}
\section{Network Server and Web-Interface}
\section{Matlab Driver}
\label{sec:matlab}

\chapter{Verification of the Measurement System}
\label{chap:verification}
\begin{tikzpicture}[node distance=0.6]
    \tikzpicturedependsonfile{rfsymbols.tex}
    \tikzstyle{every node}=[font=\footnotesize]
    \draw node[dut] (dut) {}
          node[dircoupler,right=1 of dut] (dirvna) {}
          node[dircouplera,right=of dirvna] (dircirc) {}
          node[attenuator,right=of dircirc,label=below:\scriptsize\SI{10}{\deci\bel}] (attcirc) {}
          node[vectorgenerator,right=of attcirc,anchor=out,label=below:\scriptsize\SI{900}{\mega\hertz}] (gen) {}

          node[lowpass,above=of attcirc,label=below:\scriptsize\SI{81}{\mega\hertz}] (alias) {}
          node[mixer,rotate=180,left=of alias,anchor=in,scale=0.5] (mixer) {}
          node[adc,right=of alias] (adc) {}
          node[generator,above=of mixer.in 2] (lo) {}
          node[rotate=90,anchor=north] at (lo.east) {\scriptsize\SI{830}{\mega\hertz}}

          node[generator,above=of adc] (sample) {}
          node[rotate=90,anchor=north] at (sample.east) {\scriptsize\SI{100}{\mega\hertz}}

          node[oscilloscope,above=of dirvna.A2,anchor=A1] (oszivna) {}

          node[mixer,right=1 of gen.in,scale=0.4,rotate=180,anchor=out] (mult) {}
          (mult |- adc) node[mixer,scale=0.4] (iqdemod) {}
          ($(mult)!.5!(iqdemod)$) node[allpass,rotate=-90,scale=0.7] (filter) {}
          node[rotate=90,anchor=north] at (filter.north) {H}

          node[vsourcesinshape,scale=.5,rotate=90,right=of iqdemod.out,anchor=center] (diglo) {}
          node[rotate=90,anchor=north] at (diglo.south) {\scriptsize\SI{30}{\mega\hertz}}
          (mult -| diglo) node (gamma) {$\Gamma$};

    \draw [rounded corners=2pt]
          (dut.B) -- (dirvna.A1)
          (dirvna.B1) -- (dircirc.A1)
          (dircirc.B1) -- (attcirc.A)
          (attcirc.B) -- (gen.out)

          (dirvna.A2) -- (oszivna.A1)
          (dirvna.B2) |- ($(dirvna.B2)!.5!(oszivna.A2)$) -| (oszivna.A2)

          (dircirc.A2) |- (mixer.out)
          (mixer.in) -- (alias.A)
          (alias.B) -- (adc.A)

          (mixer.in 2) -- (lo)

          (sample) -- (adc) -- (iqdemod.in)
          (iqdemod.in 2) -- (filter) -- (mult.in 2)
          (mult.out) -- (gen.in)

          (diglo) -- (iqdemod.out)
          (gamma) -- (mult.in);

    \begin{scope}[rounded corners=2pt]
        \draw [<-]
        (sample.north) |- ($(sample.north) + (5pt,0.4)$) node[coordinate] (merge) {} -| ($(gen.north west)!.85!(gen.north east)$) node[coordinate] (refgen) {};
        \draw [->] (merge) -| (lo.north);
        \draw [->] (merge) -| (oszivna.north);
    \end{scope}

    \draw ($(refgen |- oszivna.north)!.5!(oszivna.north)$) node[coordinate] (refa) {}
          (refa |- merge) node[anchor=south] {\scriptsize\SI{10}{\mega\hertz} Reference clock};

    \node[draw,fit=(iqdemod) (filter) (mult) (diglo),rounded corners=4pt,inner xsep=12pt,inner ysep=8pt,label=above:FPGA] {};

\end{tikzpicture}
\section{One Port \glsentryshort{vna}}
\label{sec:vna_verify}
\section{Reflection Measurements}
\begin{tikzpicture}
    \begin{smithchart}[width=7cm,clip=false]
        \foreach \i in {1,...,11}{
            \foreach \j in {1,...,11}{
                \addplot[blue,is smithchart cs] file {testdata/filter/-1+0i/\i,\j.data};
            }
        }
        \addplot[red,is smithchart cs,mark=*,only marks] coordinates {(-1,0)};
    \end{smithchart}
\end{tikzpicture}\\
\begin{tikzpicture}
    \begin{smithchart}[width=7cm,clip=false]
        \foreach \i in {1,...,11}{
            \foreach \j in {1,...,11}{
                \addplot[blue,is smithchart cs] file {testdata/filter/+1+0i/\i,\j.data};
            }
        }
        \addplot[red,is smithchart cs,mark=*,only marks] coordinates {(+1,0)};
    \end{smithchart}
\end{tikzpicture}\\
\begin{tikzpicture}
    \begin{smithchart}[width=7cm,clip=false]
        \foreach \i in {1,...,11}{
            \foreach \j in {1,...,11}{
                \addplot[blue,is smithchart cs] file {testdata/filter/mean1/\i,\j.data};
            }
        }
        \addplot[red,is smithchart cs,mark=*,only marks] coordinates {(-1,0) (+1,0)};
    \end{smithchart}
\end{tikzpicture}

\section{Phase Drift}
\begin{tikzpicture}
    \begin{axis}[
            ylabel={angle},
            xlabel={seconds},
            x unit={\s},
            width=\linewidth
        ]
        \addplot[blue] table {testdata/phase/single.data};
    \end{axis}
\end{tikzpicture}

\begin{tikzpicture}
    \pgfplotstableread{testdata/phase/all.data}\phaseall
    \begin{axis}[
            ylabel={angle},
            xlabel={seconds},
            x unit={\s},
            width=\linewidth
        ]
        \addplot[blue] table {\phaseall};
        \addlegendentry{\gls{vna}}
        \addplot[green] table[x index=0,y index=2] {\phaseall};
        \addlegendentry{R\&S SMIQ}
        \addplot[red] table[y index=3] {\phaseall};
        \addlegendentry{R\&S SMGU}
        \addplot[black] table[y index=4] {\phaseall};
        \addlegendentry{R\&S SMBV}
    \end{axis}
\end{tikzpicture}
\chapter{Conclusions and Outlook}

\begin{appendix}
    \chapter{Hardware Reference}
    \section{Physical Overview}
    \section{Memory Map \& Register Assignment}
    \chapter{Software Reference}
    \section{Kernel Module Usage}
    \section{Protocols}
    \section{Matlab Classes}
    \section{Usage Examples}
    \chapter{Build Instructions}
    \section{Hardware}
    \section{Software}

    \printglossary[type=\acronymtype]

    \listoffigures

    \bibliographystyle{IEEEtran}
    \bibliography{main}

\begin{otherlanguage}{ngerman}
    \chapter*{Code of Conduct}
    Hiermit erkl\"are ich, dass die vorliegende Arbeit ohne unzul\"assige Hilfe Dritter und ohne Benutzung
    anderer als der angegebenen Hilfsmittel angefertigt wurde. Die aus anderen Quellen oder indirekt
    \"ubernommenen Daten und Konzepte sind unter Angabe der Quelle gekennzeichnet.
    Die Arbeit wurde bisher weder im In- noch im Ausland in gleicher oder in \"ahnlicher Form in anderen
    Pr\"ufungsverfahren vorgelegt.

    \par\noindent\makebox[7cm]{\hrulefill}      \hfill\makebox[5cm]{\hrulefill}%
    \par\noindent\makebox[7cm][l]{Unterschrift} \hfill\makebox[5cm][l]{Datum}%
\end{otherlanguage}

    \end{appendix}
\end{document}

