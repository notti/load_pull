\documentclass[12pt,a4paper,parskip=full,abstract=true,BCOR=12mm,twoside,open=right]{scrreprt}
\KOMAoption{bibliography}{totoc}
\KOMAoption{listof}{totoc}

\usepackage[ngerman,english]{babel}

%drawings

\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{tikz}
\usepackage{circuitikz}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{arrows}
\usetikzlibrary{backgrounds}
\usetikzlibrary{bending}
\usetikzlibrary{calc}
\usetikzlibrary{colorbrewer}
\usetikzlibrary{chains}
\usetikzlibrary{circuits.ee.IEC}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{dsp}
\usetikzlibrary{fit}
\usetikzlibrary{matrix}
\usetikzlibrary{patterns}
\usetikzlibrary{positioning}
\usetikzlibrary{scopes}
\usetikzlibrary{shadows}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.misc}
\include{rfsymbols}
\makeatletter
\newcommand\currentcoordinate{\the\tikz@lastxsaved,\the\tikz@lastysaved}
\makeatother

%units

\usepackage[binary-units,retain-explicit-plus,group-digits=false]{siunitx}
\DeclareSIUnit \belm {Bm}
\DeclareSIUnit \belfs {BFS}
\DeclareSIUnit \samples {S}
\sisetup{per-mode = symbol}

%plots

\usepackage{pgfplots}
\pgfplotsset{compat=1.12}
\pgfplotsset{every axis/.append style={grid=major,legend style={font=\footnotesize}}}
\usepgfplotslibrary{smithchart}
\usepgfplotslibrary{units}
\usepgfplotslibrary{fillbetween}
\usepgfplotslibrary{statistics}
\usepgfplotslibrary{colorbrewer}
\pgfplotsset{unit code/.code 2 args={\si{#1#2}}}

\usepgfplotslibrary{external}
\tikzsetexternalprefix{figures/}
\tikzexternalize[mode=list and make]
\tikzexternalwritetomakefile{}
\tikzexternalwritetomakefile{.DELETE_ON_ERROR:}
\tikzexternalwritetomakefile{}

\tikzifexternalizing{%
    \newcommand{\hack}{}
}{%
    \usepackage{fontspec}
    \newfontfamily\hack{hack}[
        Scale = MatchUppercase,
        ItalicFont = *-oblique,
        BoldItalicFont = *-boldoblique,
    ]
}



%math

\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{gensymb}

\providecommand{\abs}[1]{\lvert#1\rvert}

%source

\usepackage{listings}
\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}
\newcommand*{\lstitem}[1]{
  \setbox0\hbox{\lstinline{#1}}
  \item[\usebox0]
  \hfill \\
}

%stuff

\usepackage{url}
\usepackage{tocloft} %table of contents modification
\usepackage{subcaption} %subfigures
\usepackage{placeins} % keep floats in check (=sections where they belong)
\usepackage{booktabs} % nicer tables
\usepackage{cite}
\usepackage{register}

\usepackage{scrlayer-scrpage}
\pagestyle{scrheadings}
\automark[chapter]{chapter}
\automark*[section]{}

\def\device#1{\textit{#1}}

\usepackage[colorlinks,hyperindex,plainpages=false,
pdftitle={FPGA-based Load-Pull Measurement System},
pdfauthor={Gernot Vormayr},
pdfsubject={Diploma thesis},
pdfpagelabels %,hidelinks
]{hyperref}

% lots of acronyms
\usepackage[acronym]{glossaries}

\newacronym{ac}{AC}{alternative current}
\newacronym{adc}{ADC}{analog-to-digital converter}
\newacronym{cf}{CF}{compact flash}
\newacronym{cpu}{CPU}{central processing unit}
\newacronym{dac}{DAC}{digital-to-analog converter}
\newacronym{dc}{DC}{direct current}
\newacronym{ddr}{DDR}{double data rate}
\newacronym{dft}{DFT}{discrete Fourier transform}
\newacronym{dram}{DRAM}{dynamic random access memory}
\newacronym{dut}{DUT}{device under test}
\newacronym{elp}{ELP}{envelope load-pull}
\newacronym{emt}{EMT}{electromechanical tuner}
\newacronym{fft}{FFT}{fast Fourier transform}
\newacronym{fir}{FIR}{finite impulse response}
\newacronym{fpga}{FPGA}{field programmable gate array}
\newacronym[longplural={general-purpose inputs/outputs}]{gpio}{GPIO}{general-purpose input/output}
\newacronym{gui}{GUI}{graphical user interface}
\newacronym{if}{IF}{intermediate frequency}
\newacronym{iq}{IQ}{in-phase/quadrature-phase}
\newacronym{led}{LED}{light emitting diode}
\newacronym{lo}{LO}{local oscillator}
\newacronym{lp}{LP}{load-pull}
\newacronym{lvds}{LVDS}{low voltage differential signalling}
\newacronym{mw}{MW}{microwave}
\newacronym{os}{OS}{operating system}
\newacronym[shortplural=OSERDES]{oserdes}{OSERDES}{output parallel-to-serial logic resource}
\newacronym{pa}{PA}{power amplifier}
\newacronym{pc}{PC}{personal computer}
\newacronym{plb}{PLB}{processor local bus}
\newacronym{rf}{RF}{radio frequency}
\newacronym[longplural=random access memories]{ram}{RAM}{random access memory}
\newacronym{rom}{ROM}{read only memory}
\newacronym{sata}{SATA}{serial AT attachment}
\newacronym{sma}{SMA}{sub-miniature version A}
\newacronym{snr}{SNR}{signal-to-noise ratio}
\newacronym{sparam}{S-parameter}{scattering parameter}
\newacronym{ui}{UI}{user interface}
\newacronym{vhdl}{VHDL}{VHSIC Hardware Description Language}
\newacronym{vna}{VNA}{vector network analyzer}
\newacronym{xps}{XPS}{Xilinx Platform Studio}

\makeglossaries

\usepackage[noabbrev]{cleveref} %needs to be last
\crefname{Regfloat}{register}{registers}
\Crefname{Regfloat}{Register}{Registers}

\pagenumbering{roman}
\begin{document}
\begin{titlepage}
    \enlargethispage{1cm}
    \centering
    \vspace*{5cm}
    {\Huge \textbf{Diploma thesis}}\\
    \vspace*{1cm}
    {\Large FPGA-based Load-Pull Measurement System}

    \vspace*{2cm}
    {\large Gernot ~\textsc{Vormayr} \\ 0425210 \\ } ~\\

    \vspace*{2cm}
    {\today } ~\\

    \vfill
    {Supervisors} ~\\\vspace*{0.1cm}
    {Ass.Prof. Dipl.-Ing. Dr.techn. \large Holger ~\textsc{Arthaber}} ~\\
    {Univ.Ass. Dipl.-Ing. Dr.techn. \large Thomas ~\textsc{Faseth}}
    \vspace*{2cm}

    \rule{\linewidth}{0.4pt}
    \begin{minipage}[t]{0.55\linewidth}
        \flushleft
        \begin{large}
            EMCE - Institute of Electrodynamics, Microwave and Circuit Engineering
        \end{large}\\
        Vienna University of Technology
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.27\linewidth}
        \flushright
        Gusshausstrasse 25\\
        1040 Vienna\\
        www.emce.tuwien.ac.at
    \end{minipage}
    \vspace*{-3pt}
    \rule{\linewidth}{0.4pt}
    \clearpage
\end{titlepage}

\begin{abstract}
    %TODO
    \begin{itemize}
        \item RFPA
        \item load-pull
        \item the one in this work
        \item verification
    \end{itemize}
\end{abstract}

\begin{otherlanguage}{ngerman}
\begin{abstract}
    %TODO
    \begin{itemize}
        \item RFPA
        \item load-pull
        \item the one in this work
        \item verification
    \end{itemize}
\end{abstract}
\end{otherlanguage}

\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
    %TODO
    TODO
\end{abstract}

\tableofcontents

\chapter{Introduction}
\pagenumbering{arabic}
\label{chap:introduction}

At \gls{rf} and \gls{mw} frequencies, the circuit theory with lumped elements, where
voltage and current do not vary over the physical dimension of the elements, is of limited
value. The wavelength at these frequencies is of the order of the circuit
element dimensions. This means that transmission line theory has to be used instead \cite{pozar_mw_engineering_2011}.
This theory applies circuit theory to infinitesimal small pieces of the lumped elements
and introduces the concept of forward and backward traveling power waves.

For this reason, instead of impedance- and admittance matrices, \glspl{sparam}
are commonly used in \gls{rf} and \gls{mw} circuit engineering to describe
$N$-ports (see \cref{fig:sparam,eq:sparam} for a 2-port). $a_n$ denotes the incident and
$b_n$ the reflected power wave. Complex valued $S_{nn}$ represents the
part of $a_n$ that gets reflected at port $n$, where as $S_{nm}$ is the part of $a_m$ that
is transmitted to $b_n$. A set of \glspl{sparam} is only valid for a specific frequency, a
characteristic impedance $Z_0$, and a well defined reference plane (port 1 and port 2 in \cref{fig:sparam}).

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \matrix (box)
        [matrix of nodes,%
         nodes in empty cells,
         nodes={dspnodeopen},
         column sep=1cm,
         row sep=2cm]
        {
            |[coordinate]| & &[4cm] & |[coordinate]| \\
            |[coordinate]| & & & |[coordinate]| \\
        };
        \draw[-latex] (box-1-1) node[anchor=east] {$a_1$} -- (box-1-2);
        \draw[-latex] (box-1-2) -- node[above] {$S_{21}$} (box-1-3);
        \draw[-latex] (box-1-3) -- (box-1-4) node[anchor=west] {$b_2$};

        \draw[latex-] (box-2-1) node[anchor=east] {$b_1$} -- (box-2-2);
        \draw[latex-] (box-2-2) -- node[above] {$S_{12}$} (box-2-3);
        \draw[latex-] (box-2-3) -- (box-2-4) node[anchor=west] {$a_2$};

        \draw[-latex] (box-1-2) to[bend left=30] node[right] {$S_{11}$} (box-2-2);
        \draw[latex-] (box-1-3) to[bend right=30] node[left] {$S_{22}$} (box-2-3);

        \draw ($(box-1-2) + (0,0.7cm)$) rectangle ($(box-2-3) - (0,0.7cm)$);

        \draw[dashed] (box-1-2) -- ++(0,1.5cm) node[anchor=south] {Port 1};
        \draw[dashed] (box-1-3) -- ++(0,1.5cm) node[anchor=south] {Port 2};

        \draw[dashed] (box-2-2) -- ++(0,-1cm);
        \draw[dashed] (box-2-3) -- ++(0,-1cm);
    \end{tikzpicture}
    \caption{\Glspl{sparam} of a 2-port}
    \label{fig:sparam}
\end{figure}

\begin{equation}
    \label{eq:sparam}
    \begin{pmatrix} b_1 \\ b_2 \end{pmatrix} = \begin{pmatrix} S_{11} & S_{12} \\ S_{21} & S_{22} \end{pmatrix} \begin{pmatrix} a_1 \\ a_2 \end{pmatrix}
\end{equation}

For a 1-port there is only the parameter $S_{11}$, which is equivalent to the reflection
coefficient $\Gamma$ and can be also expressed by the input impedance $Z_{in}$ (see
\cref{eq:s11ref} as shown in \cite{pozar_mw_engineering_2011}). This does not necessarily hold for 2-ports, since for a generic
multi-port configuration, also reflections from the devices connected at the other ports
can be seen.
\begin{equation}
    \label{eq:s11ref} \Gamma = S_{11} = \frac{Z_{in}-Z_0}{Z_{in}+Z_0}
\end{equation}

One way to evaluate the \glspl{sparam} at a specific frequency would be connecting
the reference impedance $Z_0$ to the other ports. To measure e.g. $S_{11}$ a matching impedance, equal to the ports reference impedance, has to
be connected to port 2. According to \cref{eq:s11ref} the reflected wave $a_2$
at port 2 is zero in this case. This means that measurements at port 1 can only see the
reflections caused by $S_{11}$. Consequently $S_{11}$ can now be calculated by measuring the incident
and reflected wave at port 1 (see \cref{eq:s11}) \cite{agilent_an_154}.
\begin{align}
    \label{eq:s11} S_{11} & = \left.\frac{b_1}{a_1} \right\rvert_{a_2 = 0}\\
    \label{eq:s21} S_{21} & = \left.\frac{b_2}{a_1} \right\rvert_{a_2 = 0}
\end{align}
Because of connectors and cabling it is often impossible to connect exact matches. Therefor
\glspl{sparam} are measured by sending a power wave into port 1 of the \gls{dut}, measuring
$a_n$ and $b_n$. After that the measurement is repeated with port 2. With measurements from
both ports and calibration measurements, which are necessary to account for systematic errors in the measurement setup,
it is possible to determine every \gls{sparam}. \Glspl{vna} use this method
and can make automated measurements at various frequencies.

As long as a network behaves linearly, what is typical for small incident signals, the \glspl{sparam}
fully describe this network at a specific frequency. Thus they can also be used
to model amplifiers, as long as they exhibit controlled and linear behaviour. Since
class-A \glspl{pa} are nearly linear, \glspl{sparam} can be used to describe the small
signal behaviour. But those \glspl{pa} exhibit a very low efficiency of around \SI{50}{\percent}.
In modern \gls{rf} and \gls{mw} applications the efficiency is increased with specially designed input and
output matching networks, that improve the performance. This comes at the cost of non-linear
behaviour of the \gls{pa} \cite{ghannouchi_load-pull_2013}.

Because of these non-linearities more complex models and verification systems are
needed. One way to measure the characteristics of a non-linear system is the so called
\gls{lp} technique (see \cref{fig:load_coeff}). This measurement system presents a
controllable load impedance (output tuner) to the \gls{dut}. The fixed input tuner is
needed to match the input of the \gls{dut} to the source. \Gls{lp} can be used for obtaining the
\gls{dut} characteristics, and for verifying an implementation. \Gls{lp} also
allows to test the \gls{dut} under realistic operational conditions.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \draw node[source] (source) {}
              node[tuner,right=of source,label=above:{fixed input tuner}] (ituner) {}
              node[dut,right=of ituner] (dut) {}
              node[tuner,right=2 of dut,label=above:{output tuner}] (otuner) {}
              node[match,right=of otuner,label=above:{$Z_0$}] (match) {}
              node[rground,right=0.3 of match,rotate=90,anchor=center] (ground) {};
        \draw ($(dut)!.5!(otuner)$) node[coordinate] (plane) {};

        \draw (source) -- (ituner) -- (dut) -- (otuner) -- (match) -- (ground);

        \draw [dashed] ($(plane) + (0,2)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,2.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};

    \end{tikzpicture}
    \caption{Load reflection coefficient}
    \label{fig:load_coeff}
\end{figure}

The \cref{eq:gl,eq:zl} show the relations between the load reflection coefficient $\Gamma_L$,
the incident wave $a_2$, the reflected
wave $b_2$, and the load impedance $Z_L$ at port 2 of \cref{fig:sparam,fig:load_coeff}. $Z_0$
is the characteristic impedance of the system \cite{hashmi_highly_2011}.
\begin{align}
    \label{eq:gl} \Gamma_L & = \frac{a_2}{b_2} \\
    \label{eq:zl} \Gamma_L & = \frac{Z_L-Z_0}{Z_L+Z_0}
\end{align}
The output tuner in \cref{fig:load_coeff} synthesizes an appropriate $\Gamma_L$
either by varying the phase and magnitude of the reflected wave $a_2$ or by varying
the load impedance $Z_L$. This means, that it is possible to build a \gls{lp}
setup by either using a passive tuner, or feeding a modified wave back to the
\gls{dut}.

There are various types of \gls{lp} measurement setups, which have different
characteristics. One important feature of a \gls{lp} setup is the repeatability of reflection
coefficients. The repeatability is needed to ensure accurate application
specific device models. Another important factor is the tuning range, which
depicts the maximal achievable range of the reflection coefficient $\abs{\Gamma_L}$
(e.g. \cref{fig:range_passive}). Usually passive \gls{lp}
systems have a more limited tuning range than active ones, but provide a
better repeatability \cite{ghannouchi_load-pull_2013}. Tuner speed and tuner
resolution is an additional trade off. High resolution is needed since \glspl{pa} are often
highly sensitive to impedance variations. However a high resolution incurs
a slow tuner speed. An exemplary resolution can be seen in \cref{fig:generic_emt}.
Power handling capability is another extremely important factor. The \gls{lp}
setup has to be capable to sustain the power presented to the tuner without
damage. Which \gls{lp} setup to choose for a specific \gls{dut} depends on
these requirements.

\begin{figure}[htb]
    \begin{subfigure}[b]{.5\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth]
                \addplot[blue,is smithchart cs,mark=o,only marks] file {testdata/generic_emt.data};
            \end{smithchart}
        \end{tikzpicture}
        \caption{\Glsentryshort{emt}}
        \label{fig:generic_emt}
    \end{subfigure}%
    \begin{subfigure}[b]{.5\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth]
                \filldraw[draw=blue,fill=blue,fill opacity=0.2] (cartesian cs:0,0) let \p1 = (cartesian cs:0.75,0) in circle ({\x1});
            \end{smithchart}
        \end{tikzpicture}
        \caption{Passive \gls{lp} system}
        \label{fig:range_passive}
    \end{subfigure}
    \caption{Generic representation of achievable tuning range/points passive \gls{lp}}
\end{figure}

Passive \gls{lp} systems are based on the block diagram in \cref{fig:load_coeff}. Depending on
the desired measurements, additional circuit elements like directional couplers,
power meters, and oscilloscopes are needed. For higher power measurements additional
amplifiers, and attenuators to reduce the output power to acceptable levels might also
be needed. These additional components, the cabling, and connectors add additional loss
on the reflection path, leading to achievable reflection levels $\abs{\Gamma_L} < 1$ with
a maximum usually around 0.75 \cite{de_groote_introduction_2008} (see \cref{fig:range_passive}).

Typically used tuners, consist of a transmission line and a probe that introduces a mismatch
by adding a parallel susceptance. Varying the position of the probe along the transmission
line changes the phase of the impedance mismatch and the distance the magnitude \cite{hashmi_highly_2011}.
Automated positioning can be achieved by adding motors. These tuners are called \glspl{emt}.
Those have to be calibrated before use and achieve reflection levels like shown in
\cref{fig:generic_emt} with up to 10000 points \cite{ghannouchi_load-pull_2013}.

If higher $\abs{\Gamma_L}$-levels  are needed (even levels $> 1$), active \gls{lp} setups
have to be used. There are two categories: closed- and open loop.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \draw node[dut] (dut) {}
              node[circulator,right=2 of dut] (circ) {}
              node[vmatch,right=of circ,label=above:{Attenuator},yshift=1cm] (att) {}
              node[vphase,right=1.5 of att,label=above:{Phase shift}] (phase) {}
              node[amplifier,right=of circ,label=above:{Amplifier},yshift=-1cm] (amp) {};

        \draw ($(dut)!.5!(circ)$) node[coordinate] (plane) {};

        \draw (dut) -- (circ.A);
        \draw (circ.B) -- ($(circ.B |- att)!.5!(att)$) node[coordinate] (upper) {} -- (att) -- (phase) -- ++(1,0) |- (amp) -- ($(circ.C |- amp)!.5!(amp)$) node[coordinate] (lower) {} -- (circ.C);

        \draw [-latex] ($(circ.B) + (-0.2,0.2)$) -- node[sloped,above] {$b_2$} ($(upper) + (-0.2,0.2)$);
        \draw [latex-] ($(circ.C) + (-0.2,-0.2)$) -- node[sloped,below] {$a_2$} ($(lower) + (-0.2,-0.2)$);

        \draw [dashed] ($(plane) + (0,2)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,2.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};
    \end{tikzpicture}
    \caption{Active closed loop \gls{lp} block diagram}
    \label{fig:active_closed_loop}
\end{figure}

Active closed loop \gls{lp} setups generate a modified reflected wave $a_2$ by
modifying the phase and magnitude of $b_2$ and feeding it back to the \gls{dut}.
The functional block diagram, which can be seen in \Cref{fig:active_closed_loop},
is an example of such an active closed loop \gls{lp} setup. With the circulator
the power wave $b_2$ is fed to a variable attenuator, a phase shifter and an
amplifier. These elements enable modifying the phase and the magnitude of $b_2$,
which is again fed back to the \gls{dut} with the circulator. Because of limited
isolation provided by real world circulators this system will oscillate if the loop gain
exceeds the isolation \cite{ghannouchi_load-pull_2013}. This can be circumvented with
an isolator after the amplifier. Another way to improve the stability of the system
is to introduce a bandpass filter into the loop.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \draw node[dut] (dut) {}
              node[isolator,right=2 of dut,rotate=180,anchor=east] (iso) {}
              node[amplifier,right=of iso.west,label=above:Amplifier] (amp) {}
              node[vphase,right=of amp,label=below:{Phase Shift}] (shift) {}
              node[vmatch,right=of shift,label=above:{Attenuator}] (att) {}
              node[source,right=of att,label=below:{Phase Locked Source}] (source) {};

        \draw ($(dut)!.5!(iso)$) node[coordinate] (plane) {};

        \draw (dut) -- (iso) -- (amp) -- (shift) -- (att) -- (source);
        \draw [latex-] ($(iso.west) + (0.2,-0.2)$) -- node[below] {$a_2$} ($(amp.west) + (-0.2,-0.2)$);

        \draw [dashed] ($(plane) + (0,2)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,2.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};
    \end{tikzpicture}
    \caption{Active open loop \gls{lp} block diagram}
    \label{fig:active_open_loop}
\end{figure}

Active open loop \gls{lp} setups work by generating a phase coherent wave with
an external signal generator (see \cref{fig:active_open_loop}). The open loop
approach has the advantage, that it can't oscillate, since there is no closed loop.
It works by generating a signal with a source, that is locked to the generator driving the
source port of the \gls{dut}. Phase and magnitude can be adjusted with the attenuator and
phase shifter. A disadvantage of the open loop system is that the generated waves $a_2$ are
not derived from $b_2$. This implies that the reflection coefficient $\Gamma_L$ not only
depends on the phase shifter and attenuator settings, but also on the \gls{dut} itself.
Therefore, an iterative approach is needed to be able to achieve a specific $\Gamma_L$ \cite{muller_comparison_1994}.

Keeping in mind above discussions, in the course of the presented thesis the following chapters introduce an active closed loop \gls{lp} system, which
is built with a digital attenuator, phase shifter, and loop filter implemented
in a \gls{fpga}. Possible uses include high throughput or drive- and bias-level
independent \gls{rf} and microwave \gls{lp} measurement applications. Furthermore
it is possible to synthesize broadband reflections, therefore enabling the use
of modulated signals during characterization, which enables a wider range of
operational conditions.

% ===========================================================================

\chapter{\glsentryshort{fpga}-based Load-Pull Measurement System}
\label{chap:measurement_system}

The aim of this thesis was to setup a broadband active \gls{lp} measurement system, capable of providing a bandwidth of \SI{20}{\mega\hertz}.
As mentioned in \cref{chap:introduction} these traditional classic systems can only synthesize
narrow band reflections. To overcome these limitations an \gls{elp} measurement system, which
synthesizes the reflections in the digital domain, was chosen as the base for this work. This approach solves the stability problem
and the problem of the \gls{if} calibration with a fully configurable digital \gls{fir} filter.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[circulator,right=2 of dut,label=below:circ] (circ) {}

              node[coordinate,right=of circ,yshift=1.5cm] (uppernode) {}
              node[coordinate,right=of circ,yshift=-1.5cm] (lowernode) {}

              node[amplifier,right=0.5 of lowernode,label=above:amp] (amp) {}
              node[mixer,right=of amp,label=below:mix2] (upmix) {}

              (uppernode -| upmix) node[mixer,label=above:mix1] (downmix) {}

              ($(upmix)!.5!(downmix)$) node[mixer] (mul) {}
              node[rotate=90,anchor=south] at (mul.west) {mul}

              node[right=0.5 of mul] (gamma) {$\Gamma_{L,set} = X + j Y$}
              node[source,right=0.5 of gamma,scale=0.7,label=right:$f_0$] (lo) {};

        \draw ($(dut)!.5!(circ)$) node[coordinate] (plane) {};

        \draw [latex-] ($(amp.west |- uppernode) + (-0.2,0.2)$) -- node[sloped,above] {$b_2$} ($(uppernode) + (-0.4,0.2)$);
        \draw [-latex] ($(amp.west) + (-0.2,-0.2)$) -- node[below] {$a_2$} ($(lowernode) + (-0.4,-0.2)$);

        { [rounded corners=2pt]
            \draw (dut) -- (circ.A);
            \draw [-latex] (circ.B) -- ($(circ.B |- uppernode)!.5!(uppernode)$) node[coordinate] (upper) {} -- (downmix);
            \draw [-latex] (amp) -- ($(circ.C |- amp)!.5!(lowernode)$) node[coordinate] (lower) {} -- (circ.C);
            \draw [-latex] (lo) |- (downmix);
            \draw [-latex] (lo) |- (upmix);
        }
        \draw [-latex] (gamma) -- (mul);
        { [start chain,every on chain/.style={join=by -latex}]
            \chainin (downmix);
            { [every on chain/.style={join=by {double,-latex}}]
                \chainin (mul);
                \chainin (upmix);
            }
            \chainin (amp);
        }

        \draw [dashed] ($(plane) + (0,2)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,3)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$a_{2}$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-2)$) node[anchor=west] {$b_{2}$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_{L,set}$};
    \end{tikzpicture}
    \caption{Generic block diagram \gls{elp}}
    \label{fig:elp}
\end{figure}

Instead of traditional active closed loop \gls{lp}, this system generates the
load coefficient at baseband or \gls{if}. The basic principle of this \gls{elp} system
can be seen in \cref{fig:elp}. A circulator is used to split the incident and
reflected wave. The mixer \device{mix1} is used for shifting the spectrum to
the baseband and for \gls{iq} demodulation. This \gls{iq} signal is then
multiplied by the complex valued $\Gamma_{L,set}$ (\device{mul1}), thus creating a specific
reflection coefficient $\Gamma_L$. Mixer \device{mix2} is used for modulating
the \gls{iq} signal and upconverting the signal back to the desired \gls{rf} \cite{williams_experimental_2005}.

The multiplication can be done in the analog domain, as has been described
by \cite{williams_experimental_2005}. But this has the disadvantage that
an additional image will be generated by the multiplicator \device{mul1},
if there are amplitude imbalances in the output
of the demodulator \device{mix1}. Since this image is very close to the
carrier signal, it can't be filtered out \cite{hashmi_agile_2010}.

\begin{figure}[htb]
    \centering
    \resizebox{\linewidth}{!}{
    \begin{tikzpicture}
        \pgfdeclarelayer{foreground}
        \pgfsetlayers{background,main,foreground}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[dircoupler,right=2 of dut,label=below:dir1] (dirvna) {}
              node[oscilloscope,above=of dirvna.A2,anchor=A1] (oszivna) {}
              node[circulator,right=of dirvna,label=below:circ1] (circ) {}

              node[coordinate,right=of circ,yshift=1.5cm] (uppernode) {}
              node[coordinate,right=of circ,yshift=-1.5cm] (lowernode) {}

              (lowernode) node[amplifier,label=above:amp1] (amp) {}
              node[mixer,right=of amp,label=above:mix3] (upmix) {}
              node[lowpass,right=of upmix,label=above:lp1] (antialias) {}
              node[adc,right=of antialias,label=above:dac1] (dac) {}

              (uppernode -| upmix) node[mixer,label=below:mix1] (downmix) {}
              node[bandpass,right=of downmix,label=below:bp1] (bp) {}
              node[adc,right=of bp,label=below:adc1] (adc) {}
              node[empty,right=of adc,label=below:buffer1] (inbuf) {}
              node[mixer,right=of inbuf] (shift) {}
              node[rotate=90,anchor=north] at (shift.east) {mix2}

              (dac -| inbuf) node[mixer,label=above:mul1] (mul) {}
              node[empty,right=of mul] (outbuf) {}
              node[rotate=90,anchor=north] at (outbuf.east) {buffer2}

              ($(shift)!.5!(outbuf)$) node[allpass,rotate=90] (H) {}
              node[rotate=90,anchor=north] at (H.south) {fir1}

              node[source,above=of downmix.center,scale=0.7] (downsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (downsource.west) {$f_0 - \SI{70}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (downsource.east) {lo1}
              node[source,above=of adc.center,scale=0.7] (sample) {}
              node[rotate=90,anchor=south,font=\tiny] at (sample.west) {$\SI{100}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (sample.east) {lo2}
              node[source,above=of shift.center,scale=0.7] (shiftsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (shiftsource.west) {$\SI{30}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (shiftsource.east) {lo3}
              node[source,below=of upmix.center,scale=0.7] (upsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (upsource.west) {$f_0$}
              node[rotate=90,anchor=north] at (upsource.east) {lo4}
              node[below=of mul.center,fill=white] (gamma) {$\Gamma_{L,set} = X + jY$};

        \draw ($(dut)!.5!(dirvna)$) node[coordinate] (plane) {};

        { [rounded corners=2pt]
            \draw (dut) -- (dirvna) -- (circ.A);
            \draw [-latex] (circ.B) -- ($(circ.B |- uppernode)!.5!(uppernode)$) node[coordinate] (upper) {} -- (downmix);
            \draw (dirvna.A2) -- (oszivna.A1);
            \draw (dirvna.B2) |- ($(dirvna.B2)!.7!(oszivna.A2)$) node[coordinate] (oszimiddle) {} -| (oszivna.A2);
            \draw [-latex] (amp) -- ($(circ.C |- amp)!.5!(lowernode)$) node[coordinate] (lower) {} -- (circ.C);
        }
        { [-latex]
            \draw (downsource) -- (downmix);
            \draw (sample) -- (adc);
            \draw [double] (shiftsource) -- (shift);
            \draw (gamma) -- (mul);
            \draw (upsource) -- (upmix);
        }
        { [latex-,dashed,every node/.style={font=\footnotesize}]
            \foreach \device in {downsource,sample,shiftsource} {
                \draw (\device) -- ++(0,1) node[anchor=south] {ref};
            }
            \draw ([xshift=0.5cm]oszivna.north) -- ++(0,0.5) node[fill=white,anchor=south] {ref};
            \draw (upsource) -- ++(0,-1) node[anchor=north] {ref};
        }
        { [start chain,every on chain/.style={join=by -latex}]
            \chainin (downmix);
            \chainin (bp);
            \chainin (adc);
            \chainin (inbuf);
            \chainin (shift);
            { [every on chain/.style={join=by {double,-latex}}]
                \chainin (H);
                \chainin (outbuf);
                \chainin (mul);
                \chainin (dac);
                \chainin (antialias);
                \chainin (upmix);
            }
            \chainin (amp);
        }
        { [on background layer,every path/.style={dotted,decorate,decoration=random steps,segment length=2mm}]
            \draw ($(dirvna.B1)!.5!(circ.A) + (0,4)$) -- ++(0,-8.5) node[coordinate] (leftsplit) {};
            \draw ($(adc.east)!.5!(mul.west) + (0,4)$) -- ++(0,-8.5) node[coordinate] (rightsplit) {};
        }

        \draw (leftsplit) node[anchor=base east] {One Port \gls{vna}}
              (leftsplit) node[anchor=base west] {Analog}
              (rightsplit) node[anchor=base west] {Digital}
              (rightsplit) node[anchor=base east] {Analog};

%        \draw [-latex] ($(dirvna.A2) + (-0.2,0.1)$) -- node[base left] {$b_1$} ($(oszivna.A1 |- oszimiddle) - (0.2,0.1)$);
%        \begin{pgfonlayer}{foreground}
%            \draw [-latex] ($(dirvna.B2) + (0.2,0.1)$) -- ($(oszimiddle -| dirvna.B2) + (0.2,-0.1)$);
%        \end{pgfonlayer}
%        \draw ($(oszimiddle -| dirvna.B2) + (0.2,-0.1)$) node[base right,fill=white] {$a_1$};

        \draw [dashed] ($(plane) + (0,4)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,4.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-2)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};

        {[densely dashdotdotted,latex-latex]
            \draw ($(inbuf.north) + (0,1)$) -- ++(0,1) node [anchor=south] {\glsentryshort{pc}};
            \draw ([xshift=-0.5cm]oszivna.north) -- ++(0,1) node [anchor=south] {\glsentryshort{pc}};
        }
    \end{tikzpicture}
    }
    \caption{System overview}
    \label{fig:overall_hf}
\end{figure}

To overcome these limitations, a digital \gls{elp} similar to the one in
\cite{hashim_active_2008} was realized within this thesis. The design in \cite{hashim_active_2008}
uses direct conversion, which creates additional \gls{dc} components in the \gls{iq}
signals. Since these have to be removed by filters, the band around \SI{0}{\hertz} is
not usable for reflection generation. Additionally it uses a variable delay line in
the \gls{fpga}, to compensate the phase difference of multiple carriers. The design presented in
\cref{fig:overall_hf} was designed within this thesis keeping these limitations in mind. Instead of direct
conversion a superheterodyne design was used. Furthermore the delay line was replaced by
a fully configurable filter \device{fir1}. This filter allows synthesizing reflections with the required bandwidth
of \SI{20}{\mega\hertz}. It is needed to compensate the frequency response of the rest of the setup.
Without this filter the reflection coefficient $\Gamma_L$ would not be constant over the bandwidth. This
is caused by the frequency responses of the different components. Furthermore the different frequencies
equal different wavelengths which in turn experience different phase shifts. Those phase shifts are caused by the geometric
dimensions of the setup and delays introduced by buffering.
The setup consists of three distinct parts:

\begin{enumerate}
    \item A one port \gls{vna}, to be able to measure the current $\Gamma_L$. This part is
needed, to be able to reach a specific $\Gamma_{L,target}$ iteratively and is
described in detail in \cref{sec:vna}. The iterative algorithm can be found
in \cref{sec:matlab}.
    \item The analog part, which contains the mixers for the frequency shifting operation, necessary
        filters, a \gls{dac}, an \gls{adc}, and an amplifier. A detailed description can be found
        in \cref{sec:analog}.
    \item A digital processing chain is implemented in an \gls{fpga}, which is controlled with
a \gls{pc} running Matlab. The \gls{fpga} implementation is described in \cref{chap:fpga}.
The software running on the processor contained in the \gls{fpga}, as well as the Matlab
code, in \cref{chap:software}.
\end{enumerate}

% ---------------------------------------------------------------------------

\section{One Port \glsentryshort{vna}}
\label{sec:vna}

The one port \gls{vna} in \cref{fig:vna_part} consists of a directional coupler
\device{dir1} and an oscilloscope. The directional coupler is needed to split up
the signal into the incident power wave $b_{2}$ and the reflected power
wave $a_{2}$. With the help of oscilloscope both signals can be measured in the
time domain. Additionally a \gls{pc} connected to the oscilloscope is needed
for extracting the wave parameters from the measured samples and the necessary
error correction calculations, which are explained in the rest of this section.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \pgfdeclarelayer{foreground}
        \pgfsetlayers{background,main,foreground}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[dircoupler,right=2 of dut,label=below:dir1] (dirvna) {}
              node[oscilloscope,above=of dirvna.A2,anchor=A1] (oszivna) {}
              node[coordinate,right=of dirvna] (rest) {}
              node[coordinate,right=of rest] (resta) {};

        \draw ($(dut)!.5!(dirvna)$) node[coordinate] (plane) {};

        \draw [dashed] (rest) -- (resta);

        { [rounded corners=2pt]
            \draw (dut) -- (dirvna) -- (rest);
            \draw (dirvna.A2) -- (oszivna.A1);
            \draw (dirvna.B2) |- ($(dirvna.B2)!.7!(oszivna.A2)$) node[coordinate] (oszimiddle) {} -| (oszivna.A2);
        }
        { [latex-,dashed,every node/.style={font=\footnotesize}]
            \draw ([xshift=0.5cm]oszivna.north) -- ++(0,0.5) node[fill=white,anchor=south] {ref};
        }
        { [on background layer,every path/.style={dotted,decorate,decoration=random steps,segment length=2mm}]
            \draw ($(dirvna.B1)!.5!(rest) + (0,4)$) -- ++(0,-7) node[coordinate] (leftsplit) {};
        }

        \draw (leftsplit) node[anchor=base east] {One Port \gls{vna}}
              (leftsplit) node[anchor=base west] {Analog};

        \draw [-latex] ($(dirvna.A2) + (-0.2,0.1)$) -- node[base left] {$b_1$} ($(oszivna.A1 |- oszimiddle) - (0.2,0.1)$);
        \begin{pgfonlayer}{foreground}
            \draw [-latex] ($(dirvna.B2) + (0.2,0.1)$) -- node[coordinate] (a1) {} ($(oszimiddle -| dirvna.B2) + (0.2,-0.1)$);
        \end{pgfonlayer}
        \draw (a1) node[base right,fill=white] {$a_1$};

        \draw [dashed] ($(plane) + (0,4)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,3)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-2)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};

        {[densely dashdotdotted,latex-latex]
            \draw ([xshift=-0.5cm]oszivna.north) -- ++(0,1) node [anchor=south] {\glsentryshort{pc}};
        }
    \end{tikzpicture}
    \caption{One port \gls{vna} part}
    \label{fig:vna_part}
\end{figure}

As seen in \cref{eq:gl_phase} only $\frac{a_2}{b_2}$ is
of interest for calculating $\Gamma$. Since only the fraction of the magnitudes
and the phase difference is needed, the exact point in time, when the signals are
taken does not matter, as long as both are measured at the same time, which is guaranteed
by the use of the oscilloscope. Therefore no special triggering or synchronization is necessary.

\begin{equation}\label{eq:gl_phase}
    \begin{split}
        \Gamma_L & = \frac{a_2}{b_2} \\
                 & = \frac{\abs{a_2}}{\abs{b_2}} e^{j(\arg{a_2}-\arg{b_2})}
    \end{split}
\end{equation}

Magnitude and Phase of the measured waves can be calculated by using
the \gls{dft}. If multiple frequency components are of interest, the computational
power needed can be lowered by using the \gls{fft}. With both methods
spectral leakage will occur, which caused by the windowing since only a limited number of samples is used \cite{harris_use_1978}.
Another problem is that the frequency resolution $\Delta{}f$ is limited by the sampling
frequency and the number of recorded samples (see \cref{eq:fres}). Higher resolutions
can be achieved with a higher sample rate $f_{sample}$ and/or more samples $n$. Both are oscilloscope and setup
dependent parameters and potentially increase the time needed for transferring the data to the
\gls{pc}. A preferably way to improve the results is applying a window function to the
measured samples.

\begin{equation}
    \label{eq:fres} \Delta{}f = \frac{f_{sample}}{n}
\end{equation}

The window function used in this work (see \cref{sec:matlab}) is the flat top window.
This window function has a very high amplitude accuracy \cite{heinzel_spectrum_2002}.
Since it's frequency response is very flat in a small frequency range around the selected $\Delta{}f$-bin, frequency components leak
into the surrounding bins with the same amplitude as in the original bin. This enables acquiring frequency components, that are not $\Delta{}f$-aligned \cite{heinzel_spectrum_2002}.
In this work, the periodic version of the built-in Matlab flat top window \lstinline$flattopwin$
was used (see \cref{sec:matlab} and \cite{matlab_flattop}).

\begin{align}
    \label{eq:k} k & = \left\lfloor \frac{f}{\Delta{}f} \right\rfloor\\
    \label{eq:win} w & = \lstinline|flattopwin($n$, 'periodic')| \\
    \label{eq:A} A[n] & = \mathcal{DFT}(a[n]\,w) \\
    \label{eq:B} B[n] & = \mathcal{DFT}(b[n]\,w) \\
    \label{eq:gamma_lf} \Gamma_{L,f} & = \frac{A[k]}{B[k]}
\end{align}

Using \cref{eq:fres,eq:k,eq:win,eq:A,eq:B,eq:gamma_lf} the reflection coefficient $\Gamma_L$ at
frequency $f$, with the measured $n$ samples $a[n]$ of wave $a_2$ and $b[n]$ of wave $b_2$, can be calculated.
First, the frequency resolution $\Delta{}f$ is needed, to be able
to calculate the index $k$ of the frequency bin, which contains the frequency $f$. Next, the window function $w$ with
length $n$ is obtained with the Matlab function \lstinline$flattopwin$ as meantioned earlier. The spectrum of the window function has to be convoluted with the
spectrum of the samples. This is done with element-wise multiplication in \Cref{eq:A,eq:B} before applying
the \gls{dft}. After the transformation $A[n]$ and $B[n]$ contain the signals in the frequency domain. Because of the linearity of the \gls{dft}
\cite{pearson_discrete}, the value at index $k$ can be directly used in \Cref{eq:gl_phase} leading to \cref{eq:gamma_lf}.

The measurements acquired using this type of setup contain systematic errors. These are caused by mismatches and
imperfections in the equipment, which are the limited directivity of the coupler and imperfect connectors and distort the measurements. Furthermore, the
needed cabling causes the reference plane to be shifted to another place, than depicted in \cref{fig:vna_part}.
Those errors can be corrected using vector error correction. By measuring the systematic
errors with known calibration standards it is possible to calculate the error model and
use this model to remove the systematic errors from the subsequent measurements
\cite{agilent_an_1287-3}.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \matrix (box)
        [matrix of nodes,%
         nodes in empty cells,
         nodes={dspnodeopen},
         column sep=1cm,
         row sep=2cm]
        {
            |[coordinate]| & &[4cm] & & |[coordinate]| \\
            |[coordinate]| & & & & |[coordinate]| \\
        };
        \draw[-latex] (box-1-1) node[anchor=east] {$a_{1}$} -- (box-1-2);
        \draw[-latex] (box-1-2) -- node[above] {$1$} (box-1-3);
        \draw[-latex] (box-1-3) -- node[above] {$b_{2}$} (box-1-4);

        \draw[latex-] (box-2-1) node[anchor=east] {$b_{1}$} -- (box-2-2);
        \draw[latex-] (box-2-2) -- node[above] {$S_{12}$} (box-2-3);
        \draw[latex-] (box-2-3) -- node[above] {$a_{2}$} (box-2-4);

        \draw[-latex] (box-1-2) to[bend left=30] node[right] {$S_{11}$} (box-2-2);
        \draw[latex-] (box-1-3) to[bend right=30] node[left] {$S_{22}$} (box-2-3);

        \draw[-latex] (box-1-4) to[bend left=30] node[right] {$\Gamma_L$} (box-2-4);

        \draw ($(box-1-2) + (0,0.7cm)$) rectangle ($(box-2-3) - (0,0.7cm)$);
        \draw ($(box-1-4) + (0,0.7cm)$) rectangle ($(box-2-5) - (0,0.7cm)$);

        \draw[dashed] (box-1-2) -- ++(0,1.5cm) node[anchor=south] {Oscilloscope};
        \draw[dashed] (box-1-3) -- ++(0,1.5cm) node[anchor=south] {Load Reference Plane};

        \draw[dashed] (box-2-2) -- ++(0,-1cm);
        \draw[dashed] (box-2-3) -- ++(0,-1cm);

        \draw ($(box-2-4)!.5!(box-2-5) - (0,0.7cm)$) node[anchor=north] {\gls{dut}};
        \draw ($(box-2-2)!.5!(box-2-3) - (0,0.7cm)$) node[anchor=north] {Error box};
    \end{tikzpicture}
    \caption{Error box for the one port \gls{vna}}
    \label{fig:errorbox}
\end{figure}

\Cref{fig:errorbox} depicts the error model for the measurement system in \cref{fig:vna_part}. It
consists of the \gls{dut} and an error box, containing all the systematic errors of the measurement
system. This error model can cancel out three different errors:
\begin{enumerate}
    \item Source match $S_{22}$, the mismatch between the measurement system and the \gls{dut}.
    \item Directivity $S_{11}$, caused by reflections received by the oscilloscope that are
        not caused by the \gls{dut}.
    \item Reflection tracking $S_{12}$, which characterizes the difference in the frequency response
        between the two oscilloscope ports, including loss in the couplers, transmission lines, and
        other components.
\end{enumerate}

From the error model in \cref{fig:errorbox} the following equations can be derived:
\begin{align}
    \label{eq:b2} b_{2} & = a_{1} + S_{22} a_{2}\\
    \label{eq:b1} b_{1} & = S_{11} a_{1} + S_{12} a_{2} \\
    \label{eq:a2} a_{2} & = \Gamma_L b_{2}
\end{align}
\Cref{eq:b2,eq:b1,eq:a2,eq:gamma_lf} can be combined into the single \cref{eq:gamma_err}.
With the help of this equation the corrected reflection coefficient $\Gamma_L$ can be calculated.
$\Gamma_{L,f}$ is the measured value from the oscilloscope (see \cref{eq:gamma_lf}) and $S_{22}$, $S_{11}$, and $S_{12}$ denote the different
error terms meantioned above, that have to be measured and calculated, which is discussed in the following paragraphs.
\begin{equation}\label{eq:gamma_err}
    \begin{split}
        \Gamma_{L,corr} & = \frac{S_{11} - \frac{b_1}{a_1}}{S_{11} S_{22} - S_{22}\frac{b_1}{a_1} - S_{12}} \\
                        & = \frac{S_{11} - \Gamma_{L,f}^{-1}}{S_{11} S_{22}\Gamma_{L,f}^{-1} - S_{22} - S_{12}}
    \end{split}
\end{equation}

Since there are three error terms, at least three different measurements have
to be taken. These measurements are usually conducted using short, open, and load reflection standards from commercially available calibration kits,
where load is normally the characteristic impedance of the system \cite{agilent_an_1287-3}.
Other impedances could also be used, which is done for example at higher frequencies
with different shorts, because it is more difficult to characterize open and
loads at these frequencies \cite{anritsu_cal}. Another way commonly used in
commercial \gls{vna} is the electronic calibration, where different impedances
are available via a semiconductor switch through the same connector. With this
technique it isn't necessary to change the connections between the different
targets, therefore minimizing calibration time and risk for an operator error.
Nevertheless, the calibration used in this work was carried out with short, open, and load (see
\Cref{sec:vna_verify}).

Open targets are usually specified by a frequency-dependent capacitance (see
\cref{eq:cref}) and a transmission line length. Short targets use the same
specifications, but instead of a capacitance a frequency-dependent inductance is
needed (see \cref{eq:lref}). For loads, a shunt capacitance, a series inductance,
a resistance, and the transmission line length are needed.
\begin{align}
    \label{eq:cref} C & = C_0 + C_1 f + C_2 f^2 + C_3 f^3 \\
    \label{eq:lref} L & = L_0 + L_1 f + L_2 f^2 + L_3 f^3
\end{align}
Because of the inherent transmission line, the impedance on the input of this
line has to be calculated. As shown in \cite{pozar_mw_engineering_2011} this
can be achieved using \cref{eq:beta,eq:move}. In these equations the impedances
calculated from the capacitance/inductance provided by \cref{eq:cref,eq:lref},
the material dependent propagation velocity $c$, the frequency $f$ and the transmission line
length $l$ are needed. Therefore the actual frequency dependent impedances can
be calculated using the values from the data sheet of the used calibration kit.
\begin{align}
    \label{eq:beta} \beta & = \frac{2 \pi}{\lambda} = \frac{2 \pi f}{c}\\
    \label{eq:move} Z_{in} & = Z_0 \frac{Z_L + j Z_0 \tan(\beta l)}{Z_0 + j Z_L \tan(\beta l)}
\end{align}

These values don't incorporated eventual adapters needed for the measurements.
Hence it is important to use the calibration kit with the correct (the same as the \gls{dut}) gendered connectors, or
the connectors have to be additionally accounted for in the error corrections.

By using three different $\Gamma_{L,f}$ measurements, acquired with each of the three different calibration standards in place of the \gls{dut} in \cref{fig:vna_part},
a system of three \cref{eq:gls,eq:glo,eq:glm} can be set up from \cref{eq:gamma_err}. The
three different $\Gamma_L$ and $\Gamma_{L,f}$ represent the short ($\Gamma_S$),
the open ($\Gamma_O$) and the match ($\Gamma_M$) calibration standard.
\begin{align}
    \label{eq:gls} \Gamma_{L_S} & = \frac{S_{11} - \Gamma_{L,f_S}^{-1}}{S_{11} S_{22}\Gamma_{L,f_S}^{-1} - S_{22} - S_{12}} \\
    \label{eq:glo} \Gamma_{L_O} & = \frac{S_{11} - \Gamma_{L,f_O}^{-1}}{S_{11} S_{22}\Gamma_{L,f_O}^{-1} - S_{22} - S_{12}} \\
    \label{eq:glm} \Gamma_{L_M} & = \frac{S_{11} - \Gamma_{L,f_M}^{-1}}{S_{11} S_{22}\Gamma_{L,f_M}^{-1} - S_{22} - S_{12}}
\end{align}

Solving these equations for the error terms $S_{11}$, $S_{12}$ and $S_{22}$
leads to \cref{eq:S11err,eq:S12err,eq:S22err} with the common term $g$ from
\cref{eq:g_replace} and $\Gamma_1$ from \cref{eq:gamma_replace}. Those terms
were used to enable a more compact representation. These equations were
derived using Wolfram Mathematica and are implemented in a Wolfram Mathematica generated
Mathworks Matlab module (see \cref{sec:matlab}).

\begin{align}
    \label{eq:gamma_replace} \Gamma_1 & = \frac{a_1}{b_1} = \Gamma_{L,f} \\
    \begin{split}
    \label{eq:g_replace} g & = (\Gamma_{1_O} - \Gamma_{1_S}) \Gamma_{1_M} \Gamma_{L_O} \Gamma_{L_S} + \Gamma_{L_M} ((\Gamma_{1_M} - \Gamma_{1_O}) \Gamma_{1_S} \Gamma_{L_O} + (\Gamma_{1_S} - \Gamma_{1_M}) \Gamma_{1_O} \Gamma_{L_S})
    \end{split}\\
    \label{eq:S11err} S_{11} & = \frac{(\Gamma_{1_O} - \Gamma_{1_S}) \Gamma_{L_O} \Gamma_{L_S} + \Gamma_{L_M} ((\Gamma_{1_M} - \Gamma_{1_O}) \Gamma_{L_O} + (\Gamma _{1_S} - \Gamma _{1_M}) \Gamma_{L_S})}{g} \\
    \label{eq:S12err} S_{12} & = \frac{(\Gamma_{1_O} - \Gamma_{1_M}) (\Gamma_{1_M} - \Gamma_{1_S}) (\Gamma_{1_O} - \Gamma_{1_S}) (\Gamma_{L_M} - \Gamma_{L_O}) (\Gamma_{L_M} - \Gamma_{L_S}) (\Gamma_{L_O} - \Gamma_{L_S})}{g^2} \\
    \label{eq:S22err} S_{22} & = \frac{(\Gamma_{1_S} - \Gamma_{1_O}) \Gamma_{1_M} \Gamma_{L_M} + (\Gamma_{1_M} - \Gamma_{1_S}) \Gamma_{1_O} \Gamma_{L_O} + (\Gamma_{1_O} - \Gamma_{1_M}) \Gamma_{1_S} \Gamma_{L_S}}{g}
\end{align}

% ---------------------------------------------------------------------------

\section{Analog Part}
\label{sec:analog}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \pgfdeclarelayer{foreground}
        \pgfsetlayers{background,main,foreground}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[circulator,right=2 of dut,label=below:circ1] (circ) {}
              node[coordinate,right=of circ,yshift=1.5cm] (uppernode) {}
              node[coordinate,right=of circ,yshift=-1.5cm] (lowernode) {}

              (lowernode) node[amplifier,label=above:amp1] (amp) {}
              node[mixer,right=of amp,label=above:mix3] (upmix) {}
              node[lowpass,right=of upmix,label=above:lp1] (antialias) {}
              node[adc,right=of antialias,label=above:dac1] (dac) {}
              node[coordinate,right=of dac] (outbuf) {}

              (uppernode -| upmix) node[mixer,label=below:mix1] (downmix) {}
              node[bandpass,right=of downmix,label=below:bp1] (bp) {}
              node[adc,right=of bp,label=below:adc1] (adc) {}
              node[coordinate,right=of adc] (inbuf) {}

              node[source,above=of downmix.center,scale=0.7] (downsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (downsource.west) {$f_0 - \SI{70}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (downsource.east) {lo1}
              node[source,above=of adc.center,scale=0.7] (sample) {}
              node[rotate=90,anchor=south,font=\tiny] at (sample.west) {$\SI{100}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (sample.east) {lo2}
              node[source,below=of upmix.center,scale=0.7] (upsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (upsource.west) {$f_0$}
              node[rotate=90,anchor=north] at (upsource.east) {lo4};

        \draw ($(dut)!.4!(circ.A)$) node[coordinate] (plane) {};

        { [on background layer,every path/.style={dotted,decorate,decoration=random steps,segment length=2mm}]
            \draw ($(dut)!.75!(circ.A) + (0,4)$) -- ++(0,-8.5) node[coordinate] (leftsplit) {};
            \draw ($(adc.east)!.5!(outbuf.west) + (0,4)$) -- ++(0,-8.5) node[coordinate] (rightsplit) {};
        }
        { [rounded corners=2pt]
            \draw (dut) -- (plane);
            \draw [dashed] (plane) -- (plane -| leftsplit);
            \draw (plane -| leftsplit) -- (circ.A);
            \draw [-latex] (circ.B) -- ($(circ.B |- uppernode)!.5!(uppernode)$) node[coordinate] (upper) {} -- (downmix);
            \draw [-latex] (amp) -- ($(circ.C |- amp)!.5!(lowernode)$) node[coordinate] (lower) {} -- (circ.C);
        }
        { [-latex]
            \draw (downsource) -- (downmix);
            \draw (sample) -- (adc);
            \draw (upsource) -- (upmix);
        }
        { [latex-,dashed,every node/.style={font=\footnotesize}]
            \foreach \device in {downsource,sample} {
                \draw (\device) -- ++(0,1) node[anchor=south] {ref};
            }
            \draw (upsource) -- ++(0,-1) node[anchor=north] {ref};
        }
        { [start chain,every on chain/.style={join=by -latex}]
            \chainin (downmix);
            \chainin (bp);
            \chainin (adc);
            \chainin (inbuf);
        }
        { [start chain,every on chain/.style={join=by -latex}]
            { [every on chain/.style={join=by {double,-latex}}]
                \chainin (outbuf);
                \chainin (dac);
                \chainin (antialias);
                \chainin (upmix);
            }
            \chainin (amp);
        }

        \draw (leftsplit) node[anchor=south west,rotate=90] {One Port \gls{vna}}
              (leftsplit) node[anchor=base west] {Analog}
              (rightsplit) node[anchor=base west] {Digital}
              (rightsplit) node[anchor=base east] {Analog};

        \draw [dashed] ($(plane) + (0,4)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,4.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-.5)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-1)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-1.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};

        \node [draw,fit=(amp) (dac) (upsource),rounded corners=4pt,inner xsep=6pt,inner ysep=14pt,label={above:Vector Signal Generator}] {};
    \end{tikzpicture}
    \caption{Analog part}
    \label{fig:analog}
\end{figure}

The analog part, which was designed for the \gls{elp} system can be seen in
\cref{fig:analog}. It consists of everything needed to prepare the signal
for analog-to-digital conversion and back. Furthermore it contains a
circulator (\device{circ1}), which is needed for uncoupling the
incident power wave $b_2$ and the reflected power wave $a_2$. Instead of a
circulator a directional coupler could be used (see
\cref{chap:verification} for an example) \cite{ghannouchi_load-pull_2013}.

The upper analog processing chain in \cref{fig:analog} handles the
incident power wave $b_2$. It is responsible for shifting the frequency spectrum
of the power wave from \gls{rf} to an \gls{if} of \SI{70}{\mega\hertz}. This
superheterodyn design, with baseband mixing implemented in the digital
part (see \cref{sec:digital}), was chosen, because it exhibits no amplitude
imbalances between I and Q. This setup has the additional feature, that
the \gls{dc}-component caused by the analog mixer \device{mix1} is outside the
band of interest at \gls{if}. Therefore there is no gap around \SI{0}{\hertz}
and the whole bandwidth is usable. \SI{70}{\mega\hertz} was chosen as \gls{if},
because it is a widely used \gls{if} in radar and microwave applications
\cite{tozer_broadcast_2004,ahamed_design_1997,whitaker_rf_2002,penttinen_telecommunications_2015}
leading to many available components for this frequency band and compatible microwave
laboratory equipment \cite{agilent_h70}.

After shifting the band of interest to the \gls{if}, the signal is converted from
analog to digital (\device{bp1} and \device{adc1}). For the sampling rate
\SI{100}{\mega\samples\per\second} was chosen, since it provides enough headroom to
support the earlier mentioned bandwidth. Furthermore the chosen vector signal generator supports this sample rate
at the digital input port. To fulfill the sampling theosubfigurerem, this sampling rate is too low for the chosen
\gls{if}, therefore bandpass sampling was used. This necessitates that a bandpass
filter is used as alias filter \device{bp1}.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}[every node/.style={font=\tiny},every path/.style={decoration={name=zigzag,segment length=2pt}}]
        \def\bpspec#1#2{%
            \begin{scope}[shift={#1}]
                \draw [#2] (-0.2,0) -- (-0.2,0.5) -- (0.2,0.8) -- (0.2,0);
            \end{scope}
        }
        \begin{scope}[shift={(0,4.5)}]
            \draw [latex-latex] (-5,0) -- (3,0) decorate { -- (3.1,0) } -- (5,0) node[anchor= west] {frequency};
            \draw [-latex] (0,-0.2) -- (0,1) node[anchor=south] {amplitude};
            \bpspec{(3.5,0)}{solid,thick}
            \draw (3.5,0.1) -- (3.5,-0.1) node[anchor=north] {$f_0$};
            \draw (-5,0.5) node[anchor=east,font={}] (rf) {\gls{rf}};
            \draw [-latex] (3.5,0) to[bend left=30] ($0.7*(2,0)$);
            \draw ($0.7*(2,0) + (0,0.1)$) -- ($0.7*(2,0) - (0,0.1)$) node[anchor=north] {$\SI{70}{\mega\hertz}$};
        \end{scope}
        \begin{scope}[shift={(0,3)}]
            \draw [latex-latex] (-5,0) -- (4,0) decorate { -- (4.1,0) } -- (5,0) node[anchor=west] {frequency};
            \draw [-latex] (0,-0.2) -- (0,1);
            \bpspec{(4.5,0)}{dashed}
            \draw (4.5,0.1) -- (4.5,-0.1) node[anchor=north] {$2f_0 + \SI{70}{\mega\hertz}$};
            \bpspec{($0.7*(2,0)$)}{solid,thick}
            \draw ($0.7*(2,0) + (0,0.1)$) -- ($0.7*(2,0) - (0,0.1)$) node[anchor=north] {$\SI{70}{\mega\hertz}$};
            \draw (-5,0.5) node[anchor=east,font={}] (if) {\gls{if}};
            \draw [dashed,very thick,-latex] (0,0) -- (0,0.8);
        \end{scope}
        \begin{scope}[shift={(0,1.5)}]
            \draw [latex-latex] (-5,0) -- (5,0) node[anchor=west] {frequency};
            \draw [-latex] (0,-0.2) -- (0,1);
            \foreach \x in {-2,-1,1,2} {
                \draw ($\x*(2,0) + (0,0.1)$) -- ($\x*(2,0) - (0,0.1)$) node[anchor=north] {$\x f_s$};
                \draw [dotted] ($\x*(2,0)$) -- ($\x*(2,0) + (0,1)$);
                \draw [thick,-latex,dashed] ($\x*(2,0)$) -- ($\x*(2,0) + (0,0.8)$);
            }
            \foreach \x in {-3,-2,0,1} {
                \bpspec{($0.7*(2,0) + \x*(2,0)$)}{dashed}
            }
            \begin{scope}[xscale=-1]
                \foreach \x in {-3,...,1} {
                    \bpspec{($0.7*(2,0) + \x*(2,0)$)}{dashed}
                }
            \end{scope}
            \bpspec{($0.7*(2,0) + -1*(2,0)$)}{solid,thick}
            \draw [-latex] ($0.7*(2,0) - (2,0)$) to[bend right=45] (0,0);
            \draw ($0.7*(2,0) + -1*(2,0) + (0,0.1)$) -- ($0.7*(2,0) + -1*(2,0) + (0,-0.1)$) node[anchor=north] {$\SI{-30}{\mega\hertz}$};
            \draw (-5,0.5) node[anchor=east,font={}] (sample) {sampling};
            \draw [very thick,-latex,dashed] (0,0) -- (0,0.8);
        \end{scope}
        \draw [latex-latex] (-5,0) -- (5,0) node[anchor=west] {frequency};
        \draw [-latex] (0,-0.2) -- (0,1);
        \foreach \x in {-2,-1,1,2} {
            \draw ($\x*(2,0) + (0,0.1)$) -- ($\x*(2,0) - (0,0.1)$) node[anchor=north] {$\x f_s$};
            \draw [dotted] ($\x*(2,0)$) -- ($\x*(2,0) + (0,1)$);
        }
        \bpspec{(0,0)}{solid,thick}
        \draw (-5,0.5) node[anchor=east,font={}] (mix) {digital mixer};
        \draw [-latex] ([xshift=-5pt]rf.south east) -- ([xshift=-5pt]if.north east);
        \draw [-latex] ([xshift=-5pt]if.south east) -- ([xshift=-5pt]sample.north east);
        \draw [-latex] ([xshift=-5pt]sample.south east) -- ([xshift=-5pt]mix.north east);
        \foreach \x in {-3,-2,0,1} {
            \bpspec{($(2,0) + \x*(2,0)$)}{dashed}
        }
        \begin{scope}[xscale=-1]
            \foreach \x in {-2,...,2} {
                \bpspec{($0.4*(2,0) + \x*(2,0)$)}{dashed}
            }
        \end{scope}
        \foreach \x in {-2,...,2} {
            \draw [thick,-latex,dashed] ($\x*(2,0) + 0.3*(2,0)$) -- ($\x*(2,0) + 0.3*(2,0) + (0,0.8)$);
        }
    \end{tikzpicture}
    \caption{Down conversion frequency spectra ($f_s = \SI{100}{\mega\hertz}$).}
    \label{fig:downconversion}
\end{figure}

\Cref{fig:downconversion} explains the frequency spectra for the complete down
conversion chain (including the digital mixer). The first plot sketches the
spectrum of interest in \gls{rf} around the frequency $f_0$. After the mixer \device{mix1}, the
spectrum of interest lies at \SI{70}{\mega\hertz} and $2f_0 + \SI{70}{\mega\hertz}$,
which is caused by the analog mixer. Because of this, even if only single tones
within the determined bandwith around $f_0$ are generated, at least a low pass
has to be used as filter \device{bp1}. As mentioned earlier, the mixer also generates a \gls{dc} component, which is depicted as vertical dashed arrow. During sampling spectral aliases occur. These
are located at $(n \SI{100}{\mega\hertz} + \SI{70}{\mega\hertz})$ and in mirrored form at
$(n \SI{100}{\mega\hertz} + \SI{30}{\mega\hertz})$. This mirroring would cause mixing
of frequency components around $(f_0 - \SI{40}{\mega\hertz})$ into the band of interest,
if no bandpass filter is used. The last step is the digital mixer, which shifts
the spectrum $\SI{30}{\mega\hertz}$ to the right. After that the band of interest lies around
\SI{0}{\hertz} (see \cref{sec:digital}).

The \gls{adc} chosen for this work was an LTC2274. This \SI{16}{\bit} \gls{adc}
has an input bandwidth of \SI{700}{\mega\hertz} and is capable of
\SI{105}{\mega\samples\per\second} \cite{ltc2274}. With these specifications and above discussed filtering techniques for limitation of the signal bandwidth it
is suited for sampling the \gls{if} of \SI{70}{\mega\hertz} with the sample rate
of \SI{100}{\mega\samples\per\second}. Any other \gls{adc} capable of handling
these requirements and a similar digital interface (see \cref{sec:digital}) can be used as a drop in
replacement for this \gls{elp} system.

Digital to analog conversion and up conversion is handled by the lower analog
processing chain in \cref{fig:analog}. In this work a signal vector generator
SMBV100A from Rhode \& Schwarz with digital \gls{iq} input support (R\&S SMBV-K18
\cite{smbv_100a}) was used for these tasks. Like the \gls{adc} a different
signal vector generator can be used as a drop in replacement, if it uses
the same digital interface (see \cref{sec:digital}).

% ---------------------------------------------------------------------------

\section{Digital Part}
\label{sec:digital}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[coordinate,right=2 of dut] (circ) {}

              node[coordinate,right=of circ,yshift=-1.5cm,label=left:$a_2$] (dac) {}

              node[coordinate,right=of circ,yshift=1.5cm,label=left:$b_2$] (adc) {}
              node[empty,right=of adc,label=below:buffer1] (inbuf) {}
              node[mixer,right=of inbuf] (shift) {}
              node[rotate=90,anchor=north] at (shift.east) {mix2}

              (dac -| inbuf) node[mixer,label=above:mul1] (mul) {}
              node[empty,right=of mul] (outbuf) {}
              node[rotate=90,anchor=north] at (outbuf.east) {buffer2}

              ($(shift)!.5!(outbuf)$) node[allpass,rotate=90] (H) {}
              node[rotate=90,anchor=north] at (H.south) {fir1}

              node[source,above=of shift.center,scale=0.7] (shiftsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (shiftsource.west) {$\SI{30}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (shiftsource.east) {lo3}
              node[below=of mul.center,fill=white] (gamma) {$\Gamma_{set} = X + jY$};

        \draw ($(dut)!.4!(circ)$) node[coordinate] (plane) {};

        { [on background layer,every path/.style={dotted,decorate,decoration=random steps,segment length=2mm}]
            \draw ($(dut)!.75!(circ) + (0,4)$) -- ++(0,-8.5) node[coordinate] (leftsplit) {};
            \draw ($(adc.east)!.5!(mul.west) + (0,4)$) -- ++(0,-8.5) node[coordinate] (rightsplit) {};
        }
        { [rounded corners=2pt]
            \draw (dut) -- (plane);
            \draw [dashed] (plane) -- (plane -| leftsplit) -- (circ);
        }
        { [-latex]
            \draw [double] (shiftsource) -- (shift);
            \draw (gamma) -- (mul);
        }
        { [latex-,dashed,every node/.style={font=\footnotesize}]
            \foreach \device in {shiftsource} {
                \draw (\device) -- ++(0,1) node[anchor=south] {ref};
            }
        }
        { [start chain,every on chain/.style={join=by -latex}]
            \chainin (adc);
            \chainin (inbuf);
            \chainin (shift);
            { [every on chain/.style={join=by {double,-latex}}]
                \chainin (H);
                \chainin (outbuf);
                \chainin (mul);
                \chainin (dac);
            }
        }

        \draw (leftsplit) node[anchor=south west,rotate=90] {One Port \gls{vna}}
              (rightsplit) node[anchor=base west] {Digital}
              ($(leftsplit)!.5!(rightsplit)$) node[anchor=base] {Analog};

        \draw [dashed] ($(plane) + (0,4)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,4.5)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-.5)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-1)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-1.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};

        {[densely dashdotdotted,latex-latex]
            \draw ($(inbuf.north) + (0,1)$) -- ++(0,1) node [anchor=south] {\glsentryshort{pc}};
        }
    \end{tikzpicture}
    \caption{Digital part}
    \label{fig:digital}
\end{figure}

The digital part in \cref{fig:digital} consists of a single \SI{16}{\bit} digital signal processing
chain operating at \SI{100}{\mega\samples\per\second}. It is responsible
for the reflection synthesis. This reflection synthesis is achieved with
the filter \device{fir1} and the multiplicator \device{mul1}. Furthermore
it contains the mixer \device{mix2}. This mixer is needed for \gls{iq}-demodulation
and down conversion from \gls{if} to baseband. The filter \device{fir1}
needs a static digital representation of the samples for the filter calculations.
Therefore, the additional sample buffers \device{buffer1} and \device{buffer2} are
included into the signal processing chain.

As can be seen in \cref{fig:digital}, a digital representation of the \gls{if}
signal $b_2$ is provided by the analog part. As mentioned in \cref{sec:analog}
a LTC2274 was chosen as \gls{adc}. This \gls{adc} has a
JESD204 compliant high speed serial interface \cite{ltc2274}. This interface uses 8b/10b
line coding over a \gls{lvds} connection \cite{jesd205B.01}. The line coding
is responsible for keeping a balanced number of ones and zeros on the line, therefore keeping a long term
\gls{dc} balance on the line. This allows transmitting the data stream through a high pass
channel. Clock recovery is also possible, since this protocol ensures frequent transitions
in the bit stream.

\begin{figure}[htb]
    \centering
    \resizebox{\linewidth}{!}{
    \begin{tikzpicture}[circuit ee IEC,every node/.style={font=\footnotesize},circuit symbol lines/.style={draw,very thick}]
        \tikzpicturedependsonfile{rfsymbols.tex}
        \draw (0,0) node[coordinate] (down) {}
            (0,8) node[coordinate] (up) {}
            (0,4) node[left] {RFIN}
            to[short,o-] (0.8,4) -- ++(0.4,0) node[contact] (innode) {}
            to[capacitor={info=$C_5$,farad'=10n}] ++(1.8,0) node[draw,right,text width=6em,minimum height=11em] (ad8361) {}
            node[right,font=\tiny] {RFIN} node[above left] {3}
            (innode |- down) node[rground] (lpower) {} to[resistor={info sloped=$R_{10}$,ohm' sloped=66}] (innode)
        ([yshift=-4.5em]ad8361.west) node[right,font=\tiny] {PWDN} node[above left]  {4} -| (2.5,0) node[rground] {}
        ([yshift= 1.5em]ad8361.east) node[left,font=\tiny]  {FLTR} node[above right] {6} -- ++(0.5,0)
        ([yshift=   3em]ad8361.east) node[left,font=\tiny]  {IREF} node[above right] {2} -- ++(0.5,0) -- (\currentcoordinate |- up) node[vcc] {} node[anchor=south,rotate=90] {\SI{+3.3}{\volt}}
        ([yshift= 4.5em]ad8361.east) node[left,font=\tiny]  {VPOS} node[above right] {1} -- ++(0.5,0) node[contact] (vcc1) {} -- ++(1,0) --
            (\currentcoordinate |- 0,3) node[contact] (lvcap1) {} -- ++(1.8,0) node[coordinate] (rvcap1) {}
            (lvcap1 |- down) node[rground] {} to[capacitor={info sloped=$C_1$,farad' sloped=100p}] (lvcap1)
            (rvcap1 |- down) node[rground] {} to[capacitor={info sloped=$C_2$,farad' sloped=10n}] (rvcap1)
        ([yshift=  -3em]ad8361.east) node[left,font=\tiny]  {SREF} node[above right] {8} -- ++(0.5,0) -- (\currentcoordinate |- down) node[rground] (rpower) {}
        ([yshift=-4.5em]ad8361.east) node[left,font=\tiny]  {COMM} node[above right] {5} -- ++(0.5,0) node[contact] {}
                       (ad8361.east) node[left,font=\tiny]  {VRMS} node[above right] {7} -- ++(5.5,0) node[op amp,anchor=+,yscale=-1] (op1) {}
        (op1.+) node[above] {3}
        (op1.-) node[above] {2} -- ++(-0.5,0) node[contact] (op1-) {}
        (op1- |- down) node[rground] (lthreshold) {} to[resistor={info sloped=$R_2$,ohm' sloped=1k}] (op1-) to[resistor={info sloped=$R_1$,ohm' sloped=33k}] (op1- |- up) node[vcc] {} node[anchor=south,rotate=90] {\SI{+3.3}{\volt}}
        (op1.down) node[right,yshift=3pt] {8} -- (op1.up |- up) node[vcc] {} node[anchor=south,rotate=90] {\SI{+3.3}{\volt}}
        (op1.up) node[right,yshift=-3pt] {4} -- (op1.down |- down) node[rground] {}
        ++(1.2,0) node[rground] {} to[capacitor={info sloped=$C_3$,farad' sloped=100n}] (op1- -| \currentcoordinate) |- (op1.down |- vcc1) node[contact] {}
        (op1.out) node[above left] (rthreshold) {1} -- ++(1.5,0) node[contact] (op2+) {} -- ++(2,0) node[op amp,anchor=+] (op2) {}
        (op2+ |- down) node[rground] (ldelay) {} to[capacitor={info sloped=$C_4$,farad' sloped=100n}] ($(\currentcoordinate)!.5!(op2+)$)
            to[resistor={info sloped=$R_3$,ohm' sloped=91}] (op2+) -- (op2+ |- vcc1) node[contact] (op2+a) {}
            to[resistor={info sloped=$R_4$,ohm' sloped=330k}] (op2+a |- up) node[vcc] {} node[anchor=south,rotate=90] {\SI{+3.3}{\volt}}
        (op2.+) node[above] {5}
        (op2.-) node[above] {6} -- ++(-0.5,0) node[contact] (op2-) {}
        (op2- |- down) node[rground] {} to[resistor={info sloped=$R_5$,ohm' sloped=33k}] (op2- |- op1-) -- (op2- |- vcc1) to[resistor={info sloped=$R_6$,ohm' sloped=33k}] (op2- |- up) node[vcc] {} node[anchor=south,rotate=90] {\SI{+3.3}{\volt}}
        (op2.out) node[above left] {7} -- ++(0.5,0) node[contact] (out) {}
        (op2+a) -- (op2+a -| op2-) to[resistor={info sloped=$R_7$,ohm' sloped=1M}] (out |- op2+a) node[contact] (out+) {} -- (out)
        (out+) to[resistor={info sloped=$R_8$,ohm' sloped=1k}] (out+ |- up) node[vcc] {} node[anchor=south,rotate=90] {\SI{+3.3}{\volt}}
        (out) -- ++(2.5,0) ++(0,0.8) to[diode={light emitting}] ++(0,-0.8)
        (out) ++(2.5,0.8) -- ++(-1,0) node[above right] {1} -- (\currentcoordinate |- vcc1) to[resistor={info sloped=$R_9$,ohm' sloped=220}] (\currentcoordinate |- up) node[vcc] {} node[anchor=south,rotate=90] {\SI{+3.3}{\volt}}
        (out) ++(1.5,0) node[above right] {2}
        (out) ++(3.15,0.4) -- ++(0.25,0.4) node[above right,xshift=0.4cm] {4} to[short,-o] ++(1,0) node[right] {SYNC1}
        (out) ++(3.4,0) node[above right,xshift=0.4cm] {3} to[short,-o] ++(1,0) node[right] {SYNC2};
        \draw (out) ++(2,-0.3) rectangle ++(1.8,1.4);
        \draw[thick] (out) ++(3.15,0.1) -- ++(0,0.6);
        \draw[decoration={markings,mark=at position 0.7 with {\arrow[black]{latex};}},postaction={decorate}] (out) ++(3.15,0.4) -- ++(0.25,-0.4);

        \draw (op1) node[above left,yshift=1cm,xshift=-0.3cm] {IC2A}
              (op2) node[above left,yshift=1cm,xshift=-0.3cm] {IC2B}
              (op2) node[below right,yshift=-0.5cm,xshift=-0.2cm] {LM393M}
              (ad8361) node[above left,yshift=2.2cm,xshift=-0.7cm] {IC1}
              (ad8361) node[below left,yshift=-2.2cm] {AD8361}
              (out) ++(1.9,1.05) node[anchor=south west] {OK1}
              (out) ++(1.9,-0.3) node[anchor=north west] {TLP283};

        \begin{scope}[every path/.style={decorate,decoration={brace,mirror,amplitude=5pt}},every node/.style={font=\Large}]
            \draw ($(lpower)-(0.5cm,0.7cm)$) -- ([xshift=0.5cm]\currentcoordinate -| rpower) node[midway,below,yshift=-5pt] {signal detection};
            \draw ($(lthreshold)-(0.5cm,0.7cm)$) -- (\currentcoordinate -| rthreshold) node[midway,below,yshift=-5pt] {threshold};
            \draw ($(ldelay)-(0.5cm,0.7cm)$) -- ([xshift=0.5cm]\currentcoordinate -| out+) node[midway,below,yshift=-5pt] {time delay};
        \end{scope}
    \end{tikzpicture}
    }
    \caption{Synchronization signal generator for \gls{adc}}
    \label{fig:adc_adapter}
\end{figure}

To minimize the hardware development time, a Linear Technology DC1151A-D evaluation board was used
in this work. This board consists of a \gls{sma} connector for the analog input, two \gls{sma}
connectors for data+ and data-- of the \gls{lvds} connection, an \gls{sma} connector for clock input
and two pins to enable the synchronization mode. For easier wiring an adapter circuit
board was designed to be able to use a \gls{sata} cable for clock and data. Furthermore the synchronization
circuit in \cref{fig:adc_adapter} was developed, to start a synchronization cycle by shortly suspending the clock
signal. The synchronization circuit consists of three parts. The power detector \device{IC1} which is connected
via \device{$C_5$}, used as an \gls{ac} short to the TX+ pin of the \gls{sata} connector. \device{$R_{10}$} is
needed for input matching. The TX-- pin of the \gls{sata} connector is directly connected to an \gls{sma} connector.
This enables clocking the \gls{adc} board using a clock signal delivered by the \gls{fpga}. The second part
is the comparator \device{IC1a}. This comparator was used to define a minimum threshold of \SI{194}{\milli\volt}
for valid clock signals. The last part is a time delay element. This time delay starts after a valid clock
signal is detected and lasts for about \SI{25.7}{\milli\second}. During
this time the pins \device{SYNC1} and \device{SYNC2} are connected via the optocoupler \device{OK1}, which
enables the synchronization mode of the \gls{adc}. The implemented adapter circuit board atop the
\gls{adc} evaluation board can be seen in \cref{fig:adc_adapter_circ}.

Samples provided via this connection by the \gls{adc} are stored in the sample buffer
\device{buffer1}. To be able to improve the \gls{snr} of the \gls{adc} this buffer
was designed with an averaging capability\cite{ad_mt004}. This averaging was implemented by increasing
the sample size of this buffer to \SI{19}{\bit}. Furthermore, samples can be accumulated
from up to eight consecutive signal cycles. Averaged samples can then be read by dividing the
accumulated samples by the number of cycles.

After this buffer, the \gls{if} sampled data is \gls{iq}-demodulated into baseband
with mixer $mix2$. The \gls{lo} \device{lo3} generates the needed
\SI{30}{\mega\hertz} sine and cosine waveforms using a fixed lookup table. This
approach has the advantage of a highly accurate
\gls{iq}-demodulation without any amplitude or phase imbalances. After base band
conversion, a low pass filter would be needed to
suppress the aliases generated from the sampling process, as can be seen in
\cref{fig:downconversion}. This task can also be achieved with the configurable
filter \device{fir1} in the next processing step. Therefore the aliasing filter
was left out of the design to keep resource usage at a minimum.

Next in the signal processing chain is the filter \device{fir1}.
As meantioned earlier this filter is needed to be able to synthesize a reflection coefficient
$\Gamma_L$ over a frequency range of \SI{20}{\mega\hertz}. This filter is a causal \gls{fir} filter with
the input $x[n]$, the length $n_{fft}$, the impulse response $h[n]$, and the output $y[n]$. The input samples
$x[n]$ represent the samples in buffer \device{buffer1} and the output samples $y[n]$ the samples in buffer \device{buffer2}. This filter is
implemented with linear convolution using the \gls{fft}:
\begin{equation}
    \begin{split}
     \label{eq:circ} y[n] = h[n] * x[n] & = \sum_{k=0}^{n_{fft}-1} h[k]x[n-k]\\
         & = \mathcal{DFT}^{-1}\left\{\mathcal{DFT}(x[n])\,\mathcal{DFT}(h[n])\right\}
    \end{split}
\end{equation}
Since implementing the \gls{fft} in hardware uses a lot of resources, overlap add
was used to allow for larger signal periods than $n_{fft}$. As shown by \cite{schaums_2011}
this algorithm splits the signal $x[n]$ into non-overlapping
subsequences of length $L$ (see \cref{fig:overlap_add}).
\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{scope}[shift={(0,13em)}]
            \draw [decorate,decoration={brace},yshift=2pt] (0,4.1em) -- (5,4.1em) node[midway,yshift=8pt] {$n$};
            \draw [decorate,decoration={brace},yshift=2pt] (0,2.8em) -- (3,2.8em) node[midway,yshift=8pt] {$n_{fft}$};
            \draw [decorate,decoration={brace},yshift=2pt] (0,1.5em) -- (2,1.5em) node[midway,yshift=8pt] {$L$};
            \draw (0,0.75em) node[anchor=east] {$x[n]$};
            \draw (0,0) rectangle (5,1.5em);
            \draw (5,0.75em) node[anchor=west] (zeros) {0000};
            \draw [dashed] (5,0) rectangle (6,1.5em) (2,0) -- (2,1.5em) (4,0) -- (4,1.5em);
        \end{scope}
        \begin{scope}[shift={(0,9em)}]
            \draw (0,0.75em) node[anchor=east] {$y_0[n]$};
            \draw (0,0) rectangle (2,1.5em);
            \draw [fill=black!30] (2,0) rectangle (3,1.5em);
            \draw (2.5,0) node[coordinate] (y0b) {};
            \draw (0.5,0) node[coordinate] (y2b) {};
        \end{scope}
        \begin{scope}[shift={(0,6em)}]
            \draw (0,0.75em) node[anchor=east] {$y_1[n]$};
            \draw (2,0) rectangle (4,1.5em);
            \draw [fill=black!30] (4,0) rectangle (5,1.5em);
            \draw (2.5,1.5em) node[coordinate] (y1t) {};
            \draw (4.5,0) node[coordinate] (y1b) {};
        \end{scope}
        \begin{scope}[shift={(0,3em)}]
            \draw (0,0.75em) node[anchor=east] {$y_2[n]$};
            \draw (4,0) rectangle (6,1.5em);
            \draw [fill=black!30] (6,0) rectangle (7,1.5em);
            \draw [fill=red!30] (0,0) rectangle (1,1.5em);
            \draw (1,0.75em) node[coordinate] (circto) {};
            \draw (4.5,1.5em) node[coordinate] (y2t) {};
            \draw (0.5,1.5em) node[coordinate] (ynt) {};
            \draw (0.5,0) node[coordinate] (ynb) {};
        \end{scope}
        \draw (0,0.75em) node[anchor=east] {$y[n]$};
        \draw (0,0) rectangle (5,1.5em);
        \draw [dashed,color=red] (5,0) rectangle (6,1.5em);
        \draw [dotted] (6,1.5em) rectangle (7,0em);
        \draw [latex-,color=red] (circto) parabola (5.5,1.5em);
        \draw (0.5,1.5em) node[coordinate] (yt) {};

        \draw ($(y0b)!.5!(y1t)$) node {$+$};
        \draw ($(y1b)!.5!(y2t)$) node {$+$};
        \draw ($(y2b)!.5!(ynt)$) node {$+$};
        \draw ($(ynb)!.5!(yt)$) node[color=red] {$+$};
        \draw [dotted]
              (0,1.5em) -- (0,13em)
              (1,1.5em) -- (1,9em)
              (2,1.5em) -- (2,9em)
              (3,7.5em) -- (3,9em)
              (3,1.5em) -- (3,6em)
              (4,1.5em) -- (4,6em)
              (5,1.5em) -- (5,3em)
              (5,4.5em) -- (5,6em)
              (7,1.5em) -- (7,3em)
              (2,13em) -- (3,10.5em)
              (4,13em) -- (5,10.5em) -- (5,7.5em)
              (6,13em) -- (7,10.5em) -- (7,4.5em);
    \end{tikzpicture}
    \caption{Overlap add algorithm (linear convolution, with circular in red). }
    \label{fig:overlap_add}
\end{figure}
Therefore $x[n]$ can
be expressed by a sum of shifted finite-length sequences:
\begin{equation}
    \label{eq:sum_seq} x[n] = \sum_{i=0}^{\infty} x_i[n-iL] \qquad x_i[n] =\begin{cases}
        x[n+iL] & n = 0, 1, \ldots, L-1\\
        0 & \text{else} \end{cases}
\end{equation}
Applying the linear convolution to this sum leads to
\begin{equation}
    \begin{split}\label{eq:overlap_add_sum}
        y[n] = h[n] * x[n] & = \sum_{i=0}^{\infty} x_i[n-iL] * h[n] = \sum_{i=0}^{\infty} y_i[n-iL]
    \end{split}
\end{equation}
where $y_i[n]$ is the linear convolution of $x_i[n]$ with $h[n]$. Because every $y[n]$ is of length
$N = L + n_{fft} -1$, \cref{eq:circ} utilizing n-point \glspl{fft} can be used to calculate the results.
Every convoluted subsequence $y_i[n]$ overlaps by $n_{fft} - L$. Since this overlapping
points are summed up by \cref{eq:overlap_add_sum}, this method is called overlap
add. A visualisation can be seen in \cref{fig:overlap_add}. The red part in the figure
is the circular extension of the linear convolution, which is done by adding the
$n_{fft} - L$ points after the sequence $y[n]$ to the beginning of $y[n]$.

As mentioned earlier the filter \device{fir1} needs a static image of the samples.
Another requirement is, that samples are continously output to the \gls{dac}. This
is needed to ensure that the \gls{dut} does not leave eventual bias points during
measurements. Therefor the buffer \device{buffer2} after the filter was implemented
with double buffering. This means that this sample buffer consists of an active
and an inactive buffer. The active buffer is used to continuously play back the output
signal, while the inactive buffer can be used during the filter calculations. After
a new signal period has been computed the buffers can be swapped without interrupting
the output signal.

The last element in the processing chain is the complex multiplier \device{mul1}. This
multiplier is responsible for the actual reflection generation. It allows
adjusting the phase and amplitude of the reflection coefficient $\Gamma_{L,set}$ by
varying $X$ and $Y$. Samples from \device{buffer2} are continuously multiplied
with this reflection coefficient and output to the analog part as signal $a_2$.

The digital interface needed to forward the processed samples to the analog part
was implemented according to the digital \gls{iq} interface supported by the used
SMBV100A signal generator from Rhode \& Schwarz. According to \cite{fsq_b17}, this interface is
implemented according to the channel link serializer described in \cite{ds90cr485}. This
serializer uses eight \gls{lvds} data lines and one \gls{lvds} clock line. Each of the lines
is clocked at \SI{700}{\mega\hertz} for a sample rate of \SI{100}{\mega\hertz}. An adapter
board was developed for this work that allows connecting pin headers of an \gls{fpga} board with
the needed mini D ribbon connector\cite{fsq_b17}. The connector and the wiring schema for the adapter
were laid out according to the data sheet in \cite{fsq_b17}. One missing detail from the documentation,
which was found out empirically during this work, is that the S\_CLK pin of the connector
has to be connected to ground. This signal is marked for future use in the data sheet \cite{fsq_b17}.
Without this ground connection the SMBV100A signal generator does not recognize a connected peripheral
at the digital \gls{iq} port. A photo of the implemented pin header to digital \gls{iq} adapter including
the fix can be seen in \cref{fig:iq_adapter_circ}.

\begin{figure}[htb]
    \begin{subfigure}[c]{.45\linewidth}
        \centering
        \begin{tikzpicture}
            \node[anchor=south west,inner sep=0pt] (image) at (0,0) {\includegraphics[width=\textwidth]{adc.jpg}};
            \begin{scope}[x={(image.south east)},y={(image.north west)},every node/.style={fill=white, fill opacity=0.8}]
                \draw (0,0.6) node[anchor=south west] {analog in};
                \draw (1,0) node[anchor=south east] {power supply};
                \draw (0.1,0.1) node[anchor=south west] {data+};
                \draw (0.2,1) node[anchor=north west] {data-};
                \draw (0.9,1) node[anchor=north east] (clk) {clock};
                \draw [-latex] (clk) -- (0.5,0.85);
                \draw (0.95,0.825) node[anchor=north east] {sync circuit};
                \draw (1,0.35) node[anchor=south east] {SATA};
            \end{scope}
        \end{tikzpicture}
        \caption{\gls{adc} adapter circuit board with disconnected clock line, atop the LTC2274 demo board}
        \label{fig:adc_adapter_circ}
    \end{subfigure}%
    ~
    \begin{subfigure}[c]{.45\linewidth}
        \centering
        \begin{tikzpicture}
            \node[inner sep=0pt] (image) at (0,0) {\includegraphics[width=\textwidth]{digital_iq.jpg}};
        \end{tikzpicture}
        \caption{Digital \gls{iq} adapter circuit board with S\_CLK fix}
        \label{fig:iq_adapter_circ}
    \end{subfigure}
    \caption{Photos of implemented adapter boards}
    \label{fig:adapters}
\end{figure}

The complete digital signal processing chain described in this section was implemented
in an \gls{fpga}. A detailed description of the digital hardware implementation can
be seen in \cref{chap:fpga}.

% ===========================================================================

\chapter{\glsentryshort{fpga} Implementation}
\label{chap:fpga}

The digital part, as described in \cref{sec:digital}, was realized in \gls{vhdl}.
It was specifically tailored to a Xilinx Virtex5 FXT on a ML507 evaluation board.
The \gls{fpga} model XC5VFX70T on this evaluation board provides the necessary
high speed transceivers, sufficient block \glspl{ram}, and dedicated digital
signal processing hardware \cite{virtex5ds}. Furthermore the ML507 board contains
the \gls{sata} connector needed for the \gls{adc} and high speed differential
pin headers which can be used for the digital \gls{iq} interface. Additionally, the board contains an
Ethernet port enabling high speed data exchange with a \gls{pc}. Although, according to
\cite{ml507}, the \gls{sata} headers are only rated up to \SI{1.5}{\giga\bit\per\second},
it was confirmed during tests that the necessary \SI{2}{\giga\bit\per\second}, as required
by the \gls{adc} \cite{ltc2274}, are also technically feasible. This \gls{fpga} also contains a
hardwired PowerPC \gls{cpu}, which was used for controlling the digital components
and as a communication bridge to the \gls{pc}. The complete source codes can be found in \cref{sec:sources}.

\tikzset{inbuf/.style={color=Set1-4-1}}
\tikzset{core/.style={color=Set1-4-2}}
\tikzset{outbuf/.style={color=Set1-4-3}}
\tikzset{pc/.style={color=Set1-4-4}}

\begin{figure}[htb]
    \centering
    \begin{subfigure}[c]{.69\linewidth}
        \centering
        \resizebox{\linewidth}{!}{
        \begin{tikzpicture}[every node/.style={minimum width=5em},latex-latex]
            \matrix (peripherals)[matrix of nodes,column sep=1.5em,row sep=0.2em,nodes={draw,anchor=center},ampersand replacement=\&]
            {
                DRAM \& \shortstack{DRAM\\Controller} \\
                |[pc]| Ethernet \& \shortstack{Ethernet\\Controller} \\
                |[pc]| RS232 \& \shortstack{RS232\\Interface} \\
                Storage \& Sys ACE \\
                \shortstack{LEDs\\Switches} \& GPIO \\
            };
            \node[draw,minimum size=5em,above right=0em of peripherals] (cpu) {CPU};
            \draw (peripherals-1-1) -- (peripherals-1-2);
            \draw (peripherals-1-2) -| ([xshift=-2.5em]cpu);
            \draw ([yshift=1em]peripherals-2-2) -| ([xshift=-1.5em]cpu);
            \foreach \i in {2,...,5}
            {
                \draw (peripherals-\i-1) -- (peripherals-\i-2);
                \draw (peripherals-\i-2) -- (peripherals-\i-2 -| cpu);
            }
            \draw[ultra thick,-] (peripherals-5-2 -| cpu) ++(0,-1em) node[below] (plb) {PLB} -- (cpu);
            \node[draw] at ($(peripherals-5-2)!2!(peripherals-5-2 -| cpu)$) (bram) {RAM};
            \draw (peripherals-5-2 -| cpu) -- (bram);
            \node[draw] at ($(peripherals-2-2)!2!(peripherals-2-2 -| cpu)$) (pint) {\shortstack{Processor\\Interface}};
            \draw (peripherals-2-2 -| cpu) -- (pint);
            \matrix (internal)[matrix of nodes,column sep=1em,row sep=0.2em,nodes={draw,anchor=center},right=of pint]
            {
                |[inbuf]| inbuf \\
                |[core]| core \\
                |[outbuf]| outbuf \\
                auto \\
            };
            \node[draw,right=1.5em of internal-3-1] (digiq) {Digital IQ};
            \node[draw,right=1.5em of internal-1-1] (adc) {ADC};
            \node[coordinate] at ($(pint.east) + (2em,0)$) (l) {};
            \foreach \i in {1,...,4}
            {
                \draw (pint.east) -- (l) |- (internal-\i-1);
            };
            \draw[inbuf,latex-] (internal-1-1) -- (adc);
            \draw[outbuf,-latex] (internal-3-1) -- (digiq);
            \node[draw,fit=(cpu) (peripherals-5-2) (plb) (bram),inner xsep=0.5em,label=processor] (processor) {};
            \node[coordinate] at ($(processor.north) + (0,1em)$) (u) {};
            \node[draw,fit=(internal-1-1) (internal-4-1) (l),inner xsep=0.5em,label=main] (main) {};
            \node[draw,fit=(processor) (main) (u),inner xsep=0.5em,label=top] (fpga) {};

        \end{tikzpicture}
        }
        \caption{\gls{fpga} modules and interconnections}
        \label{fig:fpga_modules}
    \end{subfigure}%
    ~
    \begin{subfigure}[c]{.29\linewidth}
        \centering
        \resizebox{\linewidth}{!}{
        \begin{tikzpicture}
            \tikzpicturedependsonfile{rfsymbols.tex}
            \tikzstyle{every node}=[font=\footnotesize]
            \draw (0,-1.5cm) node[coordinate,label=left:Dig IQ] (dac) {}

                  (0,1.5cm) node[coordinate,label=left:ADC] (adc) {}
                  node[empty,right=of adc,label=below:buffer1,inbuf] (inbuf) {}
                  node[mixer,right=of inbuf,core] (shift) {}
                  node[rotate=90,anchor=north] at (shift.east) {mix2}

                  (dac -| inbuf) node[mixer,label=above:mul1,outbuf] (mul) {}
                  node[empty,right=of mul,outbuf] (outbuf) {}
                  node[rotate=90,anchor=north] at (outbuf.east) {buffer2}

                  ($(shift)!.5!(outbuf)$) node[allpass,rotate=90,core] (H) {}
                  node[rotate=90,anchor=north] at (H.south) {fir1}

                  node[source,above=of shift.center,scale=0.7,core] (shiftsource) {}
                  node[rotate=90,anchor=south,font=\tiny] at (shiftsource.west) {$\SI{30}{\mega\hertz}$}
                  node[rotate=90,anchor=north] at (shiftsource.east) {lo3}
                  node[below=of mul.center,fill=white] (gamma) {$\Gamma_{set} = X + jY$};

            { [on background layer,every path/.style={dashed}]
                \draw ($(adc.east)!.5!(mul.west) + (0,4)$) -- ++(0,-8.5) node[coordinate] (rightsplit) {};
            }
            { [-latex]
                \draw [double,core] (shiftsource) -- (shift);
                \draw [outbuf] (gamma) -- (mul);
            }
            { [start chain,every on chain/.style={join=by -latex}]
                \chainin (adc);
                { [every on chain/.style={join=by {inbuf,-latex}}]
                    \chainin (inbuf);
                }
                \chainin (shift);
                { [every on chain/.style={join=by {double,-latex}}]
                    { [every on chain/.style={join=by {double,core,-latex}}]
                        \chainin (H);
                    }
                    \chainin (outbuf);
                    { [every on chain/.style={join=by {double,outbuf,-latex}}]
                        \chainin (mul);
                        \chainin (dac);
                    }
                }
            }

            \draw (rightsplit) node[anchor=base west] {Digital}
                  node[anchor=base east] {Analog};

            {[densely dashdotdotted,latex-latex,pc]
                \draw ($(inbuf.north) + (0,1)$) -- ++(0,1) node [anchor=south] {\glsentryshort{pc}};
            }
        \end{tikzpicture}
        }
        \caption{Digital signal processing chain}
        \label{fig:digital_chain}
    \end{subfigure}
    \caption{\gls{fpga} design overview and digital signal processing chain with color coded modules.}
    \label{fig:fpga_overview}
\end{figure}

The design overview, as can be seen in \cref{fig:fpga_modules}, describes
the high level modules of the design and connections between them. The overall
design was split into two parts. The digital signal processing chain
in \cref{fig:digital_chain} (see \cref{sec:digital}) implemented in the
\device{main} module. The \device{main} module is described in
\cref{sec:digital_processing}. The second part is the \device{processor} module
which contains a complete system on chip. This module was used to be able to
implement the necessary protocols for communicating with a \gls{pc} in software.
It is described in \cref{sec:processor}.

This design uses the unrelated clocks from the \gls{plb} and the \gls{adc}.
Therefore clock synchronization was needed to minimize the chance of metastable
processes. This was achieved using a two-stage synchronizer as the base
synchronization circuit. Signals with short pulses were synchronized with an
additional pulse shaping to prevent lost pulses. Signal buses were synchronized
with an open loop approach. This approach leaves out the acknowledgement of the
synchronization which is sufficient for this design because the
\device{processor} module is not fast enough to change the bus value within the
synchronization period. Block \gls{ram} in the used \gls{fpga} are true dual port
memories. Therefore no synchronization is necessary for read access. If one port
writes to the memory the other port must not access the same location at the same
time\cite{virtex5}. Care was taken to avoid this situation by disallowing
memory access from the other port during writes.

All hardware source codes and project files, which are needed to generate the hardware, can
be found in \cref{sec:sources}.

% ---------------------------------------------------------------------------

\section[Digital Signal Processing Chain]{Digital Signal Processing Chain - main}
\label{sec:digital_processing}

The \device{main} module contains the digital signal processing chain. As can be seen
in \cref{fig:main_overview} the different parts of the processing chain (\cref{fig:digital_chain1}) are mapped
to three modules (\cref{fig:main}). The module \device{inbuf} contains the digital receive interface
for the \gls{adc} and the sample buffer \device{buffer1}. This module is described
in \cref{sec:acquisition}. The \device{core} module contains the frequency
mixer \device{mix2}, the \gls{lo} \device{lo3}, and the digital filter \device{fir1}.
A detailed description can be seen in \cref{sec:overlap_add}. The third part
is the \device{outbuf} module. This module contains the sample buffer \device{buffer2},
the multiplier \device{mul1}, and the digital \gls{iq} interface and is described in \cref{sec:smbv_interface}. The
filter \device{fir1} is not capable of handling a continuous data stream (see
\cref{sec:overlap_add}). Therefore the \device{auto} module was implemented to emulate
continuous behaviour by sequentially activating the modules \device{inbuf}, \device{core},
and \device{outbuf}. A more detailed description of the \device{auto} module can be seen
in \cref{sec:auto}.

\begin{figure}[htb]
    \centering
    \begin{subfigure}[c]{.49\linewidth}
        \centering
        \begin{tikzpicture}[every node/.style={minimum width=5em},latex-latex]
            \node[coordinate] (pint) {};
            \matrix (internal)[matrix of nodes,column sep=1em,row sep=0.2em,nodes={draw,anchor=center},right=of pint]
            {
                |[inbuf]| inbuf \\
                |[core]| core \\
                |[outbuf]| outbuf \\
                auto \\
            };
            \node[draw,right=1.5em of internal-3-1] (digiq) {Digital IQ};
            \node[draw,right=1.5em of internal-1-1] (adc) {ADC};
            \node[coordinate] at ($(pint.east) + (2em,0)$) (l) {};
            \foreach \i in {1,...,4}
            {
                \draw (pint) -- (l) |- (internal-\i-1);
            };
            \draw[inbuf,latex-] (internal-1-1) -- (adc);
            \draw[outbuf,-latex] (internal-3-1) -- (digiq);
            \node[draw,fit=(internal-1-1) (internal-4-1) (l),inner xsep=0.5em,label=main] (main) {};
            \node[fit=(main),inner xsep=0.5em] (fpga) {};
            \draw[dashed,-] ($(fpga.south east) - (0,1em)$) -- ($(fpga.north east)+(0,1em)$);

        \end{tikzpicture}
        \caption{Overview of the \device{main} module}
        \label{fig:main}
    \end{subfigure}%
    ~
    \begin{subfigure}[c]{.49\linewidth}
        \centering
        \begin{tikzpicture}
            \tikzpicturedependsonfile{rfsymbols.tex}
            \tikzstyle{every node}=[font=\footnotesize]
            \draw (0,-1.5cm) node[coordinate,label=left:Dig IQ] (dac) {}

                  (0,1.5cm) node[coordinate,label=left:ADC] (adc) {}
                  node[empty,right=of adc,label=below:buffer1,inbuf] (inbuf) {}
                  node[mixer,right=of inbuf,core] (shift) {}
                  node[rotate=90,anchor=north] at (shift.east) {mix2}

                  (dac -| inbuf) node[mixer,label=above:mul1,outbuf] (mul) {}
                  node[empty,right=of mul,outbuf] (outbuf) {}
                  node[rotate=90,anchor=north] at (outbuf.east) {buffer2}

                  ($(shift)!.5!(outbuf)$) node[allpass,rotate=90,core] (H) {}
                  node[rotate=90,anchor=north] at (H.south) {fir1}

                  node[source,above=of shift.center,scale=0.7,core] (shiftsource) {}
                  node[rotate=90,anchor=south,font=\tiny] at (shiftsource.west) {$\SI{30}{\mega\hertz}$}
                  node[rotate=90,anchor=north] at (shiftsource.east) {lo3}
                  node[below=of mul.center,fill=white] (gamma) {$\Gamma_{set} = X + jY$};

            { [on background layer,every path/.style={dashed}]
                \draw ($(adc.east)!.5!(mul.west) + (0,4)$) -- ++(0,-8.5) node[coordinate] (rightsplit) {};
            }
            { [-latex]
                \draw [double,core] (shiftsource) -- (shift);
                \draw [outbuf] (gamma) -- (mul);
            }
            { [start chain,every on chain/.style={join=by -latex}]
                \chainin (adc);
                { [every on chain/.style={join=by {inbuf,-latex}}]
                    \chainin (inbuf);
                }
                \chainin (shift);
                { [every on chain/.style={join=by {double,-latex}}]
                    { [every on chain/.style={join=by {double,core,-latex}}]
                        \chainin (H);
                    }
                    \chainin (outbuf);
                    { [every on chain/.style={join=by {double,outbuf,-latex}}]
                        \chainin (mul);
                        \chainin (dac);
                    }
                }
            }

            \draw (rightsplit) node[anchor=base west] {Digital}
                  node[anchor=base east] {Analog};

            {[densely dashdotdotted,latex-latex,pc]
                \draw ($(inbuf.north) + (0,1)$) -- ++(0,1) node [anchor=south] {\glsentryshort{pc}};
            }
        \end{tikzpicture}
        \caption{Digital signal processing chain}
        \label{fig:digital_chain1}
    \end{subfigure}
    \caption{\device{main} module overview and digital signal processing chain with color coded modules.}
    \label{fig:main_overview}
\end{figure}

Necessary bit width truncations throughout the digital signal processing chain use
convergent rounding. This rounding mode was used to prevent \gls{dc} offsets. It rounds
to even integers in case of a tie. For example rounding 4.5 with this method
results in 4. The same would be true for 3.5. Thus rounding does not introduce an offset towards infinity or zero, as would
be the case for round half up. Additionally, overflows are signalled and saturation is
used where applicable.

The sample buffer size was chosen according to the available block
\gls{ram} in the \gls{fpga}. A maximum number of 148 \SI{36}{\kilo\bit} block
\glspl{ram} is available in the Virtex 5 (part XC5VFX70T) on the ML507 board\cite{virtex5ds}. Those block \glspl{ram}
can also be used as two independent \SI{18}{\kilo\bit} block \glspl{ram}. As
mentioned in \cref{sec:digital}, this design needs to support a sample width
of \SI{16}{\bit}. Input averaging was chosen to support a maximum of 8 samples,
resulting in an overall needed bit with of \SI{19}{\bit} for the input buffer. Since
the output buffer uses double buffering and needs to be able to store \gls{iq} signals,
two buffers with a bit width of \SI{32}{\bit} are needed. In order to achieve a high memory utilization,
constrained by the possible block \gls{ram} bit widths, a single data bit of a buffer was
realised with a \SI{36}{\kilo\bit} and a \SI{18}{\kilo\bit} block \gls{ram}. This leads
to a total number of 124.5 block \glspl{ram}, leaving enough for the embedded processor
and the \gls{fft} implementation. Using this memory layout only a 2-to-1 multiplexer
for the output is needed. Since the highest address line can
be used as selection between both block \glspl{ram}, no address decoder is needed. This ensures fast operation of the
overall memory. In one bit mode only \SI{32}{\kilo\bit} (\SI{16}{\kilo\bit})
are available. This leads to a theoretical buffer depth of 49152 samples. However as
will be explained in \cref{sec:overlap_add} (see also \cref{sec:digital}), if circular convolution
with a block size of $L$ and an \gls{fft} size of $n_{fft}$ is used for the \gls{fir} filter,
the full buffer depth is not usable. This is caused by the implementation of the overlap add
algorithm which needs additional buffer space of $L - n_{fft}$ samples after the signal.

% ---------------------------------------------------------------------------

\subsection[Data Acquisition]{Data Acquisition - inbuf}
\label{sec:acquisition}

The \device{inbuf} module is responsible for serial to parallel conversion
of the \gls{adc} data, descrambling, triggering, averaging and storing
the acquired samples. As can be seen in \cref{fig:inbuf}, this module consists
of the main modules \device{receiver}, which handles receiving the data stream from
\gls{adc}, and \device{average\_mem}, which handles storing the samples in a buffer
and averaging. The additional modules \device{trigger}, \device{prepare} and
\device{wallclk} are responsible for controlling the data acquisition and keeping
the time, which is needed for the \gls{iq} demodulation that will be explained in \cref{sec:overlap_add}.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \foreach \i/\j in {0/2pt,1/0pt}
        {
            \begin{scope}[xshift=\j,yshift=\j,every node/.style={draw,fill=white}]
                \node (gtx\i) {GTX};
                \node[left=2em of gtx\i] (descramble\i) {descramble};
                \node[below=1em of gtx\i] (align\i) {align};
                \draw[latex-latex] (align\i) -- (gtx\i);
                \draw[-latex] (gtx\i) -- (descramble\i);
                \draw[latex-latex] (gtx\i.east) -- ++(2.5em,0); % node[draw,anchor=west] {adc};
            \end{scope}
        };
        \node[trapezium,rotate=90,anchor=center,draw,minimum height=1em] at ($(descramble0.west) + (-2em,-1pt)$) (mux) {};
        \draw[-latex] ([xshift=-2pt]descramble0.west) -- (mux.south |- descramble0);
        \draw[-latex] (descramble1.west) -- (mux.south |- descramble1);

        \node[fit=(descramble1) (gtx0) (align1),draw,label=receiver] (receiver) {};

        \node[circle,left=of mux.north,draw] (adder) {$+$};
        \draw[-latex] (mux) -- (adder);

        \node[draw,left=of adder] (memory) {memory};
        \draw[-latex] (adder) -- (memory);

        \draw[latex-latex] (memory.west) -- ++(-2em,0) node[coordinate] (out) {};
        \draw[-latex] (memory) -- ++(0,2em) node[coordinate] (upper) {} -| (adder);

        \node[fit=(memory) (adder) (upper),label=average\_mem,draw,inner xsep=0.5em] (average) {};
        \node[draw,anchor=west] at ($(average.south west) + (0,-2em)$) (prepare) {prepare};
        \node[draw,anchor=east] at ($(average.south east) + (0,-2em)$) (trigger) {trigger};

        \draw[-latex] (trigger) -- (average.south -| trigger);
        \draw[latex-latex] (prepare) -- (average.south -| prepare);

        \draw[-latex] (prepare) -- (trigger);
        \draw[latex-latex] (prepare) -- (prepare -| out);

        \node[draw,below=1em of trigger] (wallclk) {wallclk};
        \draw[-latex] (wallclk) -- (\currentcoordinate -| out);
        \draw[-latex] (trigger) -- (wallclk);

        \node[draw,fit=(average) (receiver) (trigger) (wallclk.north),inner ysep=2em,inner xsep=0.5em,label=inbuf] (inbuf) {};
        \draw[dashed] (inbuf.south east) ++(0.5em,-1em) -- (\currentcoordinate |- inbuf.north) -- ++(0,1em);
    \end{tikzpicture}
    \caption{Block diagram of the \device{inbuf} module}
    \label{fig:inbuf}
\end{figure}

The serial to parallel conversion was implemented using the built in GTX
transceiver. Since the ML507 board features two \gls{sata} ports, two
identical receivers were implemented. Since the GTX blocks need
a lot of configuration settings, they were instantiated using the
recommended method, which is the transceiver wizard documented in \cite{gtx_wizard}. The
settings used in this work were chosen according to the data sheet
of the \gls{adc} \cite{ltc2274}. The receiver was configured to handle the
specifications as described in the \cref{sec:digital}. These are 8b/10b line coding,
a data width of \SI{16}{\bit} and a target line rate of \SI{2}{\giga\bit\per\second}.
Synchronization was configured for a set ISMODE of the \gls{adc}. In this mode the
transmitter of the \gls{adc} sends idle ordered sets consisting of
K28.5 commas followed by either D5.6 or D16.2 code words\cite{ltc2274}. A comma is a special
code sequence of the 8b/10b line coding, which does not represent valid data\cite{gtx}.
To be able to synchronize the GTX receiver according to these specifications, the comma
alignment was set to align to even byte boundaries and to detect the K28.5 comma. After
serial to parallel conversion, the endianness is converted to the internal representation.
The recovered clock from the received data stream is used as the internal sampling clock.
This setup allows the use of an externally provided sampling clock, by connecting it to
the \gls{adc} instead of the clock provided by the \gls{adc} adapter circuit board
mentioned in \cref{sec:digital}. The receiver and
the transmitter share the internal clock generation of the GTX. Therefore the transmitter
had to be configured for the same line rate. To be able to transmit a clock signal with the
transmitter, the 8b/10b line coding was disabled for the transmitter and a fixed clock pattern was applied
to the parallel input.

It is not possible to provide an externally generated clock directly to the
\gls{sata} connected GTX transceivers, because of design limitations of the ML507 evaluation
board. Since using a clock, which is routed through the global clock
network of the \gls{fpga} introduces jitter \cite{gtx}, an externally provided sampling clock
connected to the \gls{adc} is the preferred mode of usage.

The module \device{align} controls the clock signal, which is transmitted using
the GTX. This module contains a state machine that blanks the clock signal
for \SI{41}{\milli\second} after a loss of sync of the receiver. A loss of sync is
detected if either a comma value or a value that is not part of the 8b/10b line coding
is detected. After the blanking period the clock signal is reactivated and
the GTX is put into alignment mode, which searches for the above mentioned comma
K28.5. If no comma is detected during a further \SI{41}{\milli\second} period the
synchronization re-starts from the beginning.

Succeeding the GTX transceiver, the \device{descrambler} module descrambles the data
according to the data sheet of the \gls{adc}\cite{ltc2274}. This descrambler
can be bypassed, therefore allowing the use of \glspl{adc} that do not support
this feature.

%TODO
The JESD204 also supports using a scrambler on the raw data, in order to lessen the
noise caused by the digital transmission in the analog part. The scrambler implemented for
this project is based on the generator polynomial given in \cref{eq:poly} \cite{jesd205B.01}. This scrambler can
be bypassed if a different \gls{adc} is used. A more detailed explanation of the input interface
can be found in \cref{sec:acquisition}.
\begin{equation}
    \label{eq:poly} g(x) = 1 + x^{14} + x^{15}
\end{equation}
%TODO

Averaging the data is handled by the \device{average\_mem} module. This module
consists of the above mentioned \SI[product-units=brackets]{19 x 49152}{\bit} memory. Averaging is achieved
by reading the appropriate sample from the buffer and adding it to the current value.
For the first run the read sample is replaced with the value zero. Using this method
the sampled values are accumulated over a configurable number of rounds of zero, two,
four or eight rounds. Averaging is achieved during memory access from outside the module
by shifting the accessed values by zero, one, two or three bit. This is equal to dividing
the samples by the number of rounds used for averaging. This method needs
both ports of the memory. Therefore the memory interface to the rest of the \gls{fpga}
shares the ports with the rest of the implementation. Since both access needs do
not share the same clock, the above mentioned clock multiplexing was implemented.

If the data acquisition is not in use, the \device{average\_mem} is powered by
the \gls{fpga} clock. Before data acquisition starts, the \device{prepare} module
takes care of disabling the block \gls{ram} during the clock switching operation.
During data acquisition the \device{average\_mem} is powered by the sampling clock
which was recovered from the received data stream. After the data acquisition finishes, the
\device{prepare} module transitions the clock signal back to the system clock.
Write operations to the memory are ignored during data acquisition. Read operations
during data acquisition don't interfere with the process but the read out data is invalid.

The \device{trigger} module generates the start signal for the \device{average\_mem}
and the \device{wallclk} module. During the first run and after a reset, the trigger can either be triggered
externally or internally. The external trigger is sampled from the pin AN33 of the
\gls{fpga}, which is connected to HDR1\_64 on the evaluation board. After the first
successful trigger, consecutive triggers are only generated at multiples of the configured signal period $n$.

Subsequent to a trigger event, the \device{wallclk} module takes a snapshot of the
jiffy counter which marks the time the first sample of the current acquisition
was acquired. This is needed to be able to generate the \SI{30}{\mega\hertz}
signal for the \gls{iq} demodulation (see \cref{sec:digital,sec:overlap_add}).

%TODO
Undefined behaviour can occur in the block \gls{ram}, if the timing conditions of the address signals are violated
while the enable signal is high. This can lead to memory corruption
even if write enable is not asserted\cite{virtex5}. Therefore, the
enable signal of the block \gls{ram} is switched to low during clock transitions.
Since this is not possible for an unstable sample clock, the validity of
the sample buffers is not guaranteed during port operation of the \gls{adc} data connection.

% ---------------------------------------------------------------------------

\subsection[Overlap Add]{Overlap Add - core}
\label{sec:overlap_add}

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \node[source] (source) {};
        \node[circle,draw,below=1em of source] (wavemul) {$\times$};
        \draw[double,-latex] (source) -- (wavemul);
        \draw[latex-] (source.west) -- ++(-2em,0) node[coordinate] (out) {};
        \draw[latex-] (wavemul.west) -- (\currentcoordinate -| out);

        \node[draw,fit=(wavemul) (source),inner xsep=0.5em,label=below:wave] (wave) {};

        \node[draw,right=4em of wavemul] (fft) {fft};
        \draw[double,-latex] (wavemul) -- (fft);

        \node[circle,draw,right=4em of fft] (mul) {$\times$};
        \node[draw,above=5em of mul] (H) {H};
        \draw[double,latex-latex] (H) -- (\currentcoordinate -| out);

        \draw[double,-latex] (H) -- (mul);
        \draw[double,-latex] (fft) -- (mul);

        \node[draw,right=of mul] (scratch) {scratch};
        \draw[double,-latex] (mul) -- (scratch);
        \draw[double,-latex] (scratch.east) -| ++(1em,2em) -| ($(fft.west) - (1em,0)$) -- (fft);

        \node[circle,draw,below=of scratch] (add) {$+$};

        \draw[double,-latex] (scratch.east) -- ++(1em,0) node[coordinate] (r) {} |- (add);
        \draw[double,-latex] (fft.east) -- ++(2em,0) |- (add);
        \draw[double,-latex] (fft.east) -- ++(2em,0) -- (\currentcoordinate |- add) -| ($(mul.east)!.5!(scratch.west)$) -- (scratch);

        \draw[double,-latex] (add.south) -- ++(0,-1em) node[coordinate] (d) {} -- (\currentcoordinate -| out);
        \draw[double,latex-latex] (scratch) -- ($(mul.east)!.5!(scratch.west)$) -- (\currentcoordinate |- d) -- (\currentcoordinate -| out);

        \node[draw,fit=(wave) (add) (scratch) (r) (d),label={[xshift=8em]overlap\_add}] (overlap) {};
        \node[draw,fit=(overlap) (H),label=core] (core) {};
    \end{tikzpicture}
    \caption{Block diagram of the \device{core} module}
    \label{fig:core}
\end{figure}

The digital filter \device{fir1}, as described in \cref{sec:digital}, was
realized in \gls{vhdl} without any software components. This module is named
\device{core} in the source codes and a general overview can be seen in \cref{fig:core}.
It consists of the buffer \device{H}, which is needed to store the transfer
function, and the module \device{overlap\_add}, which contains the signal
processing. The \device{overlap\_add}
module itself contains the module \device{wave}, which is responsible for \gls{iq}
demodulation, the \device{fft} module, which can calculate the \gls{fft} and
inverse-\gls{fft}, a complex adder, a complex multiplier, and additional block
\gls{ram}, needed as temporary buffer space (\device{scratch}).

The \gls{iq} demodulation module \device{wave} consists of a hard coded look up
table, that generates a \SI{30}{\mega\hertz} sine and cosine waveform for
a sampling rate of \SI{100}{\mega\hertz}. Furthermore it contains multipliers,
which multiply the incoming samples with the sine and cosine waveforms, for
converting the signal into I and Q samples. Since this is not performed
at real time, but during filter execution, the generated sine and
cosine waveforms are evaluated at the calculated point in time from the
jiffy counter, contained in the \device{wallclk} module (see \cref{sec:acquisition}), and the current sample position.

A Xilinx LogiCore IP was used as the \device{fft} module \cite{xilinx_fft}. In
order to minimize block \gls{ram} usage and increase the performance, the
pipelined version with three stages in block \gls{ram}, which is the minimum
setting, was used for this work. Furthermore it was set to allow a modification of the
\gls{fft} length at runtime, with a maximum length of 4096. A further runtime configuration
setting is, that this core can be switched between \gls{fft} and inverse \gls{fft}. This
allowed using only one \device{fft} module, therefore reducing the resource usage further. Every
computational part of the \gls{fft}, called a butterfly, consists of a multiplication
and addition. This increases the needed bit width after every butterfly.
Keeping every bit for \gls{fft} lengths of this size is not possible with this hardware
because of resource constraints. Therefore scaling was used and is implemented
with a divider after every group, where one group consists of two butterflies.
Every divider can divide the samples by one, two, four or eight. The correct
scaling schedule for the \gls{fft} and inverse \gls{fft} is found by incrementing
the divider schedule by one until the computation stops overflowing. Input
data for the \gls{fft} core needs to be in natural order. Output data is in
bit reversed order.

The complex multiplier was implemented with a runtime changeable scaling schedule. This
schedule can be set to shift the result by 14 to 17 bits. Therefore the transfer function
should always be scaled to the maximum possible values. The best overall scaling schedule
can be found by first configuring the scaling schedule of the \gls{fft}, then the
complex multiplier and after that the inverse \gls{fft}.

\begin{figure}[htb]
    \centering
    \begin{subfigure}[t]{.49\linewidth}
        \centering
        \resizebox{\linewidth}{!}{
        \begin{tikzpicture}[gray]
            \node[draw,black] (wave) {wave};
            \draw[latex-,red] (wave.west) -- ++(-1em,0) node[coordinate] (out) {} node[left] {$x$};

            \node[draw,right=2em of wave,black] (fft) {fft};

            \node[circle,draw,right=2em of fft] (mul) {$\times$};
            \node[coordinate,above=1.5em of mul] (u) {};
            \node[above=3em of mul] (H) {$H$};

            \draw[double] (H) -- (mul);
            \draw[double] (fft) -- (mul);

            \node[draw,right=of mul] (scratch) {scratch};
            \draw[double] (mul) -- (scratch);
            \draw[double] (scratch.east) -| ++(1em,2em) -| ($(fft.west) - (1em,0)$) -- (\currentcoordinate |- fft);

            \node[circle,draw,below=of scratch] (add) {$+$};

            \draw[double] (scratch.east) -- ++(1em,0) node[coordinate] (r) {} |- (add);
            \draw[double] (fft.east) -- ($(fft.east)!.5!(mul.west)$) |- (add);
            \draw[double] (fft.east) -- ($(fft.east)!.5!(mul.west)$) -- (\currentcoordinate |- add) -| ($(mul.east)!.5!(scratch.west)$) -- (scratch);

            \draw[double] (add.south) -- ++(0,-1em) node[coordinate] (d) {} -- (\currentcoordinate -| out) node[left] {$y$};
            \draw[double] (scratch) -- ($(mul.east)!.5!(scratch.west)$) -- (\currentcoordinate |- d) -- (\currentcoordinate -| out);

            \node[draw,fit=(wave) (add) (scratch) (r) (d) (u),inner xsep=0.5em,black] (overlap) {};
            \node[black,anchor=south east] at (overlap.north east) {overlap\_add};
            \draw[double,-latex,red] (wave) -- (fft);
        \end{tikzpicture}
        }
        \caption{Step 1: Up converting and filling \device{fft} with samples.}
        \label{fig:stage1}
    \end{subfigure}%
    ~
    \begin{subfigure}[t]{.49\linewidth}
        \centering
        \resizebox{\linewidth}{!}{
        \begin{tikzpicture}[gray]
            \node[draw] (wave) {wave};
            \draw (wave.west) -- ++(-1em,0) node[coordinate] (out) {} node[left] {$x$};

            \node[draw,right=2em of wave,black] (fft) {fft};
            \draw[double] (wave) -- (fft);

            \node[circle,draw,right=2em of fft,black] (mul) {$\times$};
            \node[coordinate,above=1.5em of mul] (u) {};
            \node[above=3em of mul,red] (H) {$H$};

            \node[draw,right=of mul,black] (scratch) {scratch};
            \draw[double] (scratch.east) -| ++(1em,2em) -| ($(fft.west) - (1em,0)$) -- (fft);

            \node[circle,draw,below=of scratch] (add) {$+$};

            \draw[double] (scratch.east) -- ++(1em,0) node[coordinate] (r) {} |- (add);
            \draw[double] (fft.east) -- ($(fft.east)!.5!(mul.west)$) |- (add);
            \draw[double] (fft.east) -- ($(fft.east)!.5!(mul.west)$) -- (\currentcoordinate |- add) -| ($(mul.east)!.5!(scratch.west)$);

            \draw[double] (add.south) -- ++(0,-1em) node[coordinate] (d) {} -- (\currentcoordinate -| out) node[left] {$y$};
            \draw[double] ($(mul.east)!.5!(scratch.west)$) -- (\currentcoordinate |- d) -- (\currentcoordinate -| out);

            \node[draw,fit=(wave) (add) (scratch) (r) (d) (u),inner xsep=0.5em,black] (overlap) {};
            \node[black,anchor=south east] at (overlap.north east) {overlap\_add};
            \draw[double,-latex,red] (fft) -- (mul);
            \draw[double,-latex,red] (mul) -- (scratch);
            \draw[double,-latex,red] (H) -- (mul);
        \end{tikzpicture}
        }
        \caption{Step 2: Unloading \device{fft} and complex multiplication.}
        \label{fig:stage2}
    \end{subfigure}\\
    \begin{subfigure}[t]{.49\linewidth}
        \centering
        \resizebox{\linewidth}{!}{
        \begin{tikzpicture}[gray]
            \node[draw] (wave) {wave};
            \draw[latex-] (wave.west) -- ++(-1em,0) node[coordinate] (out) {} node[left] {$x$};

            \node[draw,right=2em of wave,black] (fft) {ifft};
            \draw[double] (wave) -- ($(fft.west) - (1em,0)$);

            \node[circle,draw,right=2em of fft] (mul) {$\times$};
            \node[coordinate,above=1.5em of mul] (u) {};
            \node[above=3em of mul] (H) {$H$};

            \draw[double] (H) -- (mul);
            \draw[double] (fft) -- (mul);

            \node[draw,right=of mul,black] (scratch) {scratch};
            \draw[double] (mul) -- ($(mul.east)!.5!(scratch.west)$);

            \node[circle,draw,below=of scratch] (add) {$+$};

            \draw[double] (scratch.east) -- ++(1em,0) node[coordinate] (r) {} |- (add);
            \draw[double] (fft.east) -- ($(fft.east)!.5!(mul.west)$) |- (add);
            \draw[double] (fft.east) -- ($(fft.east)!.5!(mul.west)$) -- (\currentcoordinate |- add) -| ($(mul.east)!.5!(scratch.west)$);

            \draw[double] (add.south) -- ++(0,-1em) node[coordinate] (d) {} -- (\currentcoordinate -| out) node[left,blue] {$y$};
            \draw[double,latex-,blue] (scratch) -- ($(mul.east)!.5!(scratch.west)$) -- (\currentcoordinate |- d) -- (\currentcoordinate -| out);

            \node[draw,fit=(wave) (add) (scratch) (r) (d) (u),inner xsep=0.5em,black] (overlap) {};
            \node[black,anchor=south east] at (overlap.north east) {overlap\_add};
            \draw[double,-latex,red] (scratch.east) -| ++(1em,2em) -| ($(fft.west) - (1em,0)$) -- (fft);
        \end{tikzpicture}
        }
        \caption{Step 3: Loading the \device{fft} with the computed samples and loading scratch with the previous block.}
        \label{fig:stage3}
    \end{subfigure}%
    ~
    \begin{subfigure}[t]{.49\linewidth}
        \centering
        \resizebox{\linewidth}{!}{
        \begin{tikzpicture}[gray]
            \node[draw] (wave) {wave};
            \draw[latex-] (wave.west) -- ++(-1em,0) node[coordinate] (out) {} node[left] {$x$};

            \node[draw,right=2em of wave,black] (fft) {ifft};
            \draw[double] (wave) -- (fft);

            \node[circle,draw,right=2em of fft] (mul) {$\times$};
            \node[coordinate,above=1.5em of mul] (u) {};
            \node[above=3em of mul] (H) {$H$};

            \draw[double] (H) -- (mul);
            \draw[double] (fft) -- (mul);

            \node[draw,right=of mul,black] (scratch) {scratch};
            \draw[double] (mul) -- (scratch);
            \draw[double] (scratch.east) -| ++(1em,2em) -| ($(fft.west) - (1em,0)$) -- (fft);

            \node[circle,draw,below=of scratch,black] (add) {$+$};

            \draw[double] (fft.east) -- ($(fft.east)!.5!(mul.west)$) -- (\currentcoordinate |- add) -| ($(mul.east)!.5!(scratch.west)$) -- (scratch);

            \draw[double,-latex,red] (scratch.east) -- ++(1em,0) node[coordinate] (r) {} |- (add);
            \draw[double,-latex,red] (add.south) -- ++(0,-1em) node[coordinate] (d) {} -- (\currentcoordinate -| out) node[left] {$y$};
            \node[draw,fit=(wave) (add) (scratch) (r) (d) (u),inner xsep=0.5em,black] (overlap) {};
            \draw[double] (scratch) -- ($(mul.east)!.5!(scratch.west)$) -- (\currentcoordinate |- d);
            \node[black,anchor=south east] at (overlap.north east) {overlap\_add};
            \draw[double,-latex,red] (fft.east) -- ($(fft.east)!.5!(mul.west)$) |- (add);
        \end{tikzpicture}
        }
        \caption{Step 4: Unloading \device{fft} and adding the overlapping part from \device{scratch}.}
        \label{fig:stage4}
    \end{subfigure}
    \caption{Overlap add algorithm hardware implementation}
    \label{fig:overlap_add_machine}
\end{figure}

The overlap add algorithm, was implemented with two separate state machines.
This allows speeding up the process since some parts can be calculated in parallel.
The first state machine controls the \gls{fft} and the complex multiplication part of the
algorithm. It is called \device{fftncmul}. Inverse \gls{fft} and complex
addition is handled by \device{ifftnadd}. The overall process is described in
\cref{fig:overlap_add_machine}. Every block of size $L$ (see \cref{fig:overlap_add})
needs to be processed within four steps. In the first step (\cref{fig:stage1}),
the \device{fft} module is loaded with $L$ \gls{iq} demodulated samples from the source memory $x$. According to
the overlap add algorithm, after $L$ samples the data input of the \device{fft}
is switched to zero. After the \device{fft} module has finished processing,
the second step (\cref{fig:stage2}) starts. In this step the data is multiplied
with $H$ and stored in the scratch buffer. During the next step (\cref{fig:stage3}),
the \device{fft} module is switched to inverse operation and the samples from the
\device{scratch} buffer are loaded into the \device{fft} module. At the same time
the \device{scratch} buffer is filled with the previous computed block from the target
memory $y$. After the \device{fft} module has finished the computation, the last step (\cref{fig:stage4})
is executed. During this step the overlapping part from the previous block is added and
the samples are unloaded into the target memory. Since the \gls{fft}
module is pipelined, step one of the next block is started after step three
of the current block has finished. This means, that the \gls{fft} module computes
the samples of two different blocks at the same time. With this technique, the
duration of the overlap add algorithm is reduced by one stage per $L$ sized block.
If the circular mode is enabled, then the block after the signal is added to the
beginning (see \cref{fig:overlap_add}). Since this process needs $L - n_{fft}$ samples
after the end of the signal, the sample buffer can't be used to the full extent.

The overall module is freely configurable and accepts \gls{fft} sizes 8, 16,
32, 64, 128, 256, 512, 1024, 2048 and 4096. The signal size $n$ has to be between
8 and 65535 and the block size $L$ between 1 and 4096. There are no plausibility
checks in the hardware, which means that wrong settings will lead to undefined
behaviour. The \device{core} module can be stopped by issuing a reset signal.
Numerical overflows are separately reported for \gls{fft}, inverse \gls{fft}
and complex multiplication.

% ---------------------------------------------------------------------------

\subsection[SMBV Interface]{SMBV Interface - outbuf}
\label{sec:smbv_interface}

The \device{outbuf} module consists of two independent sample buffers
\device{mem\_0} and \device{mem\_1}, a complex multiplier and the digital
\gls{iq} interface \device{transmitter}. The two sample buffers are both
\SI{32}{\bit} wide, to be able to store the \SI{16}{\bit} wide I and Q
signals. Both can store up to 49152 samples. A general overview can be
seen in \cref{fig:outbuf}.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \node[draw] (mem0) {mem\_0};
        \node[draw,below=of mem0] (mem1) {mem\_1};
        \node[coordinate] at ($(mem0.west)+(-4em,0)$) (out) {};

        \draw[double] ($(mem0.west)-(1em,0)$) -- ($(mem1.west)-(2em,0)$)  node[coordinate] (out2) {};
        \draw[double] ($(mem1.west)-(1em,0)$) -- ($(mem0.west)-(2em,0)$);
        \draw[double,latex-latex] (mem0.west) -- (out);
        \draw[double,latex-latex] (mem1) -- (mem1 -| out);

        \node[trapezium,minimum height=1em,rotate=-90,anchor=center,draw] at ($(mem0.south east)!0.5!(mem1.north east) + (3em,0)$) (mux) {};

        \draw[double,-latex] (mem0.east) -| ([yshift=0.5em]$(mux.south) - (1em,0)$) -- ([yshift=0.5em]mux.south);
        \draw[double,-latex] (mem1.east) -| ([yshift=-0.5em]$(mux.south) - (1em,0)$) -- ([yshift=-0.5em]mux.south);

        \node[circle,draw,right=of mux.north] (mul) {$\times$};
        \draw[double,-latex] (mux) -- (mul);
        \draw[double,latex-] (mul.south) -- ++(0,-3em) node[coordinate] (r) {} -- (\currentcoordinate -| out);

        \node[draw,right=of mul] (transmitter) {transmitter};
        \draw[double,-latex] (mul) -- (transmitter);
        \draw[double,-latex] (transmitter.east) -- ++(2em,0);

        \node[draw,fit=(mem0) (r) (transmitter) (out2),inner xsep=0.5em,label=outbuf] (outbuf) {};
        \draw[dashed] (outbuf.south east) ++(0.5em,-1em) -- (\currentcoordinate |- outbuf.north) -- ++(0,1em);
    \end{tikzpicture}
    \caption{Block diagram of the \device{outbuf} module}
    \label{fig:outbuf}
\end{figure}

Sample buffers \device{mem\_0} and \device{mem\_1} can only be accessed by the
logical names \device{active} and \device{inactive} from outside the
\device{outbuf} module. The \device{active} sample buffer contains the sample data,
which is streamed via the \device{transmitter} module to the digital \gls{iq}
interface. This memory can only be used in read mode via the internal interface.
The \device{inactive} sample buffer can be read and written to. Maintaining this
logical to physical assignment is handled by the network, indicated to the left
of the sample buffers, and the multiplexer in \cref{fig:outbuf}. Both sample
buffers consist of true dual port block \glspl{ram}. In combination with the
unsupported writes to the \device{active} sample buffer, this ensures that
no timing conditions are violated, due to the different clocks.

This module uses a configurable signal period $n$. This period can only be changed
by resetting the module or by asserting the resync signal. Sample data of length $n$ is
continuously read from the \device{active} buffer. Swapping the \device{active}
and the \device{inactive} buffer can be initiated by asserting the toggle\_buf
signal for one cycle. To prevent signal distortion, the actual swapping occurs
only before reading sample zero from the buffer. Accesses to the sample buffers
during this operation result in undefined behaviour and can corrupt the buffer
content.

The complex multiplier, between the multiplexer and the \device{transmitter}
module in \cref{fig:outbuf}, is responsible for the
reflection generation. It multiplies the signal output to the transmitter
with $\Gamma_{L,set}$ (see \cref{sec:digital}). As mentioned earlier, this
multiplier features a bit shifter at the output. This bit shifter shifts the
output by a configurable range of \SIrange{2}{17}{\bit}. With that operation
it is possible to reach full scale output also for small input
signals. This is necessary if, e.g., a high scaling factor is needed
for the \device{core} module (see \cref{sec:overlap_add}). After this scaling
and convergent rounding, the multiplier is also capable of saturating the
output. This would prevent a wrap around and therefore limit signal distortion.

According to \cite{fsq_b17} the Rhode \& Schwarz digital \gls{iq} interface
uses the encoding scheme and digital interface of a DS90CR485 channel link
serializer. This serializer encodes data from a \SI{24}{\bit} input on both
clock edges resulting in a total of \SI{48}{\bit} per clock cycle \cite{ds90cr485}.
As specified by \cite{fsq_b17} \SI{20}{\bit} I data, \SI{20}{\bit} Q data, enable,
valid, marker bits, and trigger bits need to be encoded in these \SI{48}{\bit}. Enable
and valid are connected to high in this implementation. The marker and trigger
bits are not supported by the Rhode \& Schwarz SMBV100a vector signal generator
in digital \gls{iq} input mode. Therefore these were permanently disabled in this
work. The \gls{fpga} internal \SI{16}{\bit} \gls{iq} implementation was mapped
onto the \SI{20}{\bit} link by left shifting the data by \SI{4}{\bit}.

The \device{transmitter} module is an implementation of the DS90CR485 channel
link serializer specification in \gls{vhdl}. Since \cite{fsq_b17} does not
mention which operating mode of the channel link serializer is needed, the
full DS90CR485 specification according to \cite{ds90cr485} was implemented during this work.
According to this specification, the \SI{48}{\bit}, as mentioned in the last
paragraph, need to be partitioned onto eight \gls{lvds} links clocked at
\SI{700}{\mega\hertz}. It is not possible to achieve such high frequencies
in the \gls{fpga} fabric. Therefore the serialization was implemented utilizing
\glspl{oserdes} in \SI{4}{\bit} \gls{ddr} mode. The \gls{ddr} mode reduces the
necessary clock rate to \SI{350}{\mega\hertz} for the \gls{oserdes}. Furthermore the
\SI{4}{\bit} mode decreases the needed clock for the parallel data to
\SI{175}{\mega\hertz}. By connecting a test implementation of the transmitter,
it was verified, that the Rhode \& Schwarz digital \gls{iq} interface uses the
DS90CR485 channel link serializer with switched off \gls{dc} Balance mode.

% ---------------------------------------------------------------------------

\subsection{Auto module}
\label{sec:auto}

For the complete signal computation, the previously described blocks
\device{inbuf} (see \cref{sec:acquisition}), \device{core} (see
\cref{sec:overlap_add}) and \device{outbuf} (see \cref{sec:smbv_interface})
need to be triggered in this order. To minimize the delay and \gls{cpu}
usage, the \device{auto} module contains a state machine that can achieve
this task. It supports single shot and continuous operation.

During a single run, the \device{auto} module first triggers the \device{inbuf}
module. After data acquisition is finished, the filter operation is carried out
by starting the \device{core} module. If an overflow occurs during these
computations, the automatic mode is stopped. After a successful filter
operation the \device{outbuf} buffer is toggled. If the \device{auto} module
is switched to continuous mode, then the whole process repeats.

Because of the way the \device{auto} module was implemented for this thesis,
it is necessary to clear eventual overflows of the \device{core} module before
enabling the automatic mode.

% ---------------------------------------------------------------------------

\section{Processor}
\label{sec:processor}

The embedded processor design was realized using the \gls{xps}. The
design consists of every additional module needed to be
able to run Linux and communicate via Ethernet. As can be seen in
\cref{fig:cpu_design}, this includes a \gls{dram} controller, an
Ethernet controller, a RS232 interface, a System ACE controller,
a \gls{gpio} module, and an additional memory controller with a connected
block \gls{ram}. Additionally, an interrupt controller is needed which is
not included in \cref{fig:cpu_design}.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}[every node/.style={minimum width=5em},latex-latex]
        \matrix (peripherals)[matrix of nodes,column sep=1.5em,row sep=0.2em,nodes={draw,anchor=center},ampersand replacement=\&]
        {
            DRAM \& \shortstack{DRAM\\Controller} \\
            Ethernet \& \shortstack{Ethernet\\Controller} \\
            RS232 \& \shortstack{RS232\\Interface} \\
            Storage \& Sys ACE \\
            \shortstack{LEDs\\Switches} \& GPIO \\
        };
        \node[draw,minimum size=5em,above right=0em of peripherals] (cpu) {CPU};
        \draw (peripherals-1-1) -- (peripherals-1-2);
        \draw (peripherals-1-2) -| ([xshift=-2.5em]cpu);
        \draw ([yshift=1em]peripherals-2-2) -| ([xshift=-1.5em]cpu);
        \foreach \i in {2,...,5}
        {
            \draw (peripherals-\i-1) -- (peripherals-\i-2);
            \draw (peripherals-\i-2) -- (peripherals-\i-2 -| cpu);
        }
        \draw[ultra thick,-] (peripherals-5-2 -| cpu) ++(0,-1em) node[below] (plb) {PLB} -- (cpu);
        \node[draw] at ($(peripherals-5-2)!2!(peripherals-5-2 -| cpu)$) (bram) {RAM};
        \draw (peripherals-5-2 -| cpu) -- (bram);
        \node[draw] at ($(peripherals-2-2)!2!(peripherals-2-2 -| cpu)$) (pint) {\shortstack{Processor\\Interface}};
        \draw (peripherals-2-2 -| cpu) -- (pint);
        \draw[latex-,dashed] (pint.east) -- ++(2em,0);
        \node[draw,fit=(cpu) (peripherals-5-2) (plb) (bram),inner xsep=0.5em,label=processor] (processor) {};
        \node[coordinate] at ($(processor.north) + (0,1em)$) (u) {};
        \node[fit=(processor) (u),inner xsep=0.5em,label=top] (fpga) {};
        \draw[-] (fpga.south east) -- (fpga.south west) -- (fpga.north west) -- (fpga.north east);
        \draw[-,dashed] (fpga.north east) -- ++(2em,0);
        \draw[-,dashed] (fpga.south east) -- ++(2em,0);

    \end{tikzpicture}
    \caption{Block diagram of the \device{processor} module}
    \label{fig:cpu_design}
\end{figure}

The internal block \gls{ram} is needed because the PowerPC 440 embedded
in the used \gls{fpga} has a reset address which resides in the highest
addressable page\cite{ppc}. Since the \gls{dram} is mapped at the lowest address
and is only \SI{256}{\mebi\byte} large\cite{ml507}, the processor would try to access
a non existing address after a reset. The \gls{cpu} starts
executing code before the complete setup is finished initializing. To prevent such undefined
behaviour after programming the \gls{fpga}, a memory has to be placed at
this address. This memory needs to be filled with a boot loop. A boot
loop is a simple program consisting of an endless loop. Since Linux
also uses this address range, this small memory can't be implemented
as a \gls{rom}.

To enable a communication with a computer the RS232 module and the Ethernet
module are needed. The RS232 module is not necessary for production use,
but needed for debugging purposes. The System ACE module is required to
provide access to the \gls{cf} card on the ML507 board. With this module,
a network boot setup is unnecessary, therefore enabling easier deployment
of the whole system. The \gls{gpio} module was included into this setup,
to provide the \gls{os} with access to the \glspl{led} and switches for
indicating purposes.

% ---------------------------------------------------------------------------

\subsection{Processor Interface}
\label{sec:processor_interface}

The processor interface, allowing the processor to control the digital
signal processing chain, consists of three modules. A \gls{xps} module which
interfaces with the \gls{plb}, called \device{proc2fpga}, a module
implementing the registers, called \device{proc\_register}, and a module
implementing a small memory controller, called \device{proc\_memory}. Separating
the \gls{plb} interface into a \gls{xps} module allowed keeping the whole
\device{processor} module fixed during development. See \cref{sec:kernel_module}
for a description of the software needed to control the processor interface.

The \gls{plb} interface was implemented with the peripheral wizard in \gls{xps}.
It uses the burst variant of the \gls{plb} slave \cite{slave_burst}. This module
exposes four user memories with \SI{16}{\bit} addressing and \SI{32}{\bit} data
bus, six \SI{32}{\bit} registers, and 16 interrupt lines to the \gls{fpga} fabric.
The interrupt lines are triggered on the positive edge. In order to enable wide
memory access the burst variant is needed to be able to use memory mapping in
Linux. In this mode, Linux handles the
size of the memory access, which results in reading or writing in whole
cache lines. The \gls{plb} is \SI{128}{\bit} wide. Therefore, the non burst variant
can't handle these operations, since the module interface is only \SI{32}{\bit}
wide. The burst variant handles this situation by queuing four consecutive
\SI{32}{\bit} operations. Without this, a Bus Error would be generated.

An overview of the register contents can be seen in \cref{sec:registers}. These
registers and the interrupt generation are implemented in the \device{proc\_register}
module. Every register has an access time of a single cycle.

The memory controller implemented in the \device{proc\_memory} module generates
the necessary acknowledge signals for the processor. Furthermore it generates the
write and enable signals from the chip select and write request signals of the
processor interface. Special care was taken to allow multi cycle requests as
described above.


% ===========================================================================

\chapter{Software Implementation}
\label{chap:software}
Controlling the hardware from within the linux operating system can be
achieved with by either mmaping \emph{/dev/mem} or writing a kernel module.
mmap has the disadvantage that interrupts can not be used and concurrent
access leads to undefined behaviour. Another disadvantage is that directly
using \emph{/dev/mem} is dangerous and can easily lead to system crashes.
Furthermore a kernel module can provide an easy api that can be easily
used by any programming language, shell script or even echo. Because of
these advantages the following kernel module has been implemented.

\section{Kernel Module}
\label{sec:kernel_module}
\lstset{language=C,numbers=left,numberstyle=\tiny,stepnumber=5,numbersep=5pt,frame=single,
breaklines=true,postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
captionpos=b,escapeinside={(*}{*)},mathescape=true,deletekeywords={register}}

\begin{lstlisting}[float=htb,caption={Basic elements of a platform driver module},label=src:pdriver,basicstyle=\hack\tiny]
...

struct emce_device { (*\label{deviceData}*)
	struct cdev cdev;
	dev_t dev;
	unsigned long reg_start;
	unsigned long reg_size;
	void __iomem *base_address;
	spinlock_t register_lock;
	struct user_mem mem[USER_MEM];
	unsigned int irq;
	struct kernfs_node *int_nodes[16];
};

...

static int emce_of_probe(struct platform_device *ofdev) { (*\label{probe}*)
	...
}

static int emce_of_remove(struct platform_device *of_dev) { (*\label{remove}*)
	...
}

static const struct of_device_id emce_of_match[] = { (*\label{match}*)
	{ .compatible = "xlnx,proc2fpga-3.00.b", },
	{ /* end of list */ },
};

MODULE_DEVICE_TABLE(of, emce_of_match); (*\label{dt}*)

static struct platform_driver emce_of_driver = { (*\label{platformDriver}*)
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table = emce_of_match,
	},
	.probe = emce_of_probe,
	.remove = emce_of_remove,
};

module_platform_driver(emce_of_driver); (*\label{pd}*)

MODULE_LICENSE("GPL"); (*\label{macros}*)
MODULE_AUTHOR("Gernot Vormayr <notti@fet.at>");
MODULE_DESCRIPTION("driver for custom fpga interface");
\end{lstlisting}

To keep the driver as generic as possible a platform device driver was
written. Platform device drivers are matched against the device tree and
the kernel takes care of invoking the \lstinline+probe+ and
\lstinline+remove+ functions. Besides the common needed macros in
\Cref{src:pdriver} \Cref{macros} only a \lstinline+struct+ describing the
driver (\Cref{platformDriver}), a list of device names (\Cref{match}),
and the accompanying platform driver macros in \Cref{dt,pd} are needed.
These macros create the module instantiation code and take care of
everything. The only code that needs to be supplied are the bodies of
the probe and remove functions (\Cref{probe,remove}). The probe function
has to allocate memory for the device data stored in the
\lstinline+struct+ defined in \Cref{deviceData}, request access to the
memories, allocate devices and files, setup the interrupt function, and
initialize the interrupt registers. For freeing the resources, everything
has to be released again in the remove function. Omitting this prevents
reloading the driver.\\
The driver handles the three tasks:
\subsubsection{Memory access}
\begin{lstlisting}[float=htbp,caption={Character device},label=src:cdev,basicstyle=\hack\tiny]
ssize_t mem_read (struct file *file, char __user *buf,
		size_t count, loff_t *ppos) { (*\label{mem_read}*)
	struct user_mem *mem = file->private_data;

	if(*ppos >= mem->size)  <*\label{mem_read_checka}*>
		return 0; //EOF

	if(*ppos + count >= mem->size)
		count = mem->size - *ppos; (*\label{mem_read_checkb}*)

	if(copy_to_user(buf, mem->base_address+*ppos, count)) (*\label{mem_read_copy}*)
		return -EFAULT;

	*ppos+=count; (*\label{mem_read_advance}*)
	return count;
}

ssize_t mem_write(struct file *file, const char __user *buf,
		size_t count, loff_t *ppos) {
	...
}

static int mem_open(struct inode *inode, struct file *file) { (*\label{mem_open}*)
	struct emce_device *edev;

	if(MINOR(inode->i_rdev)>=USER_MEM)
		return -ENODEV;

	edev = container_of(inode->i_cdev, struct emce_device, cdev);
	file->private_data = &edev->mem[MINOR(inode->i_rdev)];
	return 0;
}

static loff_t mem_lseek(struct file *file, loff_t offset, int orig) {
	...
}

...

static const struct file_operations emce_fops = { (*\label{fops}*)
	.owner = THIS_MODULE,
	.read = mem_read,
	.write = mem_write,
	.open = mem_open,
	.mmap = mem_mmap,
	.llseek = mem_lseek,
};

static struct class *emce_class;

...

        cdev_init(&edev->cdev, &emce_fops); (*\label{cdev_init}*)
	edev->cdev.owner = THIS_MODULE;
	kobject_set_name(&edev->cdev.kobj, "mem");
	if(cdev_add(&edev->cdev, edev->dev, USER_MEM)) {
		...
	}

	emce_class = class_create(THIS_MODULE, DRIVER_NAME);
	if(IS_ERR(emce_class))
		...

	for(minor = 0; minor < USER_MEM; minor++)
		device_create(emce_class, dev, MKDEV(MAJOR(edev->dev), minor),
				NULL, "emce%d", minor); (*\label{cdev_init_end}*)
\end{lstlisting}

The memories from \device{inbuf}, \device{outbuf} and \device{H} are exposed
to user space via character devices\cite{ldd}. During
\lstinline+probe+ the memory ranges are reserved with
\lstinline+request_mem_region+\cite{ldd} (only one driver is allowed
to handle a memory region at a time) and mapped to a virtual address with
\lstinline+ioremap+\cite{ldd} (only virtual memory can be accessed).
Character devices look to user space as if they were normal files which can
be opened, seeked, read and written. All those operations are possible on
the byte level, hence the name. The following paragraphs reference lines from
\Cref{src:cdev}.\\
To set up a character device a
\lstinline+struct_file_operations+\cite{ldd} is needed. This structure
has an entry for every possible operation, which in turn is a function pointer
which need to point to the implementation. Not implemented functions need to
point to \lstinline+NULL+, which is taken care of by leaving out the fields
in the GNU style initialization seen in \Cref{fops}. One of those functions
is \emph{close}, which is not needed by this driver, because only memory is
accessed and so there is virtually no setup done on \emph{open} and therefor
no cleanup needs to happen. Allocating the necessary
memory and initializing everything is taken care of by the functions in
\Crefrange{cdev_init}{cdev_init_end}. The most important functions are
\lstinline+cdev_init+\cite{ldd} which allocates the driver structure
and initializes the operations, and \lstinline+device_create+ which allocates
and creates the actual devices. Every device needs a major and a minor number,
which are used to identify which device a file belongs to. In this example the
major number is automatically allocated and assigned and the minor number
corresponds to the internal memory number. The rest of the code is boilerplate
which causes the kernel to create the device nodes \emph{/dev/emce0} to
\emph{/dev/emce3}. Without this routines these nodes would need to be created
manually with \emph{mknod}.\\
If user space calls the functions open on one of those device nodes, the
kernel deduces from the major number, that this driver is meant and calls
\lstinline+mem_open+ in \Cref{mem_open}. As mentioned earlier no setup needs
to be done here. This function only checks if the minor number, which tells
the driver which of the memories is meant, is in range and then assigns the
memory area to the private data of the inode\cite{ldd}. Storing this
information within the inode is not actually neede, but without this the
other functions would need to fetch this data on every invocation.\\
Every operation on an opened device is in turn handled by the rest of the
functions which are quiet similar and so only \lstinline+mem_read+ in
\Cref{mem_read} is explained. User space provides a buffer to write to,
and a number of bytes to read (\lstinline+count+). The current file
position is provided with \lstinline+ppos+. Since the requested information
is actually in memory, the only things that need to be done are:
\begin{enumerate}
    \item Boundary Check (\Crefrange{mem_read_checka}{mem_read_checkb}).
    \item Copy the data to user space (\Cref{mem_read_copy}). This must be
        done with the \lstinline+copy_*_user+ macros. Kernel memory and
        user memory must never be mixed!
    \item Advance the file position (\Cref{mem_read_advance}).
    \item Return the number of bytes actually read.
\end{enumerate}
Another additional function which is not absolutely necessary, but can speed
things up, is \emph{mmap} which won't be explained here, but can be looked up
in the sources.
\subsubsection{Register access}
Access to the registers is provided via files in sysfs\cite{sysfs}. To ease
user space handling and follow the spirit of sysfs with one setting per file,
every single flag from \Crefrange{reg0}{reg5} is implemented as a file in
sysfs. The linux kernel provides a very easy to use interface. A sysfs file
can be allocated with a \lstinline+device_attribute+ structure, which needs
a function pointer to a \emph{show} and \emph{store} function, access rights,
and a file name. Setting one of the function pointers to zero, disables read
and or write access. \emph{Show} is called if user space reads from a file 
and \emph{store} if user space writes to a file. Since these files are
supposed to represent a single value there are no \emph{open} and \emph{close}
functions or file positions. \emph{Show} is given a pointer to a single page
that has to be filled and the number of written bytes returned, where is
\emph{store} receives a pointer to a buffer with the user supplied data and
a size parameter.\\
The flags are assigned to attribute groups which in turn represent
subdirectories below the driver directory. For easier handling the driver
has two standard functions and some accompanying macros which can handle
flags in a bit field:
\begin{description}
    \lstitem{FPGA_FLAG(base, name, access, register, bit, length)}
        This macro creates a flag within the group \emph{base} with the name
        \emph{name} and access right \emph{access}. \emph{Register} represents
        the base address, \emph{bit} the bit number within the register and
        \emph{length} the bit width of the flag. \lstinline+_+ represents the
        base directory of the driver.
    \lstitem{FPGA_FLAGM(..., max)}
        This macro has the same arguments as \lstinline+FPGA_FLAG+ with an
        additional \emph{max}, which is the maximum value + 1, that is allowed.
    \lstitem{FPGA_FLAGC(..., show, store)}
        Same as \lstinline+FPGA_FLAGM+ but with the two additional
        arguments \lstinline+show+ and \lstinline+store+ so custom functions
        can be used.
\end{description}
Writing to the memory mapped registers is done with a read modify write cycle,
that is protected by a spin lock. This spin lock isn't actually needed by a
uni processor system and gets optimized away during the compilation. Since
one day this might run on another FPGA which could have a SMP system it is
advised to keep the spin lock.
\subsubsection{Interrupts}
These are reported to user space with sysfs files. The \emph{show} function
returns just an empty line. User space has to read the file and then wait for
an event with \emph{poll}. This function will block until an event is
triggered with \lstinline+sysfs_notify+. The interrupt service routine is
therefor very simple and does the following things:
\begin{enumerate}
    \item Read the interrupt register.
    \item Write to the interrupt register to clear the interrupts.
    \item Call \lstinline+sysfs_notify_dirent+ on the appropriate files. Since
        \lstinline+sysfs_notify+ would need to do a path lookup which is not
        allowed from within interrupts (the path lookup needs a mutex), the
        \lstinline+_dirent+ version is used instead.
    \item Return \lstinline+IRQ_HANDLED+ to signal the kernel, that the
        interrupt handling was successful.
\end{enumerate}
% \Cref{sec:sysfs} presents examples in detail on how to access these events.
\section{Network Server and Web-Interface}
\section{Matlab Driver}
\label{sec:matlab}
\lstset{language=Matlab,numbers=left,numberstyle=\tiny,stepnumber=5,numbersep=5pt,frame=single,
breaklines=true,postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
captionpos=b,escapeinside={(*}{*)},mathescape=true}


% ===========================================================================

\chapter{Verification of the Measurement System}
\label{chap:verification}

The implemented \gls{elp} design was tested with the setup in
\cref{fig:test_setup} at a center frequency $f_0$ of \SI{900}{\mega\hertz}. This test setup consists of the three parts
described in \cref{chap:measurement_system}. As mentioned in
\cref{sec:analog}, instead of a circulator, the directional coupler
\device{dir2} in combination with attenuator \device{att1} was used.
Furthermore, since during verification only waves generated inside
the specified bandwidth of \SI{20}{\mega\hertz} were used, the low-pass filter \device{lp2}
was used instead of a bandpass filter. A detailed list of used
instruments can be seen in \cref{sec:instruments}.

\begin{figure}[htb]
    \centering
    \resizebox{\linewidth}{!}{
    \begin{tikzpicture}
        \pgfdeclarelayer{foreground}
        \pgfsetlayers{background,main,foreground}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[dut] (dut) {}
              node[dircoupler,right=2 of dut,label=below:dir1,label={[font=\tiny]above:\SI{-16}{\deci\bel}}] (dirvna) {}
              node[oscilloscope,above=of dirvna.A2,anchor=A1] (oszivna) {}
              node[dircouplera,right=of dirvna,label=below:dir2,label={[font=\tiny]above:\SI{-16}{\deci\bel}}] (dircirc) {}

              node[coordinate,above=2.5 of dircirc] (uppernode) {}

              node[attenuator,right=of dircirc,label=above:att1,label={[font=\tiny]below:\SI{10}{\deci\bel}}] (att) {}
              node[amplifier,right=of att,label=above:amp1] (amp) {}
              node[mixer,right=of amp,label=above:mix3] (upmix) {}
              node[lowpass,right=of upmix,label=above:lp1] (antialias) {}
              node[adc,right=of antialias,label=above:dac1] (dac) {}

              (uppernode -| upmix) node[mixer,label=below:mix1] (downmix) {}
              node[lowpass,right=of downmix,label=below:lp2,label={[font=\tiny]above:\SI{90}{\mega\hertz}}] (bp) {}
              node[adc,right=of bp,label=below:adc1] (adc) {}
              node[empty,right=of adc,label=below:buffer1] (inbuf) {}
              node[mixer,right=of inbuf] (shift) {}
              node[rotate=90,anchor=north] at (shift.east) {mix2}

              (dac -| inbuf) node[mixer,label=above:mul1] (mul) {}
              node[empty,right=of mul] (outbuf) {}
              node[rotate=90,anchor=north] at (outbuf.east) (buffer2) {buffer2}

              ($(shift)!.5!(outbuf)$) node[allpass,rotate=90] (H) {}
              node[rotate=90,anchor=north] at (H.south) {fir1}

              node[source,above=of downmix.center,scale=0.7] (downsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (downsource.west) {$\SI{830}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (downsource.east) {lo1}
              node[source,above=of adc.center,scale=0.7] (sample) {}
              node[rotate=90,anchor=south,font=\tiny] at (sample.west) {$\SI{100}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (sample.east) {lo2}
              node[source,above=of shift.center,scale=0.7] (shiftsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (shiftsource.west) {$\SI{30}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (shiftsource.east) {lo3}
              node[source,below=of upmix.center,scale=0.7] (upsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (upsource.west) {$\SI{900}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (upsource.east) {lo4}
              node[below=of mul.center,fill=white] (gamma) {$\Gamma_{set}$};

        \draw ($(dut)!.5!(dirvna)$) node[coordinate] (plane) {};

        { [rounded corners=2pt]
            \draw (dut) -- (dirvna) -- (dircirc.A1);
            \draw [-latex] (dircirc.A2) |- (downmix);
            \draw (dirvna.A2) -- (oszivna.A1);
            \draw (dirvna.B2) |- ($(dirvna.B2)!.7!(oszivna.A2)$) node[coordinate] (oszimiddle) {} -| (oszivna.A2);
            \draw [-latex] (att) -- (dircirc.B1);
        }
        { [-latex]
            \draw (downsource) -- (downmix);
            \draw (sample) -- (adc);
            \draw [double] (shiftsource) -- (shift);
            \draw (gamma) -- (mul);
            \draw (upsource) -- (upmix);
        }
        { [latex-,dashed,every node/.style={font=\footnotesize}]
            \foreach \device in {downsource,sample} {
                \draw (\device) -- ++(0,1) node[anchor=south] {\SI{10}{\mega\hertz} ref};
            }
            \draw ([xshift=0.5cm]oszivna.north) -- ++(0,0.5) node[fill=white,anchor=south] {\SI{10}{\mega\hertz} ref};
        }
        { [start chain,every on chain/.style={join=by -latex}]
            \chainin (downmix);
            \chainin (bp);
            \chainin (adc);
            \chainin (inbuf);
            \chainin (shift);
            { [every on chain/.style={join=by {double,-latex}}]
                \chainin (H);
                \chainin (outbuf);
                \chainin (mul);
                \chainin (dac);
                \chainin (antialias);
                \chainin (upmix);
            }
            \chainin (amp);
            \chainin (att);
        }
        { [on background layer,every path/.style={dotted,decorate,decoration=random steps,segment length=2mm}]
            \draw ($(dirvna.B1)!.5!(dircirc.A1) + (0,5.5)$) -- ++(0,-8.5) node[coordinate] (leftsplit) {};
            \draw ($(adc.east)!.5!(mul.west) + (0,4)$) -- ++(0,-8.5) node[coordinate] (rightsplit) {};
        }

        \draw (leftsplit) node[anchor=base east] {One Port \gls{vna}}
              (leftsplit) node[anchor=base west] {Analog}
              (rightsplit) node[anchor=base west] {Digital}
              (rightsplit) node[anchor=base east] {Analog};

%        \draw [-latex] ($(dirvna.A2) + (-0.2,0.1)$) -- node[base left] {$b_1$} ($(oszivna.A1 |- oszimiddle) - (0.2,0.1)$);
%        \begin{pgfonlayer}{foreground}
%            \draw [-latex] ($(dirvna.B2) + (0.2,0.1)$) -- ($(oszimiddle -| dirvna.B2) + (0.2,-0.1)$);
%        \end{pgfonlayer}
%        \draw ($(oszimiddle -| dirvna.B2) + (0.2,-0.1)$) node[base right,fill=white] {$a_1$};

        \draw [dashed] ($(plane) + (0,5.5)$) node[anchor=south] {Load Reference Plane} -- ($(plane) - (0,3)$);

        \draw [latex-] ($(plane) + (0,1.5)$) -- ++(-0.5,0) node[anchor=east] {$Z_L$};

        \draw [-latex] ($(plane) + (0.25,-1.5)$) node[anchor=west] {$a_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0.25,-2)$) node[anchor=west] {$b_2$}-- ++(-0.5,0);
        \draw [latex-] ($(plane) + (0,-2.5)$) -- ++(-0.5,0) node[anchor=east] {$\Gamma_L$};
        \node [draw,fit=(amp) (dac) (upsource),rounded corners=4pt,inner xsep=6pt,inner ysep=14pt,label={above:Vector Signal Generator}] (sig) {};
        \draw [-latex,dashed] ([xshift=-2cm]sig.south) -- ++(0,-0.5) node[anchor=north] {\SI{10}{\mega\hertz} ref};
        \node [draw,fit=(gamma) (outbuf) (inbuf) (shiftsource) (buffer2),rounded corners=4pt,inner xsep=6pt,inner ysep=14pt,label={above:\gls{fpga}}] (fpga) {};

        {[densely dashdotdotted,latex-latex]
            \draw (fpga.east) -- ++(1,0) node [anchor=west] {\gls{pc}};
            \draw (sig.south) -- ++(0,-0.5) node [anchor=north] {\gls{pc}};
            \draw ([xshift=-0.5cm]oszivna.north) -- ++(0,1) node [anchor=south] {\gls{pc}};
        }
    \end{tikzpicture}
    }
    \caption{Measurement system verification test setup}
    \label{fig:test_setup}
\end{figure}

Since the overall setup consists of two independent systems, namely the one port
\gls{vna} and the reflection generation, those two were verified separately. The
one port \gls{vna} verification can be found in \cref{sec:vna_verify} and the
reflection generation, consisting of the analog part (see \cref{sec:analog}) and
the digital part (see \cref{sec:digital}), can be found in \cref{sec:reflection}.
During these measurements, a noticeable phase drift was observed, and therefore
an additional measurement was acquired, as seen in \cref{sec:drift}, to verify the origin
of this phase drift.

% ---------------------------------------------------------------------------

\section{One Port \glsentryshort{vna}}
\label{sec:vna_verify}

For the calibration and verification of the one port \gls{vna}, the modulator of
the vector signal generator was turned off. Stepping through the frequency range
was achieved by stepping the local oscillator \device{lo4} (see \cref{fig:test_setup}).
A ZV-Z132 (female) calibration kit from Rhode \& Schwarz was used for the calibration
setup in place of the \gls{dut}. Since the calibration is only valid for a single frequency, the full
calibration measurements were acquired for 21 $\Delta{}f$-aligned points in a
\SI{25}{\mega\hertz} range with a center frequency of \SI{900}{\mega\hertz}. This
was achieved by connecting the appropriate port of the calibration kit, and acquiring
$\Gamma_{L,f}$ for every frequency point. After the measurement, the different $\Gamma_{L,f}$ were linearly
interpolated at every $\Delta{}f$ bin. Afterwards the \glspl{sparam} of
the error box (see \cref{sec:vna}) were pre-calculated for every bin with the values
from the data sheet of the calibration kit\cite{zv-z132}.

For verification, a stub tuner from Maury Microwave was tuned to a specific position and
then measured with the one port \gls{vna} in this work. Measurements were acquired over
the whole \SI{25}{\mega\hertz} bandwidth at the calibrated points. Additional measurements
were acquired at an offset of $\frac{1}{2}\Delta{}f$, to be able to test the performance
of the chosen window function, and additionally between the calibrated points, to test the
performance of the interpolation. To be able to verify the measured $\Gamma_L$, measurements
were also acquired with a different \gls{vna}.

\begin{table}[htb]
    \centering
    \begin{tabular}{rrrr}
        \toprule
        \shortstack[r]{\textbf{frequency} \\ \si{\mega\hertz}} & \shortstack[r]{887.5\\(cal)} & \shortstack[r]{887.505\\($\frac{1}{2}\Delta{}f$)} & \shortstack[r]{888.095\\(between cal)} \\
        \midrule
        \shortstack[r]{\textbf{magnitude}\\ 1} & \num{581.0232e-003} & \num{581.0589e-003} & \num{582.3070e-003} \\
            standard error & \num{37.6e-006}     & \num{38.2e-006}     & \num{36.56e-006} \\
           $\Delta$Agilent \gls{vna} & \num{2.1e-003} & \num{2.1e-003} & \num{2.2e-003} \\
        \shortstack[r]{\textbf{angle}\\\si{\degree}}     & \num{-157.5029}     & \num{-157.4787}     & \num{-157.7972} \\
            standard error & \num{8.7e-003}      & \num{8.1e-003}      & \num{9.7e-003} \\
           $\Delta$Agilent \gls{vna} & \num{2.2} & \num{2.3} & \num{2.3} \\
        \bottomrule
    \end{tabular}
    \caption{Measured reflection coefficient with standard error and difference to Agilent \gls{vna}}
    \label{tab:vna}
\end{table}

No noticeable difference in standard error and difference to the results from the Agilent \gls{vna} between the three
different types of points, over the complete \SI{25}{\mega\hertz} range could be observed.
Therefore linear interpolation and the chosen window function are appropriate for this type of
measurement. Since there are only passive parts involved in the one port \gls{vna}, it should
also be possible to use less calibration points to achieve a faster calibration. The measurement
result of three exemplary points can be seen in \cref{tab:vna}.

The results are highly dependent on the used oscilloscope and calibration kit. The standard error
depends notably on the performance of the oscilloscope. Therefore these
results are only valid for the used oscilloscope in this work. Additionally care should be taken, to
always use a strong enough signal power, in order to achieve the best possible oscilloscope resolution. %Oppenheimer p196 SNR-=6db for amplitude/2
The difference to the results from the Agilent \gls{vna} is mainly caused by the used calibration kit.

% ---------------------------------------------------------------------------

\section{Reflection Measurements}
\label{sec:reflection}

The reflection measurements were carried out with the test setup in \cref{fig:test_setup}
with an Agilent \gls{vna} as the \gls{dut}. The Agilent \gls{vna} was connected to the
\SI{10}{\mega\hertz} reference, in order to be able to generate the needed phase coherent
signals for the test setup. This allowed verifying the synthesized $\Gamma_L$, and
calibrating the \gls{fir} filter \device{fir1} more accurately, than using the built
in one port \gls{vna}.

The reflection generation consists of two tasks. First the iterative target algorithm
described in \cref{sec:matlab} is needed, to be able to synthesize specific $\Gamma_L$.
The performance of this algorithm can be seen in \cref{sec:iterative}. This
algorithm was then used for calibrating and verifying the filter \device{fir1}. Measurement
results with the calibrated filter can be seen in \cref{sec:filter}.

\subsection{Iterative target algorithm}
\label{sec:iterative}

\begin{figure}[htb]
    \begin{subfigure}[b]{.5\linewidth}
        \centering
        \begin{tikzpicture}[
            spy/.style={%
                draw,green,
                line width=0.5pt,
                circle,inner sep=0pt,
            },
            ]
            \def\spyviewersize{3cm}
            \def\spyonclipreduce{0.5pt}
            \def\spyfactorI{10}

            \def\pic#1#2{
                \begin{smithchart}[width=.9\linewidth,clip=false#1]
                    \addplot[blue,is smithchart cs] file {testdata/filter/1.0,0/trajectory10.data};
                    \addplot[purple,is smithchart cs,only marks,mark=x#2] file {testdata/filter/1.0,0/trajectory10.data};
                    \draw (cartesian cs:1,0) node[coordinate] (a) {}
                          (cartesian cs:-0.4,0.4) node[coordinate] (b) {};
                \end{smithchart}
            }
            \pic{}{}
            \coordinate (spy-on 1) at (a);
            \coordinate (spy-in 1) at (b);

            \node[spy,ultra thick,circular drop shadow,minimum size=\spyviewersize,fill=white,label={[inner sep=0pt,yshift=-5pt,fill=white,font=\footnotesize]below:\spyfactorI{}x magnification}] (spy-in node 1) at (spy-in 1) {};
            \begin{scope}
                \clip (spy-in 1) circle (0.5*\spyviewersize-\spyonclipreduce);
                \pgfmathsetmacro\sI{1/\spyfactorI}
                \begin{scope}[
                    shift={($\sI*(spy-in 1)-\sI*(spy-on 1)$)},
                    scale around={\spyfactorI:(spy-on 1)}
                ]
                \pic{,every axis plot post/.append style={line width=0.07pt},every axis/.append style={line width=0.07pt,grid style={line width=0.07pt}}}{,mark size=0.35pt}
                \end{scope}
            \end{scope}

        \end{tikzpicture}
        \caption{$\Gamma_{L,target} = 1$}
        \label{fig:find_target_good}
    \end{subfigure}%
    \begin{subfigure}[b]{.5\linewidth}
        \centering

        \begin{tikzpicture}[
            spy/.style={%
                draw,green,
                line width=0.5pt,
                circle,inner sep=0pt,
            },
            ]
            \def\spyviewersize{3cm}
            \def\spyonclipreduce{0.5pt}
            \def\spyfactorI{70}

            \def\pic#1#2{
                \begin{smithchart}[width=0.9\linewidth,clip=false#1]
                    \addplot[blue,is smithchart cs] file {testdata/filter/0.5,-45/trajectory6.data};
                    \addplot[purple,is smithchart cs,only marks,mark=x#2] file {testdata/filter/0.5,-45/trajectory6.data};
                    \draw (cartesian cs:0.35325,-0.35397) node[coordinate] (a) {}
                          (cartesian cs:-0.4,0.4) node[coordinate] (b) {};
                \end{smithchart}
            }
            \pic{}{}
            \coordinate (spy-on 1) at (a);
            \coordinate (spy-in 1) at (b);

            \node[spy,ultra thick,circular drop shadow,minimum size=\spyviewersize,fill=white,label={[inner sep=0pt,yshift=-5pt,fill=white,font=\footnotesize]below:\spyfactorI{}x magnification}] (spy-in node 1) at (spy-in 1) {};
            \begin{scope}
                \clip (spy-in 1) circle (0.5*\spyviewersize-\spyonclipreduce);
                \pgfmathsetmacro\sI{1/\spyfactorI}
                \begin{scope}[
                    shift={($\sI*(spy-in 1)-\sI*(spy-on 1)$)},
                    scale around={\spyfactorI:(spy-on 1)}
                ]
                    \pic{,every axis plot post/.append style={line width=0.01pt}}{,mark size=0.05pt}
                \end{scope}
            \end{scope}
        \end{tikzpicture}
        \caption{$\Gamma_{L,target} = 0.5 \angle \SI{-45}{\degree}$}
        \label{fig:find_target_bad}
    \end{subfigure}
    \caption{Exemplary trajectories of the target algorithm}
    \label{fig:find_target}
\end{figure}

The target algorithm as described in \cref{sec:matlab}, is able to find the
correct $\Gamma_{L,set}$ with a given $\Gamma_{L,start}$ in order to synthesize
a given $\Gamma_L$. All the following measurements used 20000 samples as
signal period $n$ (see \cref{sec:acquisition}), an $L$ of 2000 and an \gls{fft} width $n_{fft}$
of 4096 (see \cref{fig:overlap_add}). The filter \device{fir1} was preloaded with the
impulse response of a low pass filter with a cut off frequency of \SI{25}{\mega\hertz} to
filter out the aliases (see \cref{sec:digital}). For the duration of these measurements,
the \gls{fpga} implementation was switched to automatic mode (see \cref{chap:fpga}). The digital reflection generation introduces
a very high latency on the order of about \SI{1}{\milli\second} with this settings.
Therefore a wait time of \SI{100}{\milli\second} was used for the iterative algorithm
(see \cref{sec:matlab}). This allows the system to settle on a $\Gamma_L$ before continuing
with the algorithm. If the wait time is too short, this algorithm can start to
cause oscillations and the completion time of the algorithm actually increases. Whereas
a long wait time increases the completion time.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
                ybar interval,
                ylabel={percentage of invocations},
                xlabel={number of iterations},
                x filter/.expression={x-1}, % remove the start point
                ymin = 0
            ]
            \addplot[blue,fill=blue!10,hist={bins=7,data min=3,data max=10,density=true}] table[y index=0] {testdata/trajectories/performance.data};
        \end{axis}
    \end{tikzpicture}
    \caption{Histogram of algorithm iterations needed to find a specific $\Gamma_L$}
    \label{fig:iteration_hist}
\end{figure}

Two descriptive example trajectories can be seen in \cref{fig:find_target}. In
\cref{fig:find_target_good} the algorithm terminated just after three steps,
whereas in \cref{fig:find_target_bad} the worst observed case can be seen. The
trajectory in \cref{fig:find_target_bad} oscillates around the target before
reaching it. This is caused either by a too stringent termination condition, or
by a bad resolution of the \gls{vna} or the digital part of this system, in the
target range.

Depending on the start point $\Gamma_{L,start}$ and the target $\Gamma_{L}$
the performance of the algorithm varied. An overall histogram of 108 different
invocations with different $\Gamma_{L,start}$, different $\Gamma_{L,target}$ and
at different frequencies can be seen in \cref{fig:iteration_hist}. The trajectory
in \cref{fig:find_target_bad} is the only one in bin 8.

As can be seen in \cref{fig:find_target,fig:iteration_hist} the algorithm is capable
of reaching a specified reflection coefficient $\Gamma_{L,target}$ within a reasonable
amount of time. Keeping the limitations above in mind the algorithm could be further
accelerated by adjusting the termination condition and the settling time.

\subsection{Filter performance}
\label{sec:filter}

For verification, the filter \device{fir1} in \cref{fig:test_setup} was calibrated
by measuring the needed $\Gamma_{L,set}$ to achieve a specific $\Gamma_L$ over a
baseband range from \SI{-13}{\mega\hertz} to \SI{13}{\mega\hertz} at a \gls{rf} of
\SI{900}{\mega\hertz} (see \cref{sec:matlab}). All following
measurements used the same settings as described in \cref{sec:iterative}, a signal period $n$ of 20000,
$L$ of 2000 and an \gls{fft} width $n_{fft}$ of 4096 (see also \cref{fig:overlap_add}).
Before calibration the filter \device{fir1} was preloaded with a low pass filter, with
a cut off frequency of \SI{25}{\mega\hertz} to filter out the aliases (see
\cref{sec:digital}). For the duration of the measurements, the \gls{fpga} implementation
was switched to automatic mode (see \cref{chap:fpga}). Filter calibration was then carried out at the following $\Gamma_L$
values: $1$, $-1$, $0.5\angle\SI{135}{\degree}$ and $0.5\angle\SI{-45}{\degree}$. Additional
verification measurements were carried out with the mean of the acquired measurements
at $1$ and $-1$, as well as the mean of the measurements at $0.5\angle\SI{135}{\degree}$
and $0.5\angle\SI{-45}{\degree}$. For the following verification measurements, the respective
calibration measurement was added to the filter \device{fir1} by linearly interpolating
the measured $\Gamma_{L,set}$ at every $\Delta{}f$-bin of the filter and then multiplying
these values with the impulse response of the above mentioned alias filter.

The verification measurements were acquired with the Agilent \gls{vna} at frequencies
ranging from \SI{895}{\mega\hertz} to \SI{905}{\mega\hertz} in \SI{1}{\mega\hertz} steps
with a settling time of \SI{0.5}{\second} for every frequency point. To be able to verify
the performance across the whole range, measurements were acquired over the possible
$\Gamma_{L,set}$ range by stepping through an 11 by 11 grid. These measurements were
acquired with the different filter calibrations mentioned above.

The results, which can be seen in \cref{fig:calibrated_filter}, contain every acquired
trajectory in blue and the calibration point in red. Since only the filter \device{fir1}
was calibrated, but neither the target algorithm, nor an error model was used for the
$\Gamma_{L,set}$ values, the overall grid is slightly distorted. As can be seen in these
smith charts, the trajectories spread out at points far away from the calibration points.
As expected, the filter calibrations with the mean values achieve better trajectories
between the calibration points. Since the trajectories around the calibration points
show the best performance, it is advisable to use calibration points near the expected
target $\Gamma_L$ and avoid calibration points at $\abs{\Gamma_L} = 1$. Noticeable
trajectory spreading near the calibration points is caused by the limited numerical
precision of the filter implementation of \device{fir1} (see \cref{sec:overlap_add}).

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{.45\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth,clip=false]
                \foreach \i in {1,...,11}{
                    \foreach \j in {1,...,11}{
                        \addplot[blue,is smithchart cs] file {testdata/filter/1.0,180/\i,\j.data};
                    }
                }
                \addplot[red,is smithchart cs,mark=*,only marks] coordinates {(-1,0)};
            \end{smithchart}
        \end{tikzpicture}
        \caption{$-1$}
    \end{subfigure}%
    \begin{subfigure}[b]{.45\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth,clip=false]
                \foreach \i in {1,...,11}{
                    \foreach \j in {1,...,11}{
                        \addplot[blue,is smithchart cs] file {testdata/filter/0.5,135/\i,\j.data};
                    }
                }
                \addplot[red,is smithchart cs,mark=*,only marks] coordinates {(-0.3536,0.3536)};
            \end{smithchart}
        \end{tikzpicture}
        \caption{$0.5 \angle \SI{135}{\degree}$}
    \end{subfigure}\\
    \begin{subfigure}[b]{.45\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth,clip=false]
                \foreach \i in {1,...,11}{
                    \foreach \j in {1,...,11}{
                        \addplot[blue,is smithchart cs] file {testdata/filter/1.0,0/\i,\j.data};
                    }
                }
                \addplot[red,is smithchart cs,mark=*,only marks] coordinates {(+1,0)};
            \end{smithchart}
        \end{tikzpicture}
        \caption{$1$}
    \end{subfigure}%
    \begin{subfigure}[b]{.45\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth,clip=false]
                \foreach \i in {1,...,11}{
                    \foreach \j in {1,...,11}{
                        \addplot[blue,is smithchart cs] file {testdata/filter/0.5,-45/\i,\j.data};
                    }
                }
                \addplot[red,is smithchart cs,mark=*,only marks] coordinates {(0.3536,-0.3536)};
            \end{smithchart}
        \end{tikzpicture}
        \caption{$0.5 \angle \SI{-45}{\degree}$}
    \end{subfigure}\\
    \begin{subfigure}[b]{.45\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth,clip=false]
                \foreach \i in {1,...,11}{
                    \foreach \j in {1,...,11}{
                        \addplot[blue,is smithchart cs] file {testdata/filter/mean1/\i,\j.data};
                    }
                }
                \addplot[red,is smithchart cs,mark=*,only marks] coordinates {(-1,0) (+1,0)};
            \end{smithchart}
        \end{tikzpicture}
        \caption{$mean(-1,1)$}
    \end{subfigure}%
    \begin{subfigure}[b]{.45\linewidth}
        \centering
        \begin{tikzpicture}
            \begin{smithchart}[width=.9\linewidth,clip=false]
                \foreach \i in {1,...,11}{
                    \foreach \j in {1,...,11}{
                        \addplot[blue,is smithchart cs] file {testdata/filter/mean2/\i,\j.data};
                    }
                }
                \addplot[red,is smithchart cs,mark=*,only marks] coordinates {(0.3536,-0.3536) (-0.3536,0.3536)};
            \end{smithchart}
        \end{tikzpicture}
        \caption{$mean(0.5 \angle \SI{135}{\degree}, 0.5 \angle \SI{-45}{\degree})$}
    \end{subfigure}
    \caption{Reflection measurements with calibrated filter}
    \label{fig:calibrated_filter}
\end{figure}

% ---------------------------------------------------------------------------

\section{Phase Drift}
\label{sec:drift}

During the measurements, phase drift could be noticed. In order to examine the
cause of these phase drifts, a test measurement was acquired, to be able
to observe the extent of the phase drift. For this measurement the test setup
in \cref{fig:test_setup} with the Agilent \gls{vna} (see \cref{sec:instruments})
as \gls{dut} was used. This \gls{vna} was also connected to the
\SI{10}{\mega\hertz} reference, in order to generate phase coherent signals. The
\gls{fpga} implementation was set to 20000 samples as the signal period $n$, an $L$
of 2000 and a \gls{fft} width $n_{fft}$ of 4096 (see \cref{fig:overlap_add}).
According to \cref{sec:digital} \device{fir1} needs at least a low pass filter to
filter out the aliases. Therefore it was preloaded with the impulse response of a low pass filter
with a cut off frequency of \SI{25}{\mega\hertz}. For the duration of the measurements,
the \gls{fpga} implementation was switched to automatic mode (see \cref{chap:fpga}). After
those preparations the system was set to a reflection coefficient $\Gamma_L = 1$ with
the target algorithm. Measurements were acquired every \SI{10}{\second} for a duration
of \SI{1000}{\minute}. The results of those phase drift measurements can be seen in
\cref{fig:phase_single}, which shows the angle of $\Gamma_L$ over time. Since the magnitude did not change noticeably during those measurements
it was left out of the plot.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
                ylabel={angle},
                y unit={\degree},
                xlabel={time},
                x unit={\minute}, %change xbase
                width=\linewidth,
                x filter/.expression={x/60},
                xmin=0,
                xmax=1000,
                height=7cm
            ]
            \addplot[blue] table {testdata/phase/single.data};
        \end{axis}
    \end{tikzpicture}
    \caption{Phase drift of $\Gamma_L$}
    \label{fig:phase_single}
\end{figure}

These results indicate, that the phase drift is not caused by the filter implementation of
\device{fir1}, which would also cause changes of magnitude. Because of that, the test
setup in \cref{fig:setup_phase_single} was devised to measure the phase drift of all the
used local oscillators in the setup. This setup consists of oscilloscopes to measure
the different signals generated by the signal generators. Since the frequencies
of the generators were \SI{830}{\mega\hertz}, \SI{100}{\mega\hertz} and \SI{900}{\mega\hertz},
the additional function generator \device{trigger} (see \cref{fig:setup_phase_single}) was needed to
generate the greatest common divisor of those frequencies, which is \SI{10}{\mega\hertz}.
It was not possible to generate a good enough trigger signal with this function generator, that
allowed reliably measuring the phase of the different signals. Therefore this signal was also recorded.
To be able to measure all the signals, a second oscilloscope had to be used. Since triggering
the second oscilloscope with the first one resulted in a worse performance, than feeding both
oscilloscopes with the same trigger, a chained setup was not used. After the measurement, the
different signals were corrected by the phase offset of the trigger signal, to achieve a phase
offset of the trigger signal of zero. Therefore the results are the same as if the oscilloscopes would
have triggered perfectly. For a list of the used instruments see \cref{sec:instruments}.
Like with the measurement of the whole test setup, a phase offset was acquired every \SI{10}{\second}
for \SI{1000}{\minute}.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \tikzpicturedependsonfile{rfsymbols.tex}
        \tikzstyle{every node}=[font=\footnotesize]
        \draw node[vna] (vna) {}
              node[source,right=of vna,scale=0.7] (downsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (downsource.west) {$\SI{830}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (downsource.east) {lo1}
              node[source,right=of downsource,scale=0.7] (sample) {}
              node[rotate=90,anchor=south,font=\tiny] at (sample.west) {$\SI{100}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (sample.east) {lo2}
              node[source,right=of sample,scale=0.7] (trigger) {}
              node[rotate=90,anchor=south,font=\tiny] at (trigger.west) {$\SI{10}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (trigger.east) {trigger}
              node[source,right=of trigger,scale=0.7] (upsource) {}
              node[rotate=90,anchor=south,font=\tiny] at (upsource.west) {$\SI{900}{\mega\hertz}$}
              node[rotate=90,anchor=north] at (upsource.east) {lo4}

              node[oscilloscope,above=2 of downsource] (oszi1) {}
              node[oscilloscope,right=of oszi1] (oszi2) {};

        {[densely dashdotdotted,latex-latex]
            \draw ([xshift=-0.5cm]oszi1.north) -- ++(0,1) node [anchor=south] {\gls{pc}};
            \draw ([xshift=-0.5cm]oszi2.north) -- ++(0,1) node [anchor=south] {\gls{pc}};
        }
        {[latex-,dashed,every node/.style={font=\footnotesize},rounded corners=2pt]
            \draw [latex reversed-,shorten <=1pt] (upsource) -- ++(0,-1) node[coordinate] (lower) {} -- ++(1,0) node[coordinate] (lowerright) {};
            \draw ([xshift=0.5cm]oszi2.north) -- ++(0,0.5) node[coordinate] (upper) {} -| (lowerright);
            \draw ([xshift=0.5cm]oszi1.north) |- (upper);
            \draw (trigger) |- (lower);
            \draw (sample) |- (trigger |- lower);
            \draw (downsource) |- (sample |- lower) node[anchor=north] {\SI{10}{\mega\hertz} ref};
            \draw (vna) |- (downsource |- lower);
        }
        {[rounded corners=2pt]
            \draw (vna) -- ++(0,1) -| (oszi1.A1);
            \draw (downsource) -- ++(0,1) -| (oszi1.A2);
            \draw (sample) -- ++(0,1.2) -| (oszi1.A3);
            \draw (trigger) -- ++(0,1.4) -| (oszi1.A4);
            \draw (trigger) -- ++(0,1.6) -| (oszi2.A1);
            \draw (upsource) -- ++(0,1.8) -| (oszi2.A2);
        }
    \end{tikzpicture}
    \caption{Phase drift measurement setup}
    \label{fig:setup_phase_single}
\end{figure}

The measurement results, which can be seen in \cref{fig:phase_overall}, show a
trend of the phase drift of every instrument. The phase drift in those instruments is likely
caused in part by phase drift of the oscillators in the instruments. Another part is caused by
the low reference frequency of \SI{10}{\mega\hertz}. During a single period of the reference
signal, a lot of periods need to be generated by the instruments, allowing only far apart
synchronisation points. This means, that a better result can be achieved by using a faster
reference clock. A further component is temperature drift, since the room temperature
of the laboratory was not held constant. For these reasons the measurement results in
\cref{fig:phase_overall} are only exemplary and don't show the real phase drift, since
the trigger source \device{trigger} and the two oscilloscopes also experience phase drift.

\begin{figure}[htb]
    \centering
    \begin{tikzpicture}
        \pgfplotstableread{testdata/phase/all.data}\phaseall
        \begin{axis}[
                ylabel={angle},
                y unit={\degree},
                xlabel={time},
                x unit={\minute},
                x filter/.expression={x/60},
                xmin=0,
                xmax=1000,
                width=\linewidth,
                height=7cm,
                legend style={at={(0.5,1.01)},anchor=south},
                legend columns=4
            ]
            \addplot[blue] table {\phaseall};
            \addlegendentry{\glsentryshort{vna}}
            \addplot[green] table[x index=0,y index=2] {\phaseall};
            \addlegendentry{\device{lo1}}
            \addplot[red] table[y index=3] {\phaseall};
            \addlegendentry{\device{lo2}}
            \addplot[black] table[y index=4] {\phaseall};
            \addlegendentry{\device{lo4}}
        \end{axis}
    \end{tikzpicture}
    \caption{Phase drift of signal generators}
    \label{fig:phase_overall}
\end{figure}

The above mentioned phase drift needs to be kept in mind during measurements. This
drift causes additional phase errors in the resulting $\Gamma_L$ and, depending on
the accuracy needed of the measurements, limits the valid time of the calibration of
the different parts of the measurement setup.

% ===========================================================================

\chapter{Conclusions and Outlook}

\appendix
\chapter{References}
\section{Sources}
\label{sec:sources}
\section{Used Instruments}
\label{sec:instruments}
\section{Register Assignment}
\label{sec:registers}
%TODO:
\begin{register}{h}{reg(0)}{0x00}%
    \label{reg0}%
    \regfield{rec\_rst}{1}{31}{0}%
    \regfield{Reserved}{4}{27}{0}%
    \regfield{rec\_stream\_valid}{1}{26}{0}%
    \regfield{Reserved}{1}{25}{0}%
    \regfield{rec\_input\_select}{1}{24}{0}%
    \regfield{Reserved}{10}{14}{0}%
    \regfield{rec\_data\_valid(1)}{1}{13}{0}%
    \regfield{rec\_rxeqmix(1)}{2}{11}{0}%
    \regfield{rec\_descramble(1)}{1}{10}{1}%
    \regfield{rec\_polarity(1)}{1}{9}{1}%
    \regfield{rec\_enable(1)}{1}{8}{1}%
    \regfield{Reserved}{2}{6}{0}%
    \regfield{rec\_data\_valid(0)}{1}{5}{0}%
    \regfield{rec\_rxeqmix(0)}{2}{3}{0}%
    \regfield{rec\_descramble(0)}{1}{2}{1}%
    \regfield{rec\_polarity(0)}{1}{1}{1}%
    \regfield{rec\_enable(0)}{1}{0}{1}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[rec\_descramble(n)]
        \item[rec\_rst] Writing a 1 to this bit resets the whole receiver.
        \item[rec\_stream\_valid] 1 if stream is valid.
        \item[rec\_input\_select] With this the data stream of receivers 0 or 1
            can be selected.
        \item[rec\_data\_valid(n)] 1 if the data received by n is valid.
        \item[rec\_rxeqmix(n)] Controls the equalizer of the receiver
            \cite{gtx}.
        \item[rec\_descramble(n)] Turns on the descrambler (see
            \cref{sec:acquisition}).
        \item[rec\_polarity(n)] Sets the polarity of the LVDs pair.
        \item[rec\_enable(n)] Enable/Disable transceiver. Disabling unneeded
            transceivers saves power.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(1)}{0x04}%
    \label{reg1}%
    \regfield{avg\_rst}{1}{31}{0}%
    \regfield{Reserved}{3}{28}{0}%
    \regfield{avg\_err}{1}{27}{0}%
    \regfield{avg\_active}{1}{26}{0}%
    \regfield{avg\_width}{2}{24}{0}%
    \regfield{trig\_rst}{1}{23}{0}%
    \regfield{auto\_rst}{1}{22}{0}%
    \regfield{auto\_single}{1}{21}{0}%
    \regfield{auto\_run}{1}{20}{0}%
    \regfield{trig\_int}{1}{19}{0}%
    \regfield{trig\_arm}{1}{18}{0}%
    \regfield{Reserved}{1}{17}{0}%
    \regfield{trig\_type}{1}{16}{0}%
    \regfield{depth}{16}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[auto\_single]
        \item[avg\_rst] Writing a 1 to this bit resets \device{average\_mem}.
        \item[avg\_err] 1 if the data stream became invalid during data
            acquisition. Gets on next trigger event.
        \item[avg\_active] 1 during data acquisition.
        \item[avg\_width] Number of samples over which averaging is done.
        \item[auto\_rst] Writing a 1 to this bit resets \device{auto}.
        \item[auto\_single] Does a single automatic mode cycle
            (acquire, convolute, switch output).
        \item[auto\_run] Automatic mode.
        \item[trig\_rst] Writing a 1 to this bit resets \device{trigger}.
        \item[trig\_int] Writing a 1 to this bit manually triggers the
            internal trigger.
        \item[trig\_arm] Writing a 1 to this bit arms the trigger.
        \item[trig\_type] 0: Internal trigger. 1: External trigger.
        \item[depth] Number of samples to acquire. Can be range 1 - 49152.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(2)}{0x08}%
    \label{reg2}%
    \regfield{Reserved}{4}{28}{0}%
    \regfield{core\_scale\_schi}{12}{16}{011010101010}%
    \regfield{Reserved}{4}{12}{0}%
    \regfield{core\_scale\_sch}{12}{0}{011010101010}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[core\_scale\_schi]
        \item[core\_scale\_schi] Scaling schedule for iFFT run (See
            \cite{xilinx_fft}).
        \item[core\_scale\_sch] Scaling schedule for FFT run (See
            \cite{xilinx_fft}).
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(3)}{0x0C}%
    \label{reg3}%
    \regfield{core\_rst}{1}{31}{0}%
    \regfield{Reserved}{1}{30}{0}%
    \regfield{core\_circular}{1}{29}{0}%
    \regfield{core\_ov\_cmul}{1}{28}{0}%
    \regfield{core\_ov\_ifft}{1}{27}{0}%
    \regfield{core\_ov\_fft}{1}{26}{0}%
    \regfield{core\_start}{1}{25}{0}%
    \regfield{core\_iq}{1}{24}{0}%
    \regfield{Reserved}{3}{21}{0}%
    \regfield{core\_n}{5}{16}{00011}%
    \regfield{core\_scale\_cmul}{2}{14}{0}%
    \regfield{Reserved}{2}{12}{0}%
    \regfield{core\_L}{12}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[core\_scale\_cmul]
        \item[core\_rst] Writing a 1 to this bit resets \device{core}.
        \item[core\_circular] Set to 1 for circular convolution.
        \item[core\_ov\_cmul] 1 if complex multiplication has overflown.
        \item[core\_ov\_ifft] 1 if iFFT has overflown.
        \item[core\_ov\_fft] 1 if FFT has overflown.
        \item[core\_start] Write 1 to this bit to start a convolution run.
        \item[core\_iq] Set to 1 for I/Q demodulation.
        \item[core\_n] Transform size in $\log_2(n_{fft})$. Valid values: 3-12.
        \item[core\_scale\_cmul] Scaling schedule for complex multiplication. Valid values: 0-3.
        \item[core\_L] $L$. See \cref{sec:overlap_add}.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(4)}{0x10}%
    \label{reg4}%
    \regfield{tx\_mulq}{16}{16}{0}%
    \regfield{tx\_muli}{16}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[tx\_mulq]
        \item[tx\_mulq] See \cref{sec:smbv_interface}.
        \item[tx\_muli] See \cref{sec:smbv_interface}.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(5)}{0x14}%
    \label{reg5}%
    \regfield{tx\_shift}{4}{28}{0}%
    \regfield{Reserved}{2}{26}{0}%
    \regfield{tx\_ovfl}{1}{25}{0}%
    \regfield{tx\_sat}{1}{24}{1}%
    \regfield{tx\_rst}{1}{23}{0}%
    \regfield{Reserved}{3}{20}{0}%
    \regfield{tx\_resync}{1}{19}{0}%
    \regfield{tx\_toggle}{1}{18}{0}%
    \regfield{tx\_dc\_balance}{1}{17}{0}%
    \regfield{tx\_deskew}{1}{16}{0}%
    \regfield{tx\_frame\_offset}{16}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[tx\_frame\_offset]
        \item[tx\_shift] Scaling schedule for complex multiplication. Valid values 0-15.
        \item[tx\_ovfl] 1 if an overflow occurred in the complex multiplier.
            Write a 0 to this bit to reset the overflow.
        \item[tx\_sat] Enable saturation for complex multiplier.
        \item[tx\_rst] Writing a 1 to this bit resets \device{outbuf}.
        \item[tx\_resync] Resynchronizes the sample output to
            tx\_frame\_offset on the internal frame clock.
        \item[tx\_toggle] Writing a 1 to this bit switches the output buffers.
        \item[tx\_dc\_balance] Turns DC balance on for the output. (See
            \cite{ds90cr485}).
        \item[tx\_deskew] Writing a 1 to this bit starts a deskew cycle. (See
            \cite{ds90cr485}).
        \item[tx\_frame\_offset] Frame offset.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{intr}{0x220}%
    \label{intr}%
    \regfield{Reserved}{19}{13}{0}%
    \regfield{auto\_stop}{1}{12}{0}%
    \regfield{auto\_start}{1}{11}{0}%
    \regfield{tx\_ovfl}{1}{10}{0}%
    \regfield{tx\_toggled}{1}{9}{0}%
    \regfield{core\_done}{1}{8}{0}%
    \regfield{avg\_done}{1}{7}{0}%
    \regfield{trigd}{1}{6}{0}%
    \regfield{stream\_invalid}{1}{5}{0}%
    \regfield{stream\_valid}{1}{4}{0}%
    \regfield{rec1\_invalid}{1}{3}{0}%
    \regfield{rec1\_valid}{1}{2}{0}%
    \regfield{rec0\_invalid}{1}{1}{0}%
    \regfield{rec0\_valid}{1}{0}{0}%
    \reglabel{Reset}\regnewline%
\end{register}
\FloatBarrier %FIXME
\section{Protocol}
\section{Matlab Classes}
\chapter{Build Instructions}
\section{Hardware}
\section{Software}

\printglossary[type=\acronymtype]

\listoffigures

\bibliographystyle{IEEEtran}
\bibliography{main}

\begin{otherlanguage}{ngerman}
    \chapter*{Code of Conduct}
    Hiermit erkl\"are ich, dass die vorliegende Arbeit ohne unzul\"assige Hilfe Dritter und ohne Benutzung
    anderer als der angegebenen Hilfsmittel angefertigt wurde. Die aus anderen Quellen oder indirekt
    \"ubernommenen Daten und Konzepte sind unter Angabe der Quelle gekennzeichnet.
    Die Arbeit wurde bisher weder im In- noch im Ausland in gleicher oder in \"ahnlicher Form in anderen
    Pr\"ufungsverfahren vorgelegt.

    \par\noindent\makebox[7cm]{\hrulefill}      \hfill\makebox[5cm]{\hrulefill}%
    \par\noindent\makebox[7cm][l]{Unterschrift} \hfill\makebox[5cm][l]{Datum}%
\end{otherlanguage}

\end{document}

