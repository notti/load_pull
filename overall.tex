\documentclass[11pt,technote,a4paper,onecolumn,dvips]{IEEEtran}

\usepackage{etex}
\usepackage{register}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pstricks}
\usepackage{pstricks-add}
\usepackage{pst-circ}
\usepackage{pst-plot}
\usepackage{pst-sigsys}
\usepackage{calc}
\usepackage{tikz-timing}
\usepackage{siunitx}
\usepackage{cite}
\usepackage{url}
\usepackage{dblfloatfix}
\usepackage{listings}
\usepackage{afterpage}

\usepackage[colorlinks,hyperindex,plainpages=false,
pdftitle={Specialized DSP in FPGA with Processor Bindings},
pdfauthor={Gernot Vormayr},
pdfsubject={Bac thesis},
pdfkeywords={},
pdfpagelabels,
pagebackref,
bookmarksopen=false
]{hyperref}

\usepackage[nameinlink]{cleveref}

\markboth{EMCE-Vienna University of Technology,~Sep 2014}{Gernot Vormayr: DSP in FPGA}

\newcommand{\legendline}[2]{\begingroup\setbox0=\hbox{\textcolor{#1}{\rule{4pt}{#2}}}\parbox{\wd0}{\box0}\endgroup}

\newcommand{\signal}[1]{{\ttfamily #1}}
\newcommand{\module}[1]{{\ttfamily\bfseries #1}}
\newcommand{\clk}[1]{{\itshape\ttfamily #1}}

\crefname{Regfloat}{register}{registers}
\Crefname{Regfloat}{Register}{Registers}

\lstdefinelanguage{ucf}{%
 morekeywords={INST,AREA_GROUP,RANGE,LOC},
 sensitive=false,
 morecomment=[l][\#],
 morestring=[b]",
}

\lstset{numbers=left,numberstyle=\tiny,stepnumber=2,numbersep=5pt,frame=single,
breaklines=true,postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
captionpos=b}

\begin{document}

\title{\huge Specialized DSP in FPGA with Processor Bindings}
\author{\IEEEauthorblockN{Gernot Vormayr - 0425210}\\
\IEEEauthorblockA{Vienna University of Technology\\
\url{gvormayr@gmail.com}}}

\maketitle

\begin{abstract}
This bachelor thesis presents a step by step guide for implementing a
specialized DSP functionality on an ML507 Board. The whole guide
covers implementing the actual hardware, the interface to the integrated
PowerPC processor, building the linux kernel and a small base system,
writing a kernel driver for the interface, and implementing a small
web interface in python.
\end{abstract}

\renewcommand{\contentsname}{\small{Table of Contents}}
\tableofcontents

\section{Introduction}
\begin{figure}[bt]
    \centering
    \begin{pspicture}(0,-1.5)(13.25,2)
        \pssignal(0,0){x}{ADC}
        \psblock(2,0){avg}{AVG}
        \pssignal(3.5,-1.5){e}{$e^{j 2 \pi \SI{30}{MHz} \cdot k/T_s}$}
        \pscircleop[operation=times](3.5,0){otimes}       
        \psblock(5,0){fft}{FFT}
        \pssignal(6.5,1.75){h}{$H[n]$}
        \pscircleop[operation=times](6.5,0){ftimes}
        \psblock(8,0){ifft}{iFFT}
        \psblock(10,0){buf}{buffer}
        \pscircleop[operation=times](11.5,0){btimes}
        \pssignal(13.25,0){out}{SMBV}
        \pssignal(13.25,-1){omul}{fixed}

        \psset{style=Arrow}
        \ncline{x}{avg}
        \ncline{avg}{otimes}
        \psset{doubleline=true}
        \nclist{ncline}{e,otimes,fft,ftimes,ifft,buf,btimes,out}
        \ncline{h}{ftimes}
        \ncangle[angleA=180,angleB=-90]{omul}{btimes}

        \fnode[doubleline=false,style=RoundCorners,style=Dash,linecolor=red,framesize=11 2.75](6.5,-0.5){box}
        \nput[offsetA=-4]{90}{box}{\textcolor{red}{DSP}}
    \end{pspicture}
    \caption{Overall datapath. Double lines indicate I/Q-data.}
    \label{fig:datapath}
\end{figure}
The signal processing task to solve consisted of the following steps (see
\Cref{fig:datapath}):
\begin{enumerate}
    \item Read data from ADC (\SI{16}{Bit} \SI{100}{MHz}, LVDS)
    \item Store data into Memory
    \item Averaging
    \item I/Q Demodulation (\SI{30}{MHz})
    \item Convolute values with configurable data
    \item Continuously output computed values (\SI{100}{MHz}, LVDS)
\end{enumerate}
Since data has to be continuously output, even while computing or reading
new data, the computed data is double buffered. Because of the high
data throughput needed this DSP algorithm has been implemented in an FPGA.\\
The ADC is an LTC2274 and has a single link LVDS as output with 8/10B line
coding. For synchronization the ADC sends the comma value K28.5
\cite{ltc2274}. Standard
SATA cabling has been chosen to connect the FPGA to the ADC with one pair
for clock from the FPGA and the other for data to the FPGA. To prevent the
need for a separate reset line, a small circuit asserts the SYNC pin of the
ADC in case of a clock pause. The ADC features an additional scrambling
circuit to minimise the noise caused by the digital interface.\\
The internal buffers were designed so that the FPGA is nearly fully utilized
which resulted in a buffer depth of \SI{48}{KiB}. Since such large FFT sizes
would fill the whole FPGA, overlap add has been used for the convolution with
possible FFT sizes ranging from 8 to 4096.\\
In order to read or write to the different memories these are mapped into the
address space of the integrated processor. The control pins are connected to
memory mapped registers. Processor and the rest of design work on different
clock domains. Because of that the control pins have synchronization circuits
and the memories can switch to the CPU clock domain. Since this clashes with
the need for continuous output, the active output buffer can only be read. If
one wants to send data to the output the inactive output buffer has to be
filled, followed by switching the output buffers.\\
To convert the signal back to analog form a R\&S SMBV100A is used. In order to
communicate the digital data to the SMBV the LVDS interface for
\emph{DIGITAL IQ IN/OUT} has been emulated.\\
The overall FPGA design can be seen in \Cref{fig:overallDesign} and is 
explained in more detail in \Cref{sec:hardware}.\\
For the rest of the document the following formating is used:
\begin{itemize}
    \item \signal{signal}
    \item \module{module}
    \item \clk{}
\end{itemize}
\begin{figure*}[p]
    \centering
    \begin{pspicture}(0,0)(15,20)
        \SpecialCoor
        \rput[tl](13.5,20){\psframebox{\shortstack[l]{%
            \legendline{blue}{1pt} data\\
            \legendline{red}{1pt} ctrl\\
            \legendline{green}{1pt} memory bus\\
            \legendline{magenta}{1pt} external\\
            \legendline{yellow}{4pt} sample\_clk\\
            \legendline{magenta}{4pt} core\_clk\\
            \legendline{cyan}{4pt} cpu\_clk}}
        }

        \pspolygon*[linecolor=yellow,opacity=0.4,linearc=0.2](2.7,18.9)(13.1,18.9)(13.1,13.4)(2.7,13.4)
        \pspolygon*[linecolor=yellow,opacity=0.4,linearc=0.2](2.7,3.6)(11.3,3.6)(11.3,0.3)(2.7,0.3)
        \pspolygon*[linecolor=magenta,opacity=0.4,linearc=0.2](2.7,13.4)(11.4,13.4)(11.4,3.6)(2.7,3.6)
        \pspolygon*[linecolor=cyan,opacity=0.4,linearc=0.1](0.15,15.05)(0.85,15.05)(0.85,7.75)(0.15,7.75)

        \rput[tr](13.3,19.9){top}
        \psframe(0,0)(13.4,20)
        \rput(1.7,0.2){%
            \rput[tr](11.4,19.1){main}
            \psframe(0,0)(11.5,19.2)
            \rput(1.1,13.3){%
                \psframe(0,0)(10.2,5.3)
                \rput[tr](10,5.2){inbuf}
                \pnode(0,0.2){inbufCtrl}
                \pnode(0,4.15){inbufDataIn}
                \pnode(0,2.85){inbufDataOut}
                \pnode(3.9,2){inbufDataMux}
                \pnode(1.9,1.4){averageMemCtrl}
                \rput(0,1.4){%
                    \rput[tr](3.4,3.3){average\_mem}
                    \psframe(0.2,0)(3.5,3.4)
                    \rput(0.6,0.4){%
                        \rput(1.7,1.7){\rnode{inMem}{\psframebox[fillstyle=solid]{mem}}}
                        \rput[t](2,1){\circlenode[fillstyle=solid]{inAdd}{$+$}}
                        \pnode(! \psGetNodeCenter{inAdd} 2.5 inAdd.y 0.25 add){averageAddLoop}
                        \pnode(! \psGetNodeCenter{inAdd} 2.5 inAdd.y 0.25 sub){averageAddIn}
                        \pnode(1,0.5){averageMuxOut}
                        \pnode(2.5,0.2){averageDataSplit}
                        \pnode(! \psGetNodeCenter{inAdd} 1.2 inAdd.y){averageMuxInAdd}
                        \pnode(1.2,0.2){averageMuxInData}
                        \ncline[linecolor=blue]{inAdd}{averageAddIn}
                        \ncline[linecolor=blue]{inAdd}{averageMuxInAdd}
                        \ncline[linecolor=green]{inAdd}{averageAddLoop}
                        \ncangle[linecolor=green, angleA=90, angleB=-90, offsetB=-1pt]{averageAddLoop}{inMem}
                        \ncloop[linecolor=green, armA=0.2, angleA=90, offsetA=1pt, angleB=180, loopsize=-1]{inMem}{averageMuxOut}
                        \ncline[linecolor=blue]{averageAddIn}{averageDataSplit}
                        \ncline[linecolor=blue]{averageDataSplit}{averageMuxInData}
                        \psdot[linecolor=blue](averageDataSplit)
                        \pnode(0.1,1.05){inMuxOut}
                        \pnode(0.1,2.35){inMuxIn}
                        \ncangle[linecolor=green, angleB=-90, offsetB=1pt, armB=0]{inMuxOut}{inMem}
                        \ncangle[linecolor=green, angleB=90, offsetB=1pt, armB=0]{inMuxIn}{inMem}
                        \ncline[linecolor=green]{inMuxOut}{inbufDataOut}
                        \ncline[linecolor=green]{inMuxIn}{inbufDataIn}
                        \rput(1,0){\pspolygon[fillcolor=white,fillstyle=solid](0,0.15)(0.2,0)(0.2,1)(0,0.85)}
                        \rput(0,0.7){\pspolygon[fillcolor=white,fillstyle=solid](0,0.15)(0.2,0)(0.2,0.7)(0,0.55)}
                        \rput{180}(0.2,2.7){\pspolygon[fillcolor=white,fillstyle=solid](0,0.15)(0.2,0)(0.2,0.7)(0,0.55)}
                    }
                }
                \rput(4.2,2){%
                    \psframe(0,-0.6)(5.8,0.9)
                    \rput[tr](5.7,0.8){receiver}
                    \multido{\i=2+-1,\n=0.1+-0.1}{3}{%
                        \pnode(!\n\space 3.5 add 5){GTXExt\i}
                        \rput(\n,\n){%
                            {
                                \psset{fillstyle=solid}
                                \rput[l](0.3,0){\rnode{descramble\i}{\psframebox{descramble}}}
                                \rput(3.5,0){\rnode{GTX\i}{\psframebox{GTX}}}
                                \rput(5,0){\rnode{align\i}{\psframebox{align}}}
                            }
                            \pnode(!\n\space neg -0.2 add 0){inbufDataMUX\i}
                            \ncline[linecolor=blue]{GTX\i}{descramble\i}
                            \ncline[linecolor=blue]{descramble\i}{inbufDataMUX\i}
                            \psset{linecolor=red}
                            \ncline{align\i}{GTX\i}
                            \ncangle[angleA=-90, armB=0]{align\i}{inbufCtrl}
                            \ncangle[angleA=-90, armB=0]{GTX\i}{inbufCtrl}
                            \ncangle[angleA=-90, armB=0]{descramble\i}{inbufCtrl}
                        }
                        \ncline[linecolor=magenta]{GTX\i}{GTXExt\i}
                    }
                }
                {
                    \psset{fillstyle=solid}
                    \rput[l](2.1,0.7){\rnode{wallclk}{\psframebox{wallclk}}}
                    \rput[r](1.6,0.7){\rnode{trigger}{\psframebox{trigger}}}
                }
                \ncline[linecolor=blue]{inbufDataMux}{averageDataSplit}
                {
                    \psset{linecolor=red}
                    \ncangle[angleA=-90, angleB=180, armB=0, offsetA=2pt]{averageMemCtrl}{wallclk}
                    \ncangle[angleA=-90, armB=0, offsetA=-2pt]{averageMemCtrl}{trigger}
                    \ncangle[angleA=-90, armB=0]{averageMemCtrl}{inbufCtrl}
                    \ncangle[angleA=-90, armB=0]{trigger}{inbufCtrl}
                    \ncangle[angleA=-90, armB=0]{wallclk}{inbufCtrl}
                    \ncangle[angleA=-90, armB=0]{inbufDataMux}{inbufCtrl}
                }
                \rput(3.8,1.65){\pspolygon[fillcolor=white,fillstyle=solid](0,0.15)(0.2,0)(0.2,0.7)(0,0.55)}
            }
            \rput(1.1,3.5){%
                \rput[tr](8.4,9.5){core}
                \psframe(0,0)(8.5,9.6)
                \rput(2,0.2){%
                    \rput[tr](6.2,8.8){overlap\_add}
                    \psframe(0,0)(6.3,8.9)
                    \rput(3,3.2){%
                        \rput[tr](3,5){fftncmul}
                        \psframe(0,0)(3.1,5.1)
                        \rput(0.2,3){%
                            \rput[tr](2.6,1.4){wave}
                            \psframe(0,-0.7)(2.7,1.5)
                            \rput(0.5,0){\circlenode[fillstyle=solid]{iqMulQ}{$\times$}}
                            \rput(2.2,0){\circlenode[fillstyle=solid]{iqMulI}{$\times$}}
                            \pnode(! \psGetNodeCenter{iqMulQ} iqMulQ.x 0.25 sub iqMulQ.y 0.5 add){iqMulQA}
                            \dotnode[linecolor=green](! \psGetNodeCenter{iqMulQ} iqMulQ.x 0.25 sub 1){iqMulInSplit}
                            \pnode(! \psGetNodeCenter{iqMulQ} iqMulQ.x 0.25 add iqMulQ.y 0.5 add){iqMulQB}
                            \pnode(! \psGetNodeCenter{iqMulI} iqMulI.x 0.25 sub iqMulI.y 0.5 add){iqMulIA}
                            \pnode(! \psGetNodeCenter{iqMulI} iqMulI.x 0.25 add iqMulI.y 0.5 add){iqMulIB}
                            \pnode(! \psGetNodeCenter{iqMulI} 1.35 iqMulI.y 0.5 add){iq}
                            \pnode(1.35,-0.5){iqMulOutSplit}
                            \ncline[linecolor=blue]{iq}{iqMulIA}
                            \ncline[linecolor=blue]{iqMulIA}{iqMulI}
                            \ncline[linecolor=blue]{iq}{iqMulQB}
                            \ncline[linecolor=blue]{iqMulQB}{iqMulQ}
                            \ncline[linecolor=green]{iqMulIB}{iqMulI}
                            \ncline[linecolor=green]{iqMulQA}{iqMulQ}
                            \ncline[linecolor=green]{iqMulQA}{iqMulInSplit}
                            \ncangle[linecolor=green, angleB=90]{iqMulInSplit}{iqMulIB}
                            \ncangle[linecolor=blue, angleA=-90, angleB=180]{iqMulQ}{iqMulOutSplit}
                            \ncangle[linecolor=blue, angleA=-90]{iqMulI}{iqMulOutSplit}
                            \rput(! \psGetNodeCenter{iqMulI} 1 iqMulI.y 0.15 add){%
                                \psframe[fillstyle=solid](0,0)(0.7,0.7)
                                \psline(0.01,0.01)(.69,.69)
                                \rput(0.21,0.525){\parametricplot[linewidth=.7pt, plotpoints=100]{-1}{1}{0.175 t mul t 180 mul sin -0.0875 mul}}
                                \rput(0.49,0.175){\parametricplot[linewidth=.7pt, plotpoints=100]{-1}{1}{0.175 t mul t 180 mul cos -0.0875 mul}}
                            }
                        }
                        \rput(1,1){\circlenode[fillstyle=solid]{fftncmulMul}{$\times$}}
                        \pnode(! \psGetNodeCenter{fftncmulMul} fftncmulMul.x 0.25 sub fftncmulMul.y 0.5 add){fftncmulMulA}
                        \pnode(! \psGetNodeCenter{fftncmulMul} fftncmulMul.x 0.25 add fftncmulMul.y 0.5 add){fftncmulMulB}
                        \ncline[linecolor=blue]{fftncmulMul}{fftncmulMulA}
                        \ncline[linecolor=green]{fftncmulMul}{fftncmulMulB}
                        \pnode(1.05,0){fftncmulCtrl}
                    }
                    \rput(3,0.2){%
                        \rput[tr](2,2.5){ifftnadd}
                        \psframe(0,0)(2.1,2.6)
                        \rput(1,1){\circlenode[fillstyle=solid]{ifftnaddAdd}{$+$}}
                        \pnode(! \psGetNodeCenter{ifftnaddAdd} ifftnaddAdd.x 0.25 sub ifftnaddAdd.y 0.5 add){ifftnaddAddA}
                        \pnode(! \psGetNodeCenter{ifftnaddAdd} ifftnaddAdd.x 0.25 add ifftnaddAdd.y 0.5 add){ifftnaddAddB}
                        \ncline[linecolor=blue]{ifftnaddAdd}{ifftnaddAddA}
                        \ncline[linecolor=green]{ifftnaddAdd}{ifftnaddAddB}
                        \pnode(1.05,2.6){ifftnaddCtrl}
                    }
                    \rput(2.4,3){\rnode{fft}{\psframebox[fillstyle=solid]{fft}}}
                    \rput[l](0.2,2.5){\rnode{scratch}{\psframebox[fillstyle=solid]{scratch}}}
                    \pnode(! \psGetNodeCenter{ifftnaddAdd} 3.2 ifftnaddAdd.y 0.5 0.2 add add){fftOutSplit}
                    \psdot[linecolor=blue](fftOutSplit)
                    \ncangle[linecolor=blue, angleA=-90, angleB=180, armB=0.2]{fft}{fftOutSplit}
                    \ncangle[linecolor=blue, angleA=-90, angleB=90, armB=0.2]{fftOutSplit}{fftncmulMulA}
                    \ncangle[linecolor=blue, angleA=-90, angleB=90, armB=0.2]{fftOutSplit}{ifftnaddAddA}
                    \pnode(2.9,3){fftCtrlSplit}
                    \pnode(2.4,4.1){fftMux}
                    \ncangle[linecolor=red, angleB=-90, armB=0]{fftCtrlSplit}{fftncmulCtrl}
                    \ncangle[linecolor=red, angleB=90, armB=0]{fftCtrlSplit}{ifftnaddCtrl}
                    \ncangle[linecolor=red, angleA=90]{fftCtrlSplit}{fftMux}
                    \ncline[linecolor=red]{fft}{fftCtrlSplit}
                    \ncangle[linecolor=green, angleA=90, angleB=-90]{scratch}{fftncmulMul}
                    \ncangle[linecolor=blue, angleA=-90, angleB=90, offsetB=0.15, armB=1.2]{iqMulOutSplit}{fftMux}
                    \ncline[linecolor=blue]{fftMux}{fft}
                    \pnode(1.85,2.05){scratchSplit}
                    \ncangle[linecolor=green, angleA=-90, angleB=180]{scratch}{scratchSplit}
                    \ncangle[linecolor=green, angleA=90, angleB=90, offsetB=-0.15]{scratchSplit}{fftMux}
                    \psdot[linecolor=green](scratchSplit)
                    \ncangle[linecolor=green, angleB=90]{scratchSplit}{ifftnaddAddB}
                    \rput{90}(2.75,4){\pspolygon[fillcolor=white,fillstyle=solid](0,0.15)(0.2,0)(0.2,0.7)(0,0.55)}
                }
                \rput(1,5.7){\rnode{H}{\psframebox[fillstyle=solid]{H}}}
                \ncangle[linecolor=green, angleA=-90, angleB=90, offsetA=1pt]{H}{fftncmulMulB}
                \pnode(0,8){coreCtrl}
                \pnode(2,8){overlapAddCtrl}
                \pnode(0,7.4){coreIn}
                \pnode(0,6.2){coreHIn}
                \pnode(0,5.25){coreHOut}
                \pnode(0,0.6){coreOut}
                \ncline[linecolor=red]{coreCtrl}{overlapAddCtrl}
                \ncline[linecolor=green]{coreIn}{iqMulInSplit}
                \ncangle[linecolor=green, angleB=90, armB=0]{coreHIn}{H}
                \ncangle[linecolor=green, angleB=-90, armB=0, offsetB=1pt]{coreHOut}{H}
                \ncangle[linecolor=green, angleB=-90, armB=0]{coreOut}{ifftnaddAdd}
            }
            \rput(1.1,0.2){%
                \psframe(0,0)(8.4,3.1)
                \rput[tr](8.3,3.0){outbuf}
                \rput(1,2){\rnode{outMem0}{\psframebox[fillstyle=solid]{mem\_0}}}
                \rput(3,2){\rnode{outMem1}{\psframebox[fillstyle=solid]{mem\_1}}}
                \pnode(0,0.2){outCtrl}
                \pnode(0,0.4){outDataOut}
                \pnode(0,2.5){outDataIn}
                \pnode(1,2.5){outDataSplit}
                \pnode(2,0.8){outMemMuxOut}
                \pnode(4.2,1.45){outMemMuxData}
                \ncangle[linecolor=green, angleA=-90, angleB=90, offsetB=-0.1, offsetA=-0.1]{outMem0}{outMemMuxOut}
                \ncangle[linecolor=green, angleA=-90, angleB=90, offsetB=0.1, offsetA=-0.1]{outMem1}{outMemMuxOut}
                \ncangle[linecolor=green, angleA=-90, angleB=180, offsetB=-0.1, offsetA=0.1]{outMem0}{outMemMuxData}
                \ncangle[linecolor=green, angleA=-90, angleB=180, offsetB=0.1, offsetA=0.1]{outMem1}{outMemMuxData}
                \rput(5.2,1.45){\circlenode[fillstyle=solid]{outMul}{$\times$}}
                \rput[l](6,1.45){\rnode{transmitter}{\psframebox[fillstyle=solid]{transmitter}}}
                \ncline[linecolor=blue]{outMemMuxData}{outMul}
                \ncangle[linecolor=red, angleB=-90, armA=0, armB=0]{outMemMuxOut}{outMemMuxData} 
                \ncangle[linecolor=red, angleB=-90, armA=0, armB=0]{outCtrl}{outMemMuxData}
                \ncangle[linecolor=red, angleB=-90, armA=0, armB=0]{outCtrl}{outMul}
                \ncangle[linecolor=red, angleB=-90, armA=0, armB=0]{outCtrl}{transmitter}
                \ncline[linecolor=green]{outDataIn}{outDataSplit}
                \ncline[linecolor=green]{outDataSplit}{outMem0}
                \psdot[linecolor=green](outDataSplit)
                \ncangle[linecolor=green, angleB=90, armA=0, armB=0]{outDataSplit}{outMem1}
                \ncangle[linecolor=green, angleB=-90, armA=0, armB=0]{outDataOut}{outMemMuxOut}
                \rput{90}(2.35,0.7){\pspolygon[fillcolor=white,fillstyle=solid](0,0.15)(0.2,0)(0.2,0.7)(0,0.55)}
                \rput{180}(4.3,1.8){\pspolygon[fillcolor=white,fillstyle=solid](0,0.15)(0.2,0)(0.2,0.7)(0,0.55)}
                \ncline[linecolor=blue]{outMul}{transmitter}
            }
            \pnode(0.7,16.15){mainMuxInInSplit}
            \psdot[linecolor=green](mainMuxInInSplit)
            \ncline[linecolor=green]{mainMuxInInSplit}{inbufDataOut}
            \ncangle[linecolor=green, angleA=90, angleB=180]{mainMuxInInSplit}{coreIn}
            \pnode(0.7,4.1){outbufMuxInCoreSplit}
            \psdot[linecolor=green](outbufMuxInCoreSplit)
            \pnode(0.4,3.1){outbufMuxInExt}
            \pnode(0.7,3.1){outbufMuxInCore}
            \pnode(0.55,2.9){outbufMuxOut}
            \ncangle[linecolor=green, angleA=90, angleB=180]{outbufMuxOut}{outDataIn}
            \ncline[linecolor=green]{outbufMuxInCore}{outbufMuxInCoreSplit}
            \ncline[linecolor=green]{outbufMuxInCoreSplit}{coreOut}
            \pnode(0,17.45){mainInbufIn}
            \pnode(0,16.15){mainInbufOut}
            \pnode(0,13.5){mainInbufCtrl}
            \pnode(0,11.5){mainCoreCtrl}
            \pnode(0,9.7){mainCoreHIn}
            \pnode(0,8.75){mainCoreHOut}
            \pnode(0,4.1){mainCoreOut}
            \pnode(0,3.3){mainOutbufIn}
            \pnode(0,0.6){mainOutbufOut}
            \pnode(0,0.4){mainOutbufCtrl}
            \ncline[linecolor=green]{mainInbufIn}{inbufDataIn}
            \ncline[linecolor=green]{mainInbufOut}{mainMuxInInSplit}
            \ncline[linecolor=red]{mainInbufCtrl}{inbufCtrl}
            \ncline[linecolor=red]{mainCoreCtrl}{coreCtrl}
            \ncline[linecolor=green]{mainCoreHIn}{coreHIn}
            \ncline[linecolor=green]{mainCoreHOut}{coreHOut}
            \ncline[linecolor=green]{mainCoreOut}{outbufMuxInCoreSplit}
            \ncangle[linecolor=green, angleB=90, armB=0]{mainOutbufIn}{outbufMuxInExt}
            \ncline[linecolor=green]{mainOutbufOut}{outDataOut}
            \ncline[linecolor=red]{mainOutbufCtrl}{outCtrl}
            \rput{90}(0.9,2.9){\pspolygon[fillcolor=white,fillstyle=solid](0,0.15)(0.2,0)(0.2,0.7)(0,0.55)}
        }
        \pnode(1.3,8.75){memMuxOutbuf}
        \pnode(1.3,8.85){memMuxCore}
        \pnode(1.3,8.95){memMuxCoreH}
        \pnode(1.3,9.05){memMuxInbuf}
        \ncangles[linecolor=green, angleA=180, armA=0.2, armB=0]{mainOutbufOut}{memMuxOutbuf}
        \ncangles[linecolor=green, angleA=180, armA=0.1, armB=0]{mainCoreOut}{memMuxCore}
        \ncangles[linecolor=green, angleA=180, armA=0.1, armB=0]{mainInbufOut}{memMuxInbuf}
        \ncline[linecolor=green]{mainCoreHOut}{memMuxCoreH}
        \pnode(1.1,8.9){memMuxOut}
        \rput[c]{90}(0.5,13.7){\rnode{procRegister}{\psframebox[fillstyle=solid]{proc\_register}}}
        \rput[c]{90}(0.5,8.9){\rnode{procMem}{\psframebox[fillstyle=solid]{proc\_mem}}}
        \rput[c]{90}(0.5,11.2){\rnode{cpu}{\psframebox[fillstyle=solid]{cpu}}}
        \ncline[linecolor=green, offsetA=0.05, offsetB=0.05]{memMuxOut}{procMem}
        \rput(1.1,8.55){\pspolygon[fillcolor=white,fillstyle=solid](0,0.15)(0.2,0)(0.2,0.7)(0,0.55)}
        \pnode(1.0,8.95){memBusSplit}
        \psdot[linecolor=green](memBusSplit)
        \ncline[linecolor=green, offsetB=-0.02]{memBusSplit}{procMem}
        \ncangle[linecolor=green, angleB=-90]{mainOutbufIn}{memBusSplit}
        \pnode(0.9,13.7){ctrlBusSplit}
        \psdot[linecolor=red](ctrlBusSplit)
        \pnode(0.9,11.7){ctrlBusSplitCore}
        \psdot[linecolor=red](ctrlBusSplitCore)
        \pnode(1.0,9.9){memBusSplitCoreH}
        \psdot[linecolor=green](memBusSplitCoreH)
        \ncangle[linecolor=green, angleB=90]{mainInbufIn}{memBusSplitCoreH}
        \ncline[linecolor=green]{memBusSplitCoreH}{memBusSplit}
        \ncline[linecolor=green]{mainCoreHIn}{memBusSplitCoreH}
        \ncangle[linecolor=red, angleB=90]{mainOutbufCtrl}{ctrlBusSplitCore}
        \ncline[linecolor=red]{mainCoreCtrl}{ctrlBusSplitCore}
        \ncline[linecolor=red]{mainInbufCtrl}{ctrlBusSplit}
        \ncline[linecolor=red]{ctrlBusSplitCore}{ctrlBusSplit}
        \ncline[linecolor=red]{procRegister}{ctrlBusSplit}
        \ncline[linecolor=green]{procRegister}{cpu}
        \ncline[linecolor=green]{procMem}{cpu}

        \pnode(-0.5,11.2){cpuExt}
        \ncline[linecolor=magenta]{cpu}{cpuExt}
        \pnode(13.9,1.85){transmitterExt}
        \ncline[linecolor=magenta]{transmitter}{transmitterExt}
    \end{pspicture}
    \caption{Overall Functional Design with the VHDL module names.}
    \label{fig:overallDesign}
\end{figure*}

\section{Hardware}
\label{sec:hardware}
This project uses ISE 10.1 to implement the Hardware on a Virtex 5 (XC5VFX70T).
The whole project is structured into the modules \module{inbuf}
(\Cref{sec:inbuf}), \module{core} (\Cref{sec:core}) and \module{outbuf}
(\Cref{sec:outbuf}). These modules are split into several clock domains as can
be seen in \Cref{fig:overallDesign}:
\begin{description}
    \item[\clk{sample\_clock}:] \hfill \\
        Clock recovered from LVDS (GTX \cite[p. 179ff]{gtx}). \SI{100}{MHz}.
    \item[\clk{core\_clock}:] \hfill \\
        This clock is only used for the DSP core, to be able
        to speed up the calculations. Due to synthesis constraints it is
        currently the same as \clk{sample\_clock}. \SI{100}{MHz}.
    \item[\clk{cpu\_clock}] \hfill \\
        Internal CPU bus clock. \SI{100}{Mhz}; not aligned to
        \clk{sample\_clock}.
\end{description}
Since \clk{sample\_clock} and \clk{cpu\_clock} are not related, all affected memory
clocks are sourced from clock muxes. Therefore it is possible to do only
one of the following activities at a time:
\begin{itemize}
    \item Capture data from ADC.
    \item Convolute.
    \item Read/Write data with the CPU.
\end{itemize}
This is guarded by \signal{core\_busy} and \signal{mem\_req} (see
\Cref{sec:register}, \Cref{reg5}).\\
Xilinx wizards and inferring from VHDL have been avoided for the memories,
because those achieved suboptimal results, which could be cause by the
high FPGA utilization.

\subsection{Module \module{inbuf}}
\label{sec:inbuf}
This module consists of the following submodules:
\begin{description}
    \item[\module{align}:] \hfill \\
        Simple state machine for generating the clock pauses to sync with
        the ADC. The timings can be configured with generics.
    \item[\module{GTX}:] \hfill \\
        GTX transceiver \cite{gtx} configured by wizard\cite{gtx_wizard}. This component has to be
        replaced in case the FPGA changes. Because of the abundant number of
        signals and generics instantiating this module by hand is not advised.
        Runtime configuration pins are exposed via \Cref{reg0}.
    \item[\module{descramble}:] \hfill \\
        Descrambler modelled after \cite[p. 28]{ltc2274}.
    \item[\module{trigger}:] \hfill \\
        Trigger for data capture. Can use either external trigger (Signal
        \signal{inbuf\_trigger} pin~AN33) or internal trigger which triggers
        on position 0 of a frame. If no frame has been captured yet, the
        internal trigger can be fired with \signal{trig\_int} (see \Cref{reg1}).
    \item[\module{wallclk}:] \hfill \\
        Generates frame position, frame trigger and start index for \module{wave}
        (I/Q demodulation).
    \item[\module{average\_mem}:] \hfill \\
        Averaging memory, that can average over 1, 2, 4, 8 samples. Averaging
        is achieved by adding the samples from consecutive runs and shifting
        the values on memory read.
\end{description}
Since there are three GTX transceivers \cite{gtx} easily accessible on the ML507 board
(two SATA connectors and one with four SMA headers; see \cite{ml507}), all
three have been instantiated. A multiplexer allows changing the input during
runtime (see \Cref{reg0}).
\subsection{Module \module{core}}
\label{sec:core}
\module{core} is mainly a wrapper for \module{overlap\_add} which does all
the calculations. For the (i)FFT the Xilinx IP \cite{xilinx_fft} has been
used. Since integer values are used during every step of the calculation the
bit width increases, scaling with convergent rounding is used. To achieve a
faster computation the pipelined version was chosen. \module{wave} implements
the I/Q demodulation which is realized with a ROM consisting of the $\sin$
and $\cos$ values for 10 cycles (\SI{30}{MHz} sampled at \SI{100}{MHz}) and
multipliers.\\
\begin{figure}[t]
    \centering
    \begin{pspicture}(0,0)(7.5,6.9)
        \psset{braceWidth=.5pt,braceWidthInner=4pt,braceWidthOuter=4pt,nodesepB=-2pt,rot=-90}
        \psbrace[ref=B](3,5.1)(1,5.1){$L$}
        \psbrace[ref=B](3.5,5.7)(1,5.7){$nfft$}
        \psbrace[ref=B](5.5,6.3)(1,6.3){$n$}
        \psset{hatchsep=2pt,dotsep=1pt}
        \pspolygon(1,4.5)(5.5,4.5)(5.5,5)(1,5)
        \psline(3,4.5)(3,5)
        \psline(5,4.5)(5,5)
        \psline[linestyle=dashed](5.5,4.5)(7,4.5)(7,5)(5.5,5)

        \psline(3,3)(1,3)(1,3.5)(3,3.5)
        \psline[fillstyle=crosshatch](3,3)(3.5,3)(3.5,3.5)(3,3.5)

        \psline(5,2)(3,2)(3,2.5)(5,2.5)
        \psline[fillstyle=crosshatch](5,2)(5.5,2)(5.5,2.5)(5,2.5)

        \psline(7,1)(5,1)(5,1.5)(7,1.5)
        \psline[linestyle=dotted](7,1)(7.2,1)
        \psline[linestyle=dotted](7,1.5)(7.2,1.5)
        {
            \psset{linecolor=red,hatchcolor=red}
            \psline[linestyle=dotted](0.8,1)(1,1)
            \psline[linestyle=dotted](0.8,1.5)(1,1.5)
            \psline[fillstyle=crosshatch](1,1)(1.5,1)(1.5,1.5)(1,1.5)
        }

        \pspolygon(1,0)(5.5,0)(5.5,0.5)(1,0.5)

        \psset{dotsep=1pt,linestyle=dotted,linecolor=gray}
        \psline(1,3.5)(1,4.5)
        \psline(3.5,3.5)(3,4.5)

        \psline(1,0.5)(1,1)
        \psline(1,1.5)(1,3)

        \psline(1.5,0.5)(1.5,1)
        \psline(1.5,1.5)(1.5,3)

        \psline(3,0.5)(3,2)
        \psline(3,2.5)(3,3)

        \psline(3.5,0.5)(3.5,2)
        \psline(3.5,2.5)(3.5,3)

        \psline(5,0.5)(5,1)
        \psline(5,1.5)(5,2)

        \psline(5.5,0.5)(5.5,1)
        \psline(5.5,1.5)(5.5,2)

        \psline(5.5,2.5)(5.5,3.5)(5,4.5)

        \psline(7.25,4)(7,4.5)

        \rput(6.25,4.75){$000000$}

        \rput(3.25,2.75){$+$}
        \rput(5.25,1.75){$+$}
        \rput(1.25,2.25){$+$}

        \rput(0.25,4.75){$x[n]$}
        \rput(0.25,0.25){$y[n]$}
        \rput(0.25,3.25){$y_0[n]$}
        \rput(0.25,2.25){$y_1[n]$}
        \rput(0.25,1.25){$y_2[n]$}

    \end{pspicture}
    \caption{Overlap add algorithm. The red part is only needed for cirular
        convolution. $y_n[n] = \mathcal{F}^{-1}\left(\mathcal{F}\left(
        x[L\cdot n:(L+1)\cdot n], nfft \right) \cdot H[n] \right)$
        where $\mathcal{F}\left(x, n \right)$ denotes the zero extended FFT of $x$.}
    \label{fig:olapadd}
\end{figure}
Overlap add as described in \Cref{fig:olapadd} can be used to calculate the
linear or circular convolution. This algorithm needs the following steps:
\begin{enumerate}
    \item Zero extend the input signal $x[n]$ to a multiple of $L$.
    \item Take an $L$ sized block out of $x[n]$.
    \item Zero extend the block to a length of $nfft$.
    \item Fourier transform the block.
    \item Multiply the result with $H[n]$.
    \item Transform the result back.
    \item $y[n]$ is Steps 2-6 done with every block. The overlapping
        parts need to be added together.
    \item For cirular convolution the overlapping part of the last block has
        to be added to the beginning of $y[n]$
\end{enumerate}
In hardware the zero extending is achived by a multiplexer zeroing the inputs.
Another difference is that the result as calculated by the used FFT IP
\cite{xilinx_fft} is in bit reversed order. This does not matter for the iFFT,
because the result gets written to memory and there the order is not important.
After the FFT however the result has to be sorted so it can be used again as 
input for the FFT IP \cite{xilinx_fft}. For this the memory \module{scratch}
is used. Scratch is also filled during the iFFT with the current overlapping
block from the result, for easier calculation of the addition. The state machine
controlling the whole process is split into the two modules \module{fftncmul} and
\module{ifftnadd}. With this split it is possible to run both at the same time,
resulting in a higher trough put. \Cref{fig:olapadd_flow} describes how this
works.
\begin{figure}[bh]
    \centering
    \begin{pspicture}(9.2,6.8)
        \rput[bl](-0.2,0){
        {
            \psset{style=RoundCorners,style=Dash}
            \fnode[linecolor=red,framesize=5 1.3](4.6,5.75){fft}
            \nput{90}{fft}{\textcolor{red}{\module{fftncmul}}}
            \pspolygon[linecolor=purple](7.4,6.3)(9.2,6.3)(9.2,0.5)(3.8,0.5)(3.8,4.9)(7.4,4.9)
            \rput(6.5,0.25){\textcolor{purple}{\module{ifftnadd}}}
        }
        \psmatrix[colsep=.5cm,rowsep=.5cm,mnode=r]
        [mnode=oval] start & \psframebox{FFT} & & \psframebox{\shortstack{$\times H[n]$ $\rightarrow$\\ \module{scratch}}} & \psframebox{iFFT} \\
        & [mnode=dia] last & [mnode=p] & \psframebox{\shortstack{$y[n] \rightarrow$\\\module{scratch}}} & [mnode=dia] first \\
        & & [mnode=p] & \psframebox{\shortstack{$0 \rightarrow$\\\module{scratch}}} & \\
        & [mnode=dia] last & & \psframebox{\shortstack{$+$\module{scratch}\\$\rightarrow y[n]$}} & [mnode=r] \\
        & [mnode=oval] finished & & &
        \psset{arrows=->}
        \ncline{1,1}{1,2}
        \ncline{1,2}{1,4}\naput{wait}\nbput{FFT}
        \ncline{1,4}{1,5}
        \ncline{1,5}{2,5}
        \ncangle[angleA=-90]{2,5}{3,4}\naput[npos=0]{Yes}
        \ncline{2,5}{2,4}\nbput[npos=0]{No}
        \ncline[arrows=-]{2,4}{2,3}
        \ncline[arrows=-]{3,4}{3,3}
        \ncangle[angleA=90]{3,3}{2,2}
        \ncline{2,2}{1,2}\nbput[npos=0]{No}
        \ncangle[arrows=-,armB=0.8,angleA=-90,angleB=90]{3,3}{4,5}
        \ncline{4,5}{4,4}\nbput{wait}\naput{iFFT}
        \ncline{4,4}{4,2}
        \ncline{4,2}{5,2}\nbput[npos=0]{Yes}
        \endpsmatrix}
    \end{pspicture}
    \caption{Overlap add control/data flow.}
    \label{fig:olapadd_flow}
\end{figure}
The module \module{core} has the following control signals:
\begin{description}
    \item[\signal{start}] \hfill \\
        Starts the convolution. All the other signals are sampled on
        \signal{start} and can change during the rest of the time.
    \item[\signal{n}] \hfill \\
        Size of the fft in $\log_2\left( nfft \right)$.
    \item[\signal{scale\_sch}:] \hfill \\
        Scaling schedule for the FFT. See \cite{xilinx_fft}.
    \item[\signal{scale\_schi}:] \hfill \\
        Scaling schedule for the iFFT. See \cite{xilinx_fft}.
    \item[\signal{scale\_cmul}:] \hfill \\
        Scaling applied after the complex multiplication.
    \item[\signal{L}:] \hfill \\
        $L$
    \item[\signal{depth}:] \hfill \\
        $n$
    \item[\signal{iq}:] \hfill \\
        Switches I/Q-demodulation on/off.
    \item[\signal{circular}:] \hfill \\
        Selects between circular and linear convolution.
    \item[\signal{ov\_*}:] \hfill \\
        After a complete run these indicate if an overflow happened during
        \begin{itemize}
            \item FFT
            \item iFFT
            \item Complex multiplication
        \end{itemize}
    \item[\signal{busy}:] \hfill \\
        High during run.
    \item[\signal{done}:] \hfill \\
        Pulses after complete run.
    \item[\signal{wave\_index}:] \hfill \\
        Wave index of the first value. Needed for the I/Q-demodulation.
\end{description}

\subsection{Module \module{outbuf}}
\label{sec:outbuf}
\begin{figure*}[b]
    \centering
    \begin{tikztimingtable}
        \clk{clk} & c11{7c}c  \\
        \clk{ckm} & c22{3.5c}c \\
        \clk{ckh} & c77{c}c \\
        \signal{outdata\_long}(0) & x2{14x}{}3{14d}7dd\\
        \signal{outdata\_long}(1) & x3{14x}{}2{14d}7dd \\
        \signal{outdata\_long}(2) & x{}4{14d}{}14d7dd \\
        \signal{outdata\_long}(3) & x14x{}4{14d}{}7dd \\
        \signal{outdata\_short} & [font=\scriptsize] x7d{(0)(6:3)}7d{(0)(2:0) (1)(6)}7d{(1)(5:2)}7d{(1)(1:0) (2)(6:5)}7d{(2)(4:1)}7d{(2)(0) (3)(6:4)}7d{(3)(3:0)}7d{(0)(6:3)}7d{(0)(2:0) (1)(6)}7d{(1)(5:2)}7d{(1)(1:0) (2)(6:5)}{}d \\
        \signal{out\_en} & l49{l}28{h}h \\
    \end{tikztimingtable}
    \caption{LVDS Output generation timing. {\scriptsize (0)(2:0) (1)(6)} in \signal{outdata\_short} means {\ttfamily outdata\_long(0)(2 downto 0) \& outdata\_long(1)(6 downto 6)}.}
    \label{fig:trans}
\end{figure*}
This module consists of the two main parts \module{transmitter} and the two
memory buffers for holding the result. The active buffer can be switched with
a pulse to \signal{toggle\_buf}. Switching gets deferred until the address
counter reaches zero. A successful switch is reported with a pulse to
\signal{toggled}. This module is also able to synchronize the output cycle
to the input cycle with asserting \signal{resync}. The data gets multiplied by
\signal{muli}/\signal{mulq} before transmission. For handling overflows, which
would be reported by \signal{ovfl}, saturation (\signal{sat}) or shift
(\signal{shift}) can be used.\\
For communication with the SMBV the interface desribed by \cite{fsq_b17} has
been implemented in VHDL. To be able to communicate with the R\&S SMBV100A the
pinout mentioned in \cite[p. 9]{fsq_b17} has been used. One undocumented
change has to be made: In order for the SMBV100A to be
able to detect connected Hardware the S\_CLK pin has to be connected to GND.
According to \cite[p. 10]{fsq_b17}, the different signals are assigned to
\signal{e1} (D24 - D47) and \signal{e2} (D0-D23). The triggers and markers are
hardcoded to zero, because the SMBV100A is not able to use those signals from
\emph{DIGITAL I/Q IN/OUT}. Since the data is always valid and enabled, those two
signals are hard coded to one. \cite[p. 10]{fsq_b17} also states that the LVDS
link is similar to the one implemented by a TI DS90CR485. Because of this the module
\module{transmitter} is a clean room VHDL implementation written according to
the specification in \cite{ds90cr485}. Because at the time of the implementation,
the settings of the receiver were unknown, the whole feature set of the
transmitter with every control signal has been implemented. The balance value
of a value is calculated with a pre filled ROM, that has been generated with
the script \emph{balance\_table.py}. Since there are no suitable GTX
transceivers \cite{gtx} available, SelectIO\cite[p. 270ff]{virtex5} is used
for the transmitters. In order to create the LVDS outputs with the same
characteristics, OSERDES \cite[p. 370ff]{virtex5} elements in
DDR mode have been used. This results in the high clock frequencies of
\SI{350}{MHz} (=7 Bit per \SI{100}{MHz} Cycle/2 Bit per Cycle, \clk{ckh}) and
\SI{175}{MHz} (\clk{ckm}). To achieve the timing goals and correct ordering
of the output signals, the timing in \Cref{fig:trans} was implemented and the
last registers and multiplexers in front of the OSERDES
\cite[p. 370ff]{virtex5} were assigned fixed locations in the floor plan
(see \Cref{sec:synthesis}).

\subsection{Module \module{proc\_register}}
\label{sec:register}

The control communication between the processor and hardware is handled by this
module. Since there are several clock domains involved this module also handles
the clock synchronization if needed. This is done with the module \module{flag}
which is a simple two stage synchronizer with two flip flops. Since this likely
causes timing issues during synthesis, this module also sets the needed
attributes:
\begin{description}
    \item[\protect{TIG = TRUE\cite[p. 302]{constraints}:}] \hfill \\
        Ignore timing on this signal.
    \item[\protect{IOB = FALSE\cite[p. 146]{constraints}:}] \hfill \\
        Prevents packing this into an IO block. This is needed,
        because an IO block contains only one flip flop and in order to ensure
        proper synchronization the two flip flops shouldn't have long
        connections in between.
    \item[\protect{ASYNC\_REG = TRUE\cite[p. 87]{constraints}:}] \hfill \\
        This constraint disables propagation of 'X' during timing simulation.
    \item[\protect{SHIFT\_EXTRACT = FALSE\cite[p. 385]{xst}:}] \hfill \\
        This prevents inferring a dedicated shift register.
    \item[\protect{HBLKNM = name\cite[p. 134]{constraints}:}] \hfill \\
        This assigns a hierarchical block name to both flip flops to ensure
        both end up in the same slice.
\end{description}
The mentioned module can only synchronize slow changing single signal logic
values. For
synchronizing a single pulse \module{toggle} has to be used. In order to
synchronize a value consisting of several signals, \module{value} has to
be used. This module prevents the assertion of \signal{fpga2bus\_wrack}
to guarantee the value doesn't change during synchronization.\\
Input and output ports of \module{proc\_register} are sorted by
needed synchronization/clock and the source contains a table which describes
every signal.\\
\module{proc\_register} also generates the interrupt register. This register
is sampled by the user logic in the processor module and generates an
interrupt on the rising edge.\\
\Crefrange{reg0}{intr} contain a list of all the registers and the meaning of
every bit therein.
\subsection{Processor}
In order to be able to communicate the internal PowerPC 440 \cite{ppc} is used.
This block is incorporated into the design by instantiating the module
\module{processor}, which is generated by EDK, in the top level module.
The following settings are needed to be able to run linux:
\begin{itemize}
    \item Enabled cache setup.
    \item One UART. XPS\_UART16550. Use interrupt.
    \item GPIO controllers if needed. Interrupts are not supported by the
        linux driver.
    \item Hard ethernet MAC. Use interrupt.
    \item DDR2 SDRAM.
    \item SysACE\_CompactFlash. Use interrupt.
    \item XPS\_BRAM\_IF\_CNTLR\_1. 8 KB. This needs to be at the highest
        address.
    \item Cache enabled for the memories.
\end{itemize}
Communication with the rest of the design is handled by the IP
\module{proc2fpga}. To
keep the everything in one place and prevent switching between two projects
(ISE and EDK), the this module is kept very basic.
\module{proc2fpga} is created with the \emph{Create or Import Peripheral\ldots}
wizard in the EDK. Settings used are:
\begin{itemize}
    \item Processor Local Bus.
    \item Software reset.
    \item Interrupt control.
    \item User logic software register.
    \item User logic memory space.
    \item Burst and cache-line support. This is needed, so the memories can
        be directly accessed by linux. Data width: 32 Bit. Write buffer depth:
        32.
    \item Use Device ISC. 16 Interrupts, edge detect.
    \item 6 registers.
    \item 4 memory address ranges.
\end{itemize}
In the generated IP, only very basic logic has been added. This logic only
converts between the different bit orderings and exposes all signals, which
were generated by the wizard, to the rest of the design. To be able to route
these signals outside the processor design, these have to be annotated in the
mpd description file with \verb+BUFFER_TYPE = none+. Without this modification
EDK instantiates I/OBUFs for these signals, which will generate errors,
since those signals won't be connected to a pad of the FPGA. After generating
this, the final module is reimported back into the EDK and added to the
design.\\
The exposed signals are listed in \cite{slave_burst}. \cite[p. 14]{slave_burst}
mentions that \signal{IP2Bus\_Error} is only sampled during acknowledge, which
seems to be wrong. Asserting this signal outside of a read or write cycle
causes random \emph{SIGBUS} faults.
\subsection{Synthesis}
\label{sec:synthesis}
\begin{lstlisting}[float,language=ucf,caption={Floor plan example},label=lst:floorplan]
INST "*/transmitter_i/outdata_short6_0" LOC=SLICE_X2Y78;
INST "*/transmitter_i/outdata_short6_1" LOC=SLICE_X2Y78;
INST "*/transmitter_i/mux24_*" LOC=SLICE_X2Y78;
INST "*/transmitter_i/mux25_*" LOC=SLICE_X2Y78;
INST "*/transmitter_i/outdata_short6_2" LOC=SLICE_X3Y78;
INST "*/transmitter_i/outdata_short6_3" LOC=SLICE_X3Y78;
INST "*/transmitter_i/mux26_*" LOC=SLICE_X3Y78;
INST "*/transmitter_i/mux27_*" LOC=SLICE_X3Y78;

#####

AREA_GROUP "inbuf" RANGE=SLICE_X54Y70:SLICE_X67Y89;
AREA_GROUP "inbuf" RANGE=DSP48_X1Y28:DSP48_X1Y35;
AREA_GROUP "inbuf" RANGE=RAMB36_X3Y24:RAMB36_X4Y25, RAMB36_X3Y22:RAMB36_X5Y23,RAMB36_X3Y20:RAMB36_X4Y21, RAMB36_X3Y18:RAMB36_X5Y19, RAMB36_X3Y6:RAMB36_X4Y17;
INST "*/inbuf_inst/*" AREA_GROUP="inbuf";
\end{lstlisting}
ISE 10.1 is not able to generate a working hardware implementation that
meets timing requirements. This is caused by the high block ram utilization
and the high frequency of the LVDS transmitter (\Cref{sec:outbuf}), which is
near the possible maximum frequency of the FPGA. In order to achieve timing
goals floor planning has to be used. Floor planning also helps speeding up
the implementation process.\\
The easiest way to create a floor plan is to use \emph{planAhead}, draw
\emph{Pblocks} and assign primitives to those. One problem with this
approach is, that after this operation every instantiated primitive
is fixed and the floor plan has to be adapted after every change to the
design. This can be circumvented with adjusting the generated ucf file
to use wildcards instead of instance names. An example can be seen in
\Cref{lst:floorplan}.\\
If the processor is used the first column of slices must not be used, because
this area is reserved for the DDR memory interface. The constraints file
generated by EDK prevents logic from being place there, because this interface
is already pre routed. Since this approach has been used, because ISE 10.1 is
not able to route the design. This short coming has been fixed in a later
version.\\
An overview of the floor plan, describing the different areas, can be seen in
\Cref{fig:floorplan}.
\begin{figure}[h]
    \centering
    \begin{pspicture}(-2.5,0)(9.5,14.5)
        \rput[bl](0,0){\includegraphics*[bb=3 2 252 381]{floorplan.ps}}
        \rput(9.5,7.5){\rnode{GTXdesc}{\psframebox{GTX}}}
        \pnode(8.62,5.7){GTX1}
        \pnode(8.62,9.1){GTX2}
        \rput(2,14){\rnode{MEMdesc}{\psframebox{memories}}}
        \pnode(1.07,13.1){MEM1}
        \pnode(2.22,13.1){MEM2}
        \pnode(3.37,13.1){MEM3}
        \rput(5.95,14){\rnode{DSPdesc}{\psframebox{DSP blocks}}}
        \pnode(5.72,13.1){DSP1}
        \pnode(6.19,13.1){DSP2}
        \rput(-1.5,11){\rnode{PPCdesc}{\psframebox{PPC}}}
        \pnode(2.4,7.8){PPC}
        \rput(-1.5,9){\rnode{LOCdesc}{\psframebox{\shortstack{outdata LOC\\constraints}}}}
        \pnode(0.6,7.4){LOC}
        \rput(-1.5,5){\rnode{PADdesc}{\psframebox{\shortstack{outdata pads}}}}
        \pnode(0.2,6.8){PAD}
        \rput(-1.5,7.2){\rnode{AREAdesc}{\psframebox{\shortstack{outdata AREA\\constraints}}}}
        \pnode(0.7,7.2){AREA}
        \psset{arrows=->}
        \ncline{LOCdesc}{LOC}
        \ncline{PADdesc}{PAD}
        \ncline{AREAdesc}{AREA}
        \ncline{PPCdesc}{PPC}
        \ncline{MEMdesc}{MEM1}
        \ncline{MEMdesc}{MEM2}
        \ncline{MEMdesc}{MEM3}
        \ncline{DSPdesc}{DSP1}
        \ncline{DSPdesc}{DSP2}
        \ncline{GTXdesc}{GTX1}
        \ncline{GTXdesc}{GTX2}
    \end{pspicture}
    \caption{Floor plan. Major areas besides \emph{outdata}:
        \emph{outbuf\_mem\_*} and \emph{outbuf} keep outbuf memories close
        together and the related logic close to \emph{outbuf}, \emph{core} to contain
        the FFT IP, \emph{proc\_interface} for keeping the cpu interface
        close to the PPC block, and \emph{inbuf} for placing related logic and
        memories close to the GTX blocks.}
    \label{fig:floorplan}
\end{figure}
\section{Software}
What and why
\subsection{Buildroot}
patch in twisted, zope, smmap\\
make menuconfig\\
config (glibc, powerpc 440 without fpu, software fpu, c++, glibc (uclibc bug with powerpc), python, python-zope-interface, python-twisted, python-smmap, expat!)\\
\verb+undefined reference to `copysignl'+\\
make
\subsection{kernel}
mainline kernel min version\\% TODO
toolchain.sh\\
pmake menuconfig\\
AMC 44x, 46x, 47x\\
Generic Xilinx Virtex 5 FXT board support\\
Math emulation\\
kexec (for reboot)\\
initial command string: console=ttyS0,115200 root=/dev/xsa2\\
default image types: simpleImage.virtex440-final\\ %TODO
devtmpfs + automount\\
Xilinx SystemACE\\
Xilinx LL TEMAC\\
Marvell PHYs\\
8250/16550 and compatible serial support\\
Serial port on Open Firmware platform bus\\
Console on 8250/16550 and compatible serial port\\
\\
arch/powerpc/boot/dts/virtex440-final.dts\\
pmake simpleImage.virtex440-final %TODO
\subsection{kernel module}
\section{Boostrap}
\subsection{build image}
\subsection{debug/test hw}
\subsection{build complete image}
\section{usage}
what how and why
\subsection{boot}
\subsection{sysfs}
\subsection{webinterface}


\clearpage
\appendices
\section{Registers}
\begin{register}{h}{reg(0)}{0x00}%
    \label{reg0}%
    \regfield{rec\_rst}{1}{31}{0}%
    \regfield{Reserved}{4}{27}{0}%
    \regfield{rec\_stream\_valid}{1}{26}{0}%
    \regfield{rec\_input\_select}{2}{24}{0}%
    \regfield{Reserved}{2}{22}{0}%
    \regfield{rec\_data\_valid(2)}{1}{21}{0}%
    \regfield{rec\_rxeqmix(2)}{2}{19}{0}%
    \regfield{rec\_descramble(2)}{1}{18}{1}%
    \regfield{rec\_polarity(2)}{1}{17}{1}%
    \regfield{rec\_enable(2)}{1}{16}{1}%
    \regfield{Reserved}{2}{14}{0}%
    \regfield{rec\_data\_valid(1)}{1}{13}{0}%
    \regfield{rec\_rxeqmix(1)}{2}{11}{0}%
    \regfield{rec\_descramble(1)}{1}{10}{1}%
    \regfield{rec\_polarity(1)}{1}{9}{1}%
    \regfield{rec\_enable(1)}{1}{8}{1}%
    \regfield{Reserved}{2}{6}{0}%
    \regfield{rec\_data\_valid(0)}{1}{5}{0}%
    \regfield{rec\_rxeqmix(0)}{2}{3}{0}%
    \regfield{rec\_descramble(0)}{1}{2}{1}%
    \regfield{rec\_polarity(0)}{1}{1}{1}%
    \regfield{rec\_enable(0)}{1}{0}{1}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[rec\_descramble(n)]
        \item[rec\_rst] Writing a 1 to this bit resets the whole receiver.
        \item[rec\_stream\_valid] 1 if stream is valid.
        \item[rec\_input\_select] With this the data stream of receivers 0 - 2
            can be selected.
        \item[rec\_data\_valid(n)] 1 if the data received by n is valid.
        \item[rec\_rxeqmix(n)] Controls the equalizer of the receiver
            \cite[p. 165f]{gtx}.
        \item[rec\_descramble(n)] Turns on the descrambler (see
            \Cref{sec:inbuf}).
        \item[rec\_polarity(n)] Sets the polarity of the LVDs pair.
        \item[rec\_enable(n)] Enable/Disable transceiver. Disabling unneeded
            transceivers saves power.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(1)}{0x04}%
    \label{reg1}%
    \regfield{avg\_rst}{1}{31}{0}%
    \regfield{Reserved}{3}{28}{0}%
    \regfield{avg\_err}{1}{27}{0}%
    \regfield{avg\_active}{1}{26}{0}%
    \regfield{avg\_width}{2}{24}{0}%
    \regfield{trig\_rst}{1}{23}{0}%
    \regfield{Reserved}{3}{19}{0}%
    \regfield{trig\_int}{1}{19}{0}%
    \regfield{trig\_arm}{1}{18}{0}%
    \regfield{Reserved}{1}{17}{0}%
    \regfield{trig\_type}{1}{16}{0}%
    \regfield{depth}{16}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[avg\_active]
        \item[avg\_rst] Writing a 1 to this bit resets \module{average\_mem}.
        \item[avg\_err] 1 if the data stream became invalid during data
            acquisition. Gets on next trigger event.
        \item[avg\_active] 1 during data acquisition.
        \item[avg\_width] Number of samples over which averaging is done:
            \begin{itemize}
                \item[0:] off.
                \item[1:] 2 samples.
                \item[2:] 4 samples.
                \item[3:] 8 samples.
            \end{itemize}
        \item[trig\_rst] Writing a 1 to this bit resets \module{trigger}. 
        \item[trig\_int] Writing a 1 to this bit manually triggers the
            internal trigger.
        \item[trig\_arm] Writing a 1 to this bit arms the trigger.
        \item[trig\_type] 0: Internal trigger. 1: External trigger.
        \item[depth] Number of samples to acquire. Can be range 1 - 49152.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(2)}{0x08}%
    \label{reg2}%
    \regfield{Reserved}{4}{28}{0}%
    \regfield{core\_scale\_schi}{12}{16}{011010101010}%
    \regfield{Reserved}{4}{12}{0}%
    \regfield{core\_scale\_sch}{12}{0}{011010101010}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[core\_scale\_schi]
        \item[core\_scale\_schi] Scaling schedule for iFFT run (See
            \cite[p. 24]{xilinx_fft}).
        \item[core\_scale\_sch] Scaling schedule for FFT run (See
            \cite[p. 24]{xilinx_fft}).
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(3)}{0x0C}%
    \label{reg3}%
    \regfield{core\_rst}{1}{31}{0}%
    \regfield{Reserved}{1}{30}{0}%
    \regfield{core\_circular}{1}{29}{0}%
    \regfield{core\_ov\_cmul}{1}{28}{0}%
    \regfield{core\_ov\_ifft}{1}{27}{0}%
    \regfield{core\_ov\_fft}{1}{26}{0}%
    \regfield{core\_start}{1}{25}{0}%
    \regfield{core\_iq}{1}{24}{0}%
    \regfield{Reserved}{3}{21}{0}%
    \regfield{core\_n}{5}{16}{00011}%
    \regfield{core\_scale\_cmul}{2}{14}{0}%
    \regfield{Reserved}{2}{12}{0}%
    \regfield{core\_L}{12}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[core\_scale\_cmul]
        \item[core\_rst] Writing a 1 to this bit resets \module{core}.
        \item[core\_circular] Set to 1 for circular convolution.
        \item[core\_ov\_cmul] 1 if complex multiplication has overflown.
        \item[core\_ov\_ifft] 1 if iFFT has overflown.
        \item[core\_ov\_fft] 1 if FFT has overflown.
        \item[core\_start] Write 1 to this bit to start a convolution run.
        \item[core\_iq] Set to 1 for I/Q demodulation.
        \item[core\_n] Transform size in $\log_2(nfft)$. Valid values:
            \begin{itemize}
                \item[3:] 8
                \item[4:] 16
                \item[5:] 32
                \item[6:] 64
                \item[7:] 128
                \item[8:] 256
                \item[9:] 512
                \item[10:] 1024
                \item[11:] 2048
                \item[12:] 4096
            \end{itemize}
        \item[core\_scale\_cmul] Scaling schedule for complex multiplication:
            \begin{itemize}
                \item[0:] $>> 17$.
                \item[1:] $>> 16$.
                \item[2:] $>> 15$.
                \item[3:] $>> 14$.
            \end{itemize}
        \item[core\_L] $L$. See \Cref{sec:core}.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(4)}{0x10}%
    \label{reg4}%
    \regfield{tx\_mulq}{16}{16}{0}%
    \regfield{tx\_muli}{16}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[tx\_mulq]
        \item[tx\_mulq] See \Cref{sec:outbuf}.
        \item[tx\_muli] See \Cref{sec:outbuf}.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{reg(5)}{0x14}%
    \label{reg5}%
    \regfield{tx\_shift}{2}{30}{0}%
    \regfield{tx\_ovfl}{1}{29}{0}%
    \regfield{tx\_sat}{1}{28}{1}%
    \regfield{Reserved}{3}{25}{0}%
    \regfield{mem\_req}{1}{24}{0}%
    \regfield{tx\_rst}{1}{23}{0}%
    \regfield{Reserved}{3}{20}{0}%
    \regfield{tx\_resync}{1}{19}{0}%
    \regfield{tx\_toggle}{1}{18}{0}%
    \regfield{tx\_dc\_balance}{1}{17}{0}%
    \regfield{tx\_deskew}{1}{16}{0}%
    \regfield{tx\_frame\_offset}{16}{0}{0}%
    \reglabel{Reset}\regnewline%
    \begin{regdesc}\begin{reglist}[tx\_frame\_offset]
        \item[tx\_shift] Scaling schedule for complex multiplication:
            \begin{itemize}
                \item[0:] $>> 17$.
                \item[1:] $>> 16$.
                \item[2:] $>> 15$.
                \item[3:] $>> 14$.
            \end{itemize}
        \item[tx\_ovfl] 1 if an overflow occurred in the complex multiplier.
            Write a 0 to this bit to reset the overflow.
        \item[tx\_sat] Enable saturation for complex multiplier.
        \item[mem\_req] Write a 1 to this bit to enable access to the
            memories. Accessing the memories is only safe if this bit is 1.
        \item[tx\_rst] Writing a 1 to this bit resets \module{outbuf}.
        \item[tx\_resync] Resynchronizes the sample output to
            tx\_frame\_offset on the internal frame clock.
        \item[tx\_toggle] Writing a 1 to this bit switches the output buffers.
        \item[tx\_dc\_balance] Turns DC balance on for the output. (See
            \cite[p. 11]{ds90cr485}).
        \item[tx\_deskew] Writing a 1 to this bit starts a deskew cycle. (See
            \cite[p. 12f]{ds90cr485}).
        \item[tx\_frame\_offset] Frame offset.
    \end{reglist}\end{regdesc}
\end{register}
\begin{register}{h}{intr}{0x220}%
    \label{intr}%
    \regfield{Reserved}{19}{13}{0}%
    \regfield{tx\_ovfl}{1}{12}{0}%
    \regfield{tx\_toggled}{1}{11}{0}%
    \regfield{core\_done}{1}{10}{0}%
    \regfield{avg\_done}{1}{9}{0}%
    \regfield{trigd}{1}{8}{0}%
    \regfield{stream\_invalid}{1}{7}{0}%
    \regfield{stream\_valid}{1}{6}{0}%
    \regfield{rec2\_invalid}{1}{5}{0}%
    \regfield{rec2\_valid}{1}{4}{0}%
    \regfield{rec1\_invalid}{1}{3}{0}%
    \regfield{rec1\_valid}{1}{2}{0}%
    \regfield{rec0\_invalid}{1}{1}{0}%
    \regfield{rec0\_valid}{1}{0}{0}%
    \reglabel{Reset}\regnewline%
\end{register}

\clearpage

\bibliographystyle{IEEEtran}
\begingroup
\raggedright
\sloppy
\bibliography{IEEEabrv,literature}
\endgroup

\end{document}
